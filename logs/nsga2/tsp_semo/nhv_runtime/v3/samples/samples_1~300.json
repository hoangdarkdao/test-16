[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8142085941284019,
            0.571387529373169
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8142085941284019,
            0.571387529373169
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8142085941284019,
            0.571387529373169
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9448300072074868,
            1.8027246594429016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9448300072074868,
            1.8027246594429016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.81865648773061,
            0.2664041519165039
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.81865648773061,
            0.2664041519165039
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution, (cost1, cost2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert (ensuring feasibility)\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply a multi-objective-aware 3-opt move to further refine the solution\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Evaluate the two possible 3-opt moves and choose the one that improves the most\n    option1 = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n    option2 = np.concatenate([new_solution[:i], segment2[::-1], segment1, new_solution[k:]])\n\n    # Calculate the cost difference for both options\n    def calculate_cost(solution):\n        total1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        total2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return total1, total2\n\n    cost1_orig, cost2_orig = calculate_cost(new_solution)\n    cost1_opt1, cost2_opt1 = calculate_cost(option1)\n    cost1_opt2, cost2_opt2 = calculate_cost(option2)\n\n    # Choose the option that improves both objectives or the one that improves the most\n    if (cost1_opt1 < cost1_orig and cost2_opt1 < cost2_orig) or (cost1_opt2 < cost1_orig and cost2_opt2 < cost2_orig):\n        if cost1_opt1 + cost2_opt1 < cost1_opt2 + cost2_opt2:\n            new_solution = option1\n        else:\n            new_solution = option2\n    else:\n        if (cost1_opt1 < cost1_orig or cost2_opt1 < cost2_orig) and (cost1_opt1 + cost2_opt1 < cost1_opt2 + cost2_opt2):\n            new_solution = option1\n        elif (cost1_opt2 < cost1_orig or cost2_opt2 < cost2_orig):\n            new_solution = option2\n\n    return new_solution\n\n",
        "score": [
            -0.869824652952374,
            0.45603346824645996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution, (cost1, cost2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert (ensuring feasibility)\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply a multi-objective-aware 3-opt move to further refine the solution\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Evaluate the two possible 3-opt moves and choose the one that improves the most\n    option1 = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n    option2 = np.concatenate([new_solution[:i], segment2[::-1], segment1, new_solution[k:]])\n\n    # Calculate the cost difference for both options\n    def calculate_cost(solution):\n        total1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        total2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return total1, total2\n\n    cost1_orig, cost2_orig = calculate_cost(new_solution)\n    cost1_opt1, cost2_opt1 = calculate_cost(option1)\n    cost1_opt2, cost2_opt2 = calculate_cost(option2)\n\n    # Choose the option that improves both objectives or the one that improves the most\n    if (cost1_opt1 < cost1_orig and cost2_opt1 < cost2_orig) or (cost1_opt2 < cost1_orig and cost2_opt2 < cost2_orig):\n        if cost1_opt1 + cost2_opt1 < cost1_opt2 + cost2_opt2:\n            new_solution = option1\n        else:\n            new_solution = option2\n    else:\n        if (cost1_opt1 < cost1_orig or cost2_opt1 < cost2_orig) and (cost1_opt1 + cost2_opt1 < cost1_opt2 + cost2_opt2):\n            new_solution = option1\n        elif (cost1_opt2 < cost1_orig or cost2_opt2 < cost2_orig):\n            new_solution = option2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The heuristic function uses a hybrid local search strategy that combines adaptive edge selection with a novel segment inversion operator, prioritizing solutions with high crowding distance in the Pareto front and dynamically adjusting the search radius based on the instance's diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution in the archive\n    def calculate_crowding_distance(archive):\n        if len(archive) < 3:\n            return [1.0] * len(archive)\n\n        # Sort by each objective\n        sorted_obj1 = sorted([(sol[1][0], i) for i, sol in enumerate(archive)])\n        sorted_obj2 = sorted([(sol[1][1], i) for i, sol in enumerate(archive)])\n\n        # Initialize crowding distance\n        crowding = [0.0] * len(archive)\n\n        # Calculate crowding distance for each objective\n        for obj in [sorted_obj1, sorted_obj2]:\n            crowding[obj[0][1]] = float('inf')\n            crowding[obj[-1][1]] = float('inf')\n\n            for i in range(1, len(obj) - 1):\n                idx = obj[i][1]\n                prev_idx = obj[i-1][1]\n                next_idx = obj[i+1][1]\n                crowding[idx] += (obj[i+1][0] - obj[i-1][0]) / (obj[-1][0] - obj[0][0] + 1e-10)\n\n        return crowding\n\n    crowding_distances = calculate_crowding_distance(archive)\n\n    # Select a solution with high crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: adaptive segment inversion\n    def adaptive_segment_inversion(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        # Calculate segment scores based on both objectives\n        segment_scores = []\n        for i in range(n):\n            for j in range(i + 2, min(i + 10, n)):  # Limit segment length\n                # Calculate improvement in both objectives\n                original_cost1 = distance_matrix_1[solution[i-1], solution[i]] + distance_matrix_1[solution[j], solution[(j+1)%n]]\n                original_cost2 = distance_matrix_2[solution[i-1], solution[i]] + distance_matrix_2[solution[j], solution[(j+1)%n]]\n\n                inverted_cost1 = distance_matrix_1[solution[i-1], solution[j]] + distance_matrix_1[solution[i], solution[(j+1)%n]]\n                inverted_cost2 = distance_matrix_2[solution[i-1], solution[j]] + distance_matrix_2[solution[i], solution[(j+1)%n]]\n\n                # Normalize improvements\n                improvement1 = (original_cost1 - inverted_cost1) / (original_cost1 + 1e-10)\n                improvement2 = (original_cost2 - inverted_cost2) / (original_cost2 + 1e-10)\n\n                # Combined score\n                score = improvement1 + improvement2\n                segment_scores.append((score, i, j))\n\n        if not segment_scores:\n            return solution.copy()\n\n        # Select best segment to invert\n        best_score, i, j = max(segment_scores, key=lambda x: x[0])\n        if best_score <= 0:\n            return solution.copy()\n\n        # Perform inversion\n        new_solution = solution.copy()\n        new_solution[i:j+1] = solution[i:j+1][::-1]\n\n        return new_solution\n\n    new_solution = adaptive_segment_inversion(base_solution, distance_matrix_1, distance_matrix_2, instance)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to simple swap if inversion causes duplicates\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(len(base_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8554769878639911,
            6.6125001311302185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution in the archive\n    def calculate_crowding_distance(archive):\n        if len(archive) < 3:\n            return [1.0] * len(archive)\n\n        # Sort by each objective\n        sorted_obj1 = sorted([(sol[1][0], i) for i, sol in enumerate(archive)])\n        sorted_obj2 = sorted([(sol[1][1], i) for i, sol in enumerate(archive)])\n\n        # Initialize crowding distance\n        crowding = [0.0] * len(archive)\n\n        # Calculate crowding distance for each objective\n        for obj in [sorted_obj1, sorted_obj2]:\n            crowding[obj[0][1]] = float('inf')\n            crowding[obj[-1][1]] = float('inf')\n\n            for i in range(1, len(obj) - 1):\n                idx = obj[i][1]\n                prev_idx = obj[i-1][1]\n                next_idx = obj[i+1][1]\n                crowding[idx] += (obj[i+1][0] - obj[i-1][0]) / (obj[-1][0] - obj[0][0] + 1e-10)\n\n        return crowding\n\n    crowding_distances = calculate_crowding_distance(archive)\n\n    # Select a solution with high crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: adaptive segment inversion\n    def adaptive_segment_inversion(solution, distance_matrix_1, distance_matrix_2, instance):\n        n = len(solution)\n        # Calculate segment scores based on both objectives\n        segment_scores = []\n        for i in range(n):\n            for j in range(i + 2, min(i + 10, n)):  # Limit segment length\n                # Calculate improvement in both objectives\n                original_cost1 = distance_matrix_1[solution[i-1], solution[i]] + distance_matrix_1[solution[j], solution[(j+1)%n]]\n                original_cost2 = distance_matrix_2[solution[i-1], solution[i]] + distance_matrix_2[solution[j], solution[(j+1)%n]]\n\n                inverted_cost1 = distance_matrix_1[solution[i-1], solution[j]] + distance_matrix_1[solution[i], solution[(j+1)%n]]\n                inverted_cost2 = distance_matrix_2[solution[i-1], solution[j]] + distance_matrix_2[solution[i], solution[(j+1)%n]]\n\n                # Normalize improvements\n                improvement1 = (original_cost1 - inverted_cost1) / (original_cost1 + 1e-10)\n                improvement2 = (original_cost2 - inverted_cost2) / (original_cost2 + 1e-10)\n\n                # Combined score\n                score = improvement1 + improvement2\n                segment_scores.append((score, i, j))\n\n        if not segment_scores:\n            return solution.copy()\n\n        # Select best segment to invert\n        best_score, i, j = max(segment_scores, key=lambda x: x[0])\n        if best_score <= 0:\n            return solution.copy()\n\n        # Perform inversion\n        new_solution = solution.copy()\n        new_solution[i:j+1] = solution[i:j+1][::-1]\n\n        return new_solution\n\n    new_solution = adaptive_segment_inversion(base_solution, distance_matrix_1, distance_matrix_2, instance)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to simple swap if inversion causes duplicates\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(len(base_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the best Pareto front dominance, then applies a novel local search combining adaptive node insertion and guided segment relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(15):\n        # Adaptive node insertion\n        if random.random() < 0.4:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (i + j) // 2\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Guided segment relinking\n        if random.random() < 0.6:\n            seg_start = random.randint(0, n-3)\n            seg_end = random.randint(seg_start+1, n-2)\n            segment = new_solution[seg_start:seg_end+1]\n            new_solution[seg_start:seg_end+1] = segment[::-1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6804010431660292,
            0.6771335601806641
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(15):\n        # Adaptive node insertion\n        if random.random() < 0.4:\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (i + j) // 2\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Guided segment relinking\n        if random.random() < 0.6:\n            seg_start = random.randint(0, n-3)\n            seg_end = random.randint(seg_start+1, n-2)\n            segment = new_solution[seg_start:seg_end+1]\n            new_solution[seg_start:seg_end+1] = segment[::-1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with non-dominated objectives, then applies a novel multi-objective-aware segment rotation that combines elements of both objective spaces to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = archive[np.random.choice(len(archive))][0].copy()\n    else:\n        base_solution = non_dominated[np.random.choice(len(non_dominated))].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment rotation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Determine rotation direction based on both objectives\n    # Calculate cost difference for both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    rotated_segment = segment[::-1]\n    candidate = new_solution.copy()\n    candidate[a:b+1] = rotated_segment\n\n    rotated_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n    rotated_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n    # Calculate dominance relationship\n    dominates = (rotated_cost1 <= original_cost1 and rotated_cost2 <= original_cost2 and\n                (rotated_cost1 < original_cost1 or rotated_cost2 < original_cost2))\n\n    if dominates:\n        new_solution = candidate\n    else:\n        # Alternative: rotate based on which objective has higher improvement\n        if (original_cost1 - rotated_cost1) > (original_cost2 - rotated_cost2):\n            # Rotate based on first objective\n            new_solution[a:b+1] = rotated_segment\n        else:\n            # Rotate based on second objective\n            new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9045322115781274,
            0.5668517351150513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = archive[np.random.choice(len(archive))][0].copy()\n    else:\n        base_solution = non_dominated[np.random.choice(len(non_dominated))].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective-aware segment rotation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Determine rotation direction based on both objectives\n    # Calculate cost difference for both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    rotated_segment = segment[::-1]\n    candidate = new_solution.copy()\n    candidate[a:b+1] = rotated_segment\n\n    rotated_cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n    rotated_cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n    # Calculate dominance relationship\n    dominates = (rotated_cost1 <= original_cost1 and rotated_cost2 <= original_cost2 and\n                (rotated_cost1 < original_cost1 or rotated_cost2 < original_cost2))\n\n    if dominates:\n        new_solution = candidate\n    else:\n        # Alternative: rotate based on which objective has higher improvement\n        if (original_cost1 - rotated_cost1) > (original_cost2 - rotated_cost2):\n            # Rotate based on first objective\n            new_solution[a:b+1] = rotated_segment\n        else:\n            # Rotate based on second objective\n            new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel hybrid local search operator combines a multi-objective-aware node insertion with a randomized segment rotation, prioritizing nodes with high edge dominance and segments with low edge diversity, while ensuring feasibility through a dominance-aware acceptance criterion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge dominance (randomly choose among top 30% by edge dominance)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_dominance = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_dominance.append(unique_edges)\n\n    top_indices = np.argsort(edge_dominance)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: node insertion + segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion: insert a random node at a new position if it improves both objectives\n    node_to_insert = np.random.choice(new_solution)\n    pos = np.random.randint(0, n)\n    candidate = np.insert(new_solution, pos, node_to_insert)\n    candidate = np.delete(candidate, np.where(candidate == node_to_insert)[0][1])\n\n    # Check feasibility and objective improvement\n    if len(set(candidate)) == n:\n        # Calculate new objectives\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if both objectives are not worse\n        old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if cost1 <= old_cost1 and cost2 <= old_cost2:\n            new_solution = candidate\n\n    # Segment rotation: rotate a random segment by a random amount\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    rotation = np.random.randint(1, b - a + 1)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8811456086305613,
            0.7861578464508057
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge dominance (randomly choose among top 30% by edge dominance)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_dominance = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_dominance.append(unique_edges)\n\n    top_indices = np.argsort(edge_dominance)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: node insertion + segment rotation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Node insertion: insert a random node at a new position if it improves both objectives\n    node_to_insert = np.random.choice(new_solution)\n    pos = np.random.randint(0, n)\n    candidate = np.insert(new_solution, pos, node_to_insert)\n    candidate = np.delete(candidate, np.where(candidate == node_to_insert)[0][1])\n\n    # Check feasibility and objective improvement\n    if len(set(candidate)) == n:\n        # Calculate new objectives\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if both objectives are not worse\n        old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if cost1 <= old_cost1 and cost2 <= old_cost2:\n            new_solution = candidate\n\n    # Segment rotation: rotate a random segment by a random amount\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    rotation = np.random.randint(1, b - a + 1)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{A novel hybrid local search operator combines a multi-objective-aware partial tour reordering with a randomized segment insertion, prioritizing segments with high edge dominance in both objective spaces while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge dominance (randomly choose among top 30% by edge dominance)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_dominance = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        dominance = 0\n        for (u, v) in edges:\n            if distance_matrix_1[u, v] < distance_matrix_1[v, u] and distance_matrix_2[u, v] < distance_matrix_2[v, u]:\n                dominance += 1\n        edge_dominance.append(dominance)\n\n    top_indices = np.argsort(edge_dominance)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: partial tour reordering + segment insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reorder\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Segment insertion: insert a segment at a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting segment [i, j] at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.869018837481724,
            2.2245197892189026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge dominance (randomly choose among top 30% by edge dominance)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_dominance = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        dominance = 0\n        for (u, v) in edges:\n            if distance_matrix_1[u, v] < distance_matrix_1[v, u] and distance_matrix_2[u, v] < distance_matrix_2[v, u]:\n                dominance += 1\n        edge_dominance.append(dominance)\n\n    top_indices = np.argsort(edge_dominance)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: partial tour reordering + segment insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reorder\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Segment insertion: insert a segment at a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting segment [i, j] at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{An adaptive segment mutation operator that combines randomized segment rotation with a multi-objective-aware edge swapping mechanism, prioritizing segments with high edge diversity and low dominance while dynamically adjusting the mutation intensity based on solution quality and objective trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity and low dominance\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    edge_diversity = []\n    for sol, _ in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    # Combine diversity and dominance (lower objective values are better)\n    scores = []\n    for i, (_, obj) in enumerate(archive_solutions):\n        diversity_score = edge_diversity[i] / max(edge_diversity)\n        dominance_score = 1 / (1 + obj[0] + obj[1])  # Higher for better solutions\n        scores.append(diversity_score * 0.7 + dominance_score * 0.3)\n\n    top_indices = np.argsort(scores)[-max(1, len(archive) // 2):]\n    selected_index = np.random.choice(top_indices)\n    selected_solution = archive_solutions[selected_index][0].copy()\n\n    # Apply adaptive segment mutation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine mutation intensity based on solution quality\n    current_obj = archive_solutions[selected_index][1]\n    mutation_intensity = min(0.5, 0.2 + 0.3 * (current_obj[0] + current_obj[1]) / (n * 100))\n\n    # Randomly select a segment to rotate\n    segment_length = max(2, int(mutation_intensity * n))\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    # Rotate the segment\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Edge swapping with multi-objective awareness\n    for _ in range(max(1, int(mutation_intensity * n))):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and i != (j-1)%n and j != (i+1)%n:\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n            # Calculate new objectives\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Accept if not dominated\n            old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (cost1 <= old_cost1 and cost2 < old_cost2) or (cost1 < old_cost1 and cost2 <= old_cost2):\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8214770227788905,
            1.0226565599441528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity and low dominance\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    edge_diversity = []\n    for sol, _ in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    # Combine diversity and dominance (lower objective values are better)\n    scores = []\n    for i, (_, obj) in enumerate(archive_solutions):\n        diversity_score = edge_diversity[i] / max(edge_diversity)\n        dominance_score = 1 / (1 + obj[0] + obj[1])  # Higher for better solutions\n        scores.append(diversity_score * 0.7 + dominance_score * 0.3)\n\n    top_indices = np.argsort(scores)[-max(1, len(archive) // 2):]\n    selected_index = np.random.choice(top_indices)\n    selected_solution = archive_solutions[selected_index][0].copy()\n\n    # Apply adaptive segment mutation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Determine mutation intensity based on solution quality\n    current_obj = archive_solutions[selected_index][1]\n    mutation_intensity = min(0.5, 0.2 + 0.3 * (current_obj[0] + current_obj[1]) / (n * 100))\n\n    # Randomly select a segment to rotate\n    segment_length = max(2, int(mutation_intensity * n))\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n\n    # Rotate the segment\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Edge swapping with multi-objective awareness\n    for _ in range(max(1, int(mutation_intensity * n))):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i != j and i != (j-1)%n and j != (i+1)%n:\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n            # Calculate new objectives\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Accept if not dominated\n            old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (cost1 <= old_cost1 and cost2 < old_cost2) or (cost1 < old_cost1 and cost2 <= old_cost2):\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9604449175379328,
            2.4669695496559143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9604449175379328,
            2.4669695496559143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.9542055396975432,
            2.0111894607543945
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high edge diversity and low dominance, then applies a novel hybrid local search combining multi-objective-aware segment insertion with adaptive edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity and low dominance\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    dominance_scores = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n        # Calculate dominance score (lower is better)\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        dominance_scores.append(cost1 + cost2)\n\n    # Combine scores (higher diversity and lower dominance preferred)\n    combined_scores = [div - dom for div, dom in zip(edge_diversity, dominance_scores)]\n    top_indices = np.argsort(combined_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment insertion + edge flipping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment insertion: extract a segment and insert it at a different position\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Adaptive edge flipping: flip edges based on multi-objective improvement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or i == (j-1)%n or j == (i+1)%n:\n            continue\n\n        # Create candidate solution with flipped edge\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Check feasibility and objective improvement\n        if len(set(candidate)) == n:\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (cost1 <= old_cost1 and cost2 <= old_cost2) or (random.random() < 0.2):\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.9349490132364371,
            2.44540673494339
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity and low dominance\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    dominance_scores = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n        # Calculate dominance score (lower is better)\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        dominance_scores.append(cost1 + cost2)\n\n    # Combine scores (higher diversity and lower dominance preferred)\n    combined_scores = [div - dom for div, dom in zip(edge_diversity, dominance_scores)]\n    top_indices = np.argsort(combined_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment insertion + edge flipping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Segment insertion: extract a segment and insert it at a different position\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Adaptive edge flipping: flip edges based on multi-objective improvement\n    for _ in range(5):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or i == (j-1)%n or j == (i+1)%n:\n            continue\n\n        # Create candidate solution with flipped edge\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Check feasibility and objective improvement\n        if len(set(candidate)) == n:\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (cost1 <= old_cost1 and cost2 <= old_cost2) or (random.random() < 0.2):\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals, followed by a novel node insertion step to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if random.random() < 0.3:\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n        if random.random() < 0.2:\n            node = random.randint(0, n-1)\n            pos = random.randint(0, n-1)\n            if node != pos:\n                new_solution = np.insert(np.delete(new_solution, node), pos, new_solution[node])\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7856741184261433,
            0.6384408473968506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if random.random() < 0.3:\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n        if random.random() < 0.2:\n            node = random.randint(0, n-1)\n            pos = random.randint(0, n-1)\n            if node != pos:\n                new_solution = np.insert(np.delete(new_solution, node), pos, new_solution[node])\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{The new algorithm selects a random solution from the archive, applies a combination of segment reversal and node insertion operations to explore the solution space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply node insertions to further improve the solution\n    insert_count = random.randint(1, min(2, n // 3))\n    for _ in range(insert_count):\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.9257964444771472,
            0.30526578426361084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply node insertions to further improve the solution\n    insert_count = random.randint(1, min(2, n // 3))\n    for _ in range(insert_count):\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a weighted combination of objective values, applies a hybrid local search combining segment reversal and edge swaps with adaptive intensity, and ensures feasibility by validating the neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(2))\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Adaptive segment reversal\n    segment_size = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Adaptive edge swaps\n    swap_count = random.randint(1, min(3, n // 3))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8955504840450902,
            0.32410454750061035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.dirichlet(np.ones(2))\n    scores = np.dot(objectives, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Adaptive segment reversal\n    segment_size = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Adaptive edge swaps\n    swap_count = random.randint(1, min(3, n // 3))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on objective diversity, applies a hybrid local search combining segment reversal with adaptive edge swaps, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        selected_idx = np.argmax([np.std([o1, o2]) for o1, o2 in objectives])\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Adaptive segment reversal\n    segment_size = min(4, n // 2)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Adaptive edge swaps based on distance matrices\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] > \\\n           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7112419725311503,
            0.9188068509101868
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        selected_idx = np.argmax([np.std([o1, o2]) for o1, o2 in objectives])\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Adaptive segment reversal\n    segment_size = min(4, n // 2)\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size - 1\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Adaptive edge swaps based on distance matrices\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] > \\\n           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0301725358101428,
            0.4450001120567322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0301725358101428,
            0.4450001120567322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high edge diversity in either objective space, then applies a hybrid local search combining adaptive segment reversals and multi-objective-aware 3-opt moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity in either objective space\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on unique edges in each space\n        edges1 = set((sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol)))\n        edges2 = set((sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol)))\n        diversity_scores.append(max(len(edges1), len(edges2)))\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 4):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversals and 3-opt moves\n    for _ in range(5):\n        # Adaptive segment reversal\n        if random.random() < 0.3:\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(6, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n        # Multi-objective-aware 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n            # Try different configurations\n            for config in [(i, j, k), (i, k, j), (j, i, k)]:\n                a, b, c = config\n                new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[c]] +\n                             distance_matrix_1[new_solution[c-1], new_solution[a]])\n                new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                             distance_matrix_2[new_solution[c-1], new_solution[a]])\n\n                if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                    new_solution[a:b] = new_solution[a:b][::-1]\n                    new_solution[b:c] = new_solution[b:c][::-1]\n                    break\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9519565463524635,
            2.6247109174728394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity in either objective space\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on unique edges in each space\n        edges1 = set((sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol)))\n        edges2 = set((sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol)))\n        diversity_scores.append(max(len(edges1), len(edges2)))\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 4):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment reversals and 3-opt moves\n    for _ in range(5):\n        # Adaptive segment reversal\n        if random.random() < 0.3:\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(6, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n        # Multi-objective-aware 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i != j and j != k:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n            # Try different configurations\n            for config in [(i, j, k), (i, k, j), (j, i, k)]:\n                a, b, c = config\n                new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b-1], new_solution[c]] +\n                             distance_matrix_1[new_solution[c-1], new_solution[a]])\n                new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b-1], new_solution[c]] +\n                             distance_matrix_2[new_solution[c-1], new_solution[a]])\n\n                if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                    new_solution[a:b] = new_solution[a:b][::-1]\n                    new_solution[b:c] = new_solution[b:c][::-1]\n                    break\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a novel \"objective-balanced inversion\" local search that inverts segments of the tour with consideration for both objectives, ensuring feasibility while promoting diverse solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        crowding[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n\n    selected_index = np.argmax(crowding)\n    selected_solution = archive[selected_index][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-balanced inversion\n    for _ in range(3):\n        # Select random segment\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate objective changes\n        old_edges = [(new_solution[k-1], new_solution[k]) for k in range(n)]\n        old_cost1 = sum(distance_matrix_1[a, b] for a, b in old_edges)\n        old_cost2 = sum(distance_matrix_2[a, b] for a, b in old_edges)\n\n        # Invert segment\n        inverted_segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        new_edges = [(new_solution[k-1], new_solution[k]) for k in range(n)]\n        new_cost1 = sum(distance_matrix_1[a, b] for a, b in new_edges)\n        new_cost2 = sum(distance_matrix_2[a, b] for a, b in new_edges)\n\n        # Accept if both objectives are not worse\n        if new_cost1 > old_cost1 or new_cost2 > old_cost2:\n            new_solution = selected_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9209956909671262,
            2.5874937772750854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    crowding = np.zeros(len(archive))\n\n    for i in range(1, len(archive)-1):\n        crowding[i] = (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n\n    selected_index = np.argmax(crowding)\n    selected_solution = archive[selected_index][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Objective-balanced inversion\n    for _ in range(3):\n        # Select random segment\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate objective changes\n        old_edges = [(new_solution[k-1], new_solution[k]) for k in range(n)]\n        old_cost1 = sum(distance_matrix_1[a, b] for a, b in old_edges)\n        old_cost2 = sum(distance_matrix_2[a, b] for a, b in old_edges)\n\n        # Invert segment\n        inverted_segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        new_edges = [(new_solution[k-1], new_solution[k]) for k in range(n)]\n        new_cost1 = sum(distance_matrix_1[a, b] for a, b in new_edges)\n        new_cost2 = sum(distance_matrix_2[a, b] for a, b in new_edges)\n\n        # Accept if both objectives are not worse\n        if new_cost1 > old_cost1 or new_cost2 > old_cost2:\n            new_solution = selected_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a novel local search combining adaptive segment reversals and multi-objective-aware node insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        if random.random() < 0.5:\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(set(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8904349443661241,
            1.5749085545539856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        if random.random() < 0.5:\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(set(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This heuristic selects a solution from the archive using a multi-criteria approach that balances solution quality and diversity, then applies a novel local search combining adaptive segment insertion and objective-aware edge flips to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Selection criteria: balance between quality and diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate quality scores (lower is better for both objectives)\n    quality_scores = [sum(obj) for obj in objectives]\n\n    # Calculate diversity scores (higher is better)\n    diversity_scores = []\n    for sol in solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        diversity_scores.append(len(set(edges)))\n\n    # Combine scores (normalized)\n    combined_scores = []\n    min_quality = min(quality_scores)\n    max_quality = max(quality_scores)\n    min_diversity = min(diversity_scores)\n    max_diversity = max(diversity_scores)\n\n    for q, d in zip(quality_scores, diversity_scores):\n        norm_q = (q - min_quality) / (max_quality - min_quality + 1e-6)\n        norm_d = (d - min_diversity) / (max_diversity - min_diversity + 1e-6)\n        combined_scores.append(0.7 * norm_q + 0.3 * norm_d)  # Quality weighted more\n\n    # Select top 30% solutions\n    top_indices = np.argsort(combined_scores)[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    if n > 3:\n        seg_length = random.randint(2, min(5, n // 2))\n        seg_start = random.randint(0, n - seg_length - 1)\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Remove segment and insert elsewhere\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_length:]\n        ])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Objective-aware edge flips\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate change in objectives\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]])\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Accept if at least one objective improves\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9103281930210947,
            0.5151994824409485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Selection criteria: balance between quality and diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate quality scores (lower is better for both objectives)\n    quality_scores = [sum(obj) for obj in objectives]\n\n    # Calculate diversity scores (higher is better)\n    diversity_scores = []\n    for sol in solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        diversity_scores.append(len(set(edges)))\n\n    # Combine scores (normalized)\n    combined_scores = []\n    min_quality = min(quality_scores)\n    max_quality = max(quality_scores)\n    min_diversity = min(diversity_scores)\n    max_diversity = max(diversity_scores)\n\n    for q, d in zip(quality_scores, diversity_scores):\n        norm_q = (q - min_quality) / (max_quality - min_quality + 1e-6)\n        norm_d = (d - min_diversity) / (max_diversity - min_diversity + 1e-6)\n        combined_scores.append(0.7 * norm_q + 0.3 * norm_d)  # Quality weighted more\n\n    # Select top 30% solutions\n    top_indices = np.argsort(combined_scores)[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    if n > 3:\n        seg_length = random.randint(2, min(5, n // 2))\n        seg_start = random.randint(0, n - seg_length - 1)\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Remove segment and insert elsewhere\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_length:]\n        ])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Objective-aware edge flips\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate change in objectives\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]])\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[j-1], new_solution[i]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Accept if at least one objective improves\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a hybrid local search combining adaptive segment rotations and multi-objective-aware edge swaps to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high diversity in both objective spaces\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        # Calculate diversity based on edge differences in both spaces\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n\n        # Calculate diversity as the number of unique edges in both spaces\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment rotation and edge swaps\n    for _ in range(5):  # Number of local search iterations\n        # Adaptive segment rotation\n        if random.random() < 0.4:  # 40% chance for rotation\n            seg_start = random.randint(0, n-2)\n            seg_length = random.randint(1, min(5, n-seg_start-1))\n            seg_end = seg_start + seg_length\n            rotation = random.randint(1, seg_length)\n\n            # Rotate segment\n            segment = new_solution[seg_start:seg_end]\n            rotated = np.roll(segment, rotation)\n            new_solution[seg_start:seg_end] = rotated\n\n        # Multi-objective-aware edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Calculate change in objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]])\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            # Accept if both objectives are not worse\n            if new_cost1 <= old_cost1 and new_cost2 <= old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to selected solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high diversity in both objective spaces, then applies a novel local search combining multi-objective-aware segment reversals and adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = segment[::-1]\n\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            if not (new_cost1 <= old_cost1 and new_cost2 <= old_cost2):\n                new_solution[i:j+1] = segment\n\n        else:\n            i, j = random.sample(range(n), 2)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = (i + 1) % (n - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n                old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]] + distance_matrix_1[new_solution[insert_pos-1], new_solution[insert_pos]]\n                new_cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[(i+1)%(n-1)]]\n                old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]] + distance_matrix_2[new_solution[insert_pos-1], new_solution[insert_pos]]\n                new_cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[(i+1)%(n-1)]]\n\n                if not (new_cost1 <= old_cost1 and new_cost2 <= old_cost2):\n                    new_solution = np.delete(new_solution, insert_pos)\n                    new_solution = np.insert(new_solution, j, node)\n\n    if len(set(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9008265834504676,
            0.6285785436630249
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n\n    for sol in archive_solutions:\n        edges1 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        edges2 = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        diversity1 = len(set(edges1))\n        diversity2 = len(set(edges2))\n        diversity_scores.append(diversity1 + diversity2)\n\n    top_indices = np.argsort(diversity_scores)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(5):\n        if random.random() < 0.5:\n            i, j = sorted(random.sample(range(n), 2))\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = segment[::-1]\n\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            if not (new_cost1 <= old_cost1 and new_cost2 <= old_cost2):\n                new_solution[i:j+1] = segment\n\n        else:\n            i, j = random.sample(range(n), 2)\n            if i != j:\n                node = new_solution[j]\n                new_solution = np.delete(new_solution, j)\n                insert_pos = (i + 1) % (n - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n                old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]] + distance_matrix_1[new_solution[insert_pos-1], new_solution[insert_pos]]\n                new_cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[(i+1)%(n-1)]]\n                old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]] + distance_matrix_2[new_solution[insert_pos-1], new_solution[insert_pos]]\n                new_cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[(i+1)%(n-1)]]\n\n                if not (new_cost1 <= old_cost1 and new_cost2 <= old_cost2):\n                    new_solution = np.delete(new_solution, insert_pos)\n                    new_solution = np.insert(new_solution, j, node)\n\n    if len(set(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a combination of objective diversity and local improvement potential, then applies a novel hybrid local search operator that combines segment insertion and 3-opt moves to explore non-dominated regions while ensuring feasibility through careful validation of all generated solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by combined objective values and select a middle solution\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        base_solution = sorted_archive[len(sorted_archive)//2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment insertion followed by 3-opt\n    if n > 3:\n        # Segment insertion\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7826341212264918,
            0.2913306951522827
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by combined objective values and select a middle solution\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        base_solution = sorted_archive[len(sorted_archive)//2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment insertion followed by 3-opt\n    if n > 3:\n        # Segment insertion\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space node reordering\" local search that intelligently reorders nodes based on their relative positions in both objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Calculate node importance based on cross-space distances\n        node_importance = []\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate importance as the sum of distances in both spaces\n            importance = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                         distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n            node_importance.append(importance)\n\n        # Find the least important node to move\n        least_important_idx = np.argmin(node_importance)\n        node_to_move = new_solution[least_important_idx]\n\n        # Find the best position to insert the moved node\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == least_important_idx or pos == (least_important_idx + 1) % n:\n                continue\n\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[prev_node, next_node] +\n                        distance_matrix_2[prev_node, next_node])\n            new_cost = (distance_matrix_1[prev_node, node_to_move] +\n                        distance_matrix_1[node_to_move, next_node] +\n                        distance_matrix_2[prev_node, node_to_move] +\n                        distance_matrix_2[node_to_move, next_node])\n\n            improvement = new_cost - old_cost\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the node and insert it at the best position\n            new_solution = np.concatenate([\n                new_solution[:least_important_idx],\n                new_solution[least_important_idx+1:]\n            ])\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node_to_move],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8829237055877395,
            0.4161815643310547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Calculate node importance based on cross-space distances\n        node_importance = []\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate importance as the sum of distances in both spaces\n            importance = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                         distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n            node_importance.append(importance)\n\n        # Find the least important node to move\n        least_important_idx = np.argmin(node_importance)\n        node_to_move = new_solution[least_important_idx]\n\n        # Find the best position to insert the moved node\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == least_important_idx or pos == (least_important_idx + 1) % n:\n                continue\n\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[prev_node, next_node] +\n                        distance_matrix_2[prev_node, next_node])\n            new_cost = (distance_matrix_1[prev_node, node_to_move] +\n                        distance_matrix_1[node_to_move, next_node] +\n                        distance_matrix_2[prev_node, node_to_move] +\n                        distance_matrix_2[node_to_move, next_node])\n\n            improvement = new_cost - old_cost\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the node and insert it at the best position\n            new_solution = np.concatenate([\n                new_solution[:least_important_idx],\n                new_solution[least_important_idx+1:]\n            ])\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node_to_move],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a novel \"space-aware edge inversion\" operator that flips segments of the tour while considering both objective spaces to create balanced improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Space-aware edge inversion\n    if n > 2:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-2)\n        seg_length = random.randint(2, min(5, n-seg_start))\n\n        # Invert the segment\n        segment = new_solution[seg_start:seg_start+seg_length]\n        inverted_segment = segment[::-1]\n\n        # Calculate cost changes in both spaces\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Only accept if improves at least one objective\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0001766922816826,
            1.94050794839859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Space-aware edge inversion\n    if n > 2:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-2)\n        seg_length = random.randint(2, min(5, n-seg_start))\n\n        # Invert the segment\n        segment = new_solution[seg_start:seg_start+seg_length]\n        inverted_segment = segment[::-1]\n\n        # Calculate cost changes in both spaces\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Only accept if improves at least one objective\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with lower combined objective values, then applies a hybrid local search combining randomized edge swaps and adaptive segment reversals to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 3, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge swaps and adaptive segment reversals\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Random edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Adaptive segment reversal\n        if random.random() < 0.3:  # 30% chance for segment reversal\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator combines a randomized segment reversal with a multi-objective-aware edge insertion, prioritizing segments with high edge diversity and low dominance in both objective spaces.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high edge diversity (randomly choose among top 30% by edge diversity)\n    archive_solutions = [sol for sol, _ in archive]\n    edge_diversity = []\n    for sol in archive_solutions:\n        edges = [(sol[i], sol[(i+1)%len(sol)]) for i in range(len(sol))]\n        unique_edges = len(set(edges))\n        edge_diversity.append(unique_edges)\n\n    top_indices = np.argsort(edge_diversity)[-max(1, len(archive) // 3):]\n    selected_solution = archive_solutions[np.random.choice(top_indices)].copy()\n\n    # Apply hybrid local search: segment reversal + edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Edge insertion: insert a random edge from the solution into a new position if it improves both objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if i != j:\n        # Try inserting edge (i, j) at a new position\n        for k in range(n):\n            if k != i and k != j and k != (i+1)%n and k != (j-1)%n:\n                # Create a candidate solution\n                candidate = new_solution.copy()\n                if i < j:\n                    segment = candidate[i:j+1]\n                    candidate = np.concatenate([candidate[:i], candidate[j+1:], segment])\n                else:\n                    segment = candidate[i:] + candidate[:j+1]\n                    candidate = np.concatenate([candidate[j+1:i], segment])\n\n                # Check feasibility and objective improvement\n                if len(set(candidate)) == n:  # Ensure no duplicates\n                    # Calculate new objectives\n                    cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives are not worse\n                    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    if cost1 <= old_cost1 and cost2 <= old_cost2:\n                        new_solution = candidate\n                        break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{This heuristic selects solutions based on their proximity to the Pareto front in the objective space, then applies a novel multi-objective-aware segment relinking operator that combines features of both objectives to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n\n    # Calculate crowding distance for each solution\n    crowding = []\n    for i in range(len(objectives)):\n        left = objectives[i-1] if i > 0 else None\n        right = objectives[(i+1)%len(objectives)] if i < len(objectives)-1 else None\n\n        if left is None or right is None:\n            crowding.append(float('inf'))\n        else:\n            crowding.append(sum(abs(right[j] - left[j]) for j in range(2)))\n\n    # Select a solution with high crowding distance (near Pareto front)\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relinking\n    n = len(new_solution)\n    k = random.randint(2, min(5, n//2))  # Number of segments to relink\n\n    # Select k segments from the solution\n    segment_starts = sorted(random.sample(range(n), k))\n    segments = []\n    for i in range(k):\n        start = segment_starts[i]\n        end = segment_starts[(i+1)%k] if (i+1) < k else n\n        segments.append(new_solution[start:end])\n\n    # Recombine segments in a new order based on both objectives\n    segment_order = list(range(k))\n    random.shuffle(segment_order)\n\n    # Create new solution by interleaving segments\n    new_solution = np.concatenate([segments[i] for i in segment_order])\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8247302188228138,
            0.4815487861633301
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n\n    # Calculate crowding distance for each solution\n    crowding = []\n    for i in range(len(objectives)):\n        left = objectives[i-1] if i > 0 else None\n        right = objectives[(i+1)%len(objectives)] if i < len(objectives)-1 else None\n\n        if left is None or right is None:\n            crowding.append(float('inf'))\n        else:\n            crowding.append(sum(abs(right[j] - left[j]) for j in range(2)))\n\n    # Select a solution with high crowding distance (near Pareto front)\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment relinking\n    n = len(new_solution)\n    k = random.randint(2, min(5, n//2))  # Number of segments to relink\n\n    # Select k segments from the solution\n    segment_starts = sorted(random.sample(range(n), k))\n    segments = []\n    for i in range(k):\n        start = segment_starts[i]\n        end = segment_starts[(i+1)%k] if (i+1) < k else n\n        segments.append(new_solution[start:end])\n\n    # Recombine segments in a new order based on both objectives\n    segment_order = list(range(k))\n    random.shuffle(segment_order)\n\n    # Create new solution by interleaving segments\n    new_solution = np.concatenate([segments[i] for i in segment_order])\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution with minor changes\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest individual objective values in either space, then applies a novel \"cross-space segment inversion\" local search that reverses segments while considering both objectives and maintaining feasibility through careful boundary checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest individual objective values in either space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n\n    candidates = []\n    for i, (sol, obj) in enumerate(archive):\n        if obj[0] == max_obj1 or obj[1] == max_obj2:\n            candidates.append(i)\n\n    if not candidates:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to reverse\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n\n        # Calculate segment's properties in both spaces\n        original_segment = new_solution[seg_start:seg_start+seg_length]\n        reversed_segment = original_segment[::-1]\n\n        # Calculate cost differences\n        prev_node = new_solution[seg_start-1]\n        next_node = new_solution[seg_start+seg_length]\n\n        old_cost1 = (distance_matrix_1[prev_node, original_segment[0]] +\n                     distance_matrix_1[original_segment[-1], next_node])\n        new_cost1 = (distance_matrix_1[prev_node, reversed_segment[0]] +\n                     distance_matrix_1[reversed_segment[-1], next_node])\n\n        old_cost2 = (distance_matrix_2[prev_node, original_segment[0]] +\n                     distance_matrix_2[original_segment[-1], next_node])\n        new_cost2 = (distance_matrix_2[prev_node, reversed_segment[0]] +\n                     distance_matrix_2[reversed_segment[-1], next_node])\n\n        # Check if inversion improves both objectives\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[seg_start:seg_start+seg_length] = reversed_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9096401914682672,
            0.41813230514526367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest individual objective values in either space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n\n    candidates = []\n    for i, (sol, obj) in enumerate(archive):\n        if obj[0] == max_obj1 or obj[1] == max_obj2:\n            candidates.append(i)\n\n    if not candidates:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to reverse\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n\n        # Calculate segment's properties in both spaces\n        original_segment = new_solution[seg_start:seg_start+seg_length]\n        reversed_segment = original_segment[::-1]\n\n        # Calculate cost differences\n        prev_node = new_solution[seg_start-1]\n        next_node = new_solution[seg_start+seg_length]\n\n        old_cost1 = (distance_matrix_1[prev_node, original_segment[0]] +\n                     distance_matrix_1[original_segment[-1], next_node])\n        new_cost1 = (distance_matrix_1[prev_node, reversed_segment[0]] +\n                     distance_matrix_1[reversed_segment[-1], next_node])\n\n        old_cost2 = (distance_matrix_2[prev_node, original_segment[0]] +\n                     distance_matrix_2[original_segment[-1], next_node])\n        new_cost2 = (distance_matrix_2[prev_node, reversed_segment[0]] +\n                     distance_matrix_2[reversed_segment[-1], next_node])\n\n        # Check if inversion improves both objectives\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[seg_start:seg_start+seg_length] = reversed_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies an adaptive segment relocation operator that intelligently moves and reorders segments based on their relative importance in each objective space, while maintaining feasibility through dynamic validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Determine segment's relative importance\n        importance = seg_cost1 / seg_cost2 if seg_cost2 != 0 else float('inf')\n\n        # Find best insertion point considering segment importance\n        best_pos = -1\n        best_score = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            # Adaptive scoring based on segment importance\n            if importance > 1:  # More important in first space\n                score = (new_cost1 - old_cost1) - 0.5*(new_cost2 - old_cost2)\n            else:  # More important in second space\n                score = (new_cost2 - old_cost2) - 0.5*(new_cost1 - old_cost1)\n\n            if score > best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8363431330574157,
            0.5216907262802124
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Determine segment's relative importance\n        importance = seg_cost1 / seg_cost2 if seg_cost2 != 0 else float('inf')\n\n        # Find best insertion point considering segment importance\n        best_pos = -1\n        best_score = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            # Adaptive scoring based on segment importance\n            if importance > 1:  # More important in first space\n                score = (new_cost1 - old_cost1) - 0.5*(new_cost2 - old_cost2)\n            else:  # More important in second space\n                score = (new_cost2 - old_cost2) - 0.5*(new_cost1 - old_cost1)\n\n            if score > best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with the highest individual objective values in either space, then applies a \"cross-space node exchange\" local search that swaps nodes between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest individual objective values in either space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    candidates = [i for i, obj in enumerate(objectives) if obj[0] == max_obj1 or obj[1] == max_obj2]\n    selected_idx = random.choice(candidates) if candidates else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node exchange\n    if n > 1:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n        new_cost1 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] + distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n        new_cost2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] + distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n        if improvement < 0:\n            # Apply swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6890272705697988,
            0.7279354929924011
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest individual objective values in either space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    candidates = [i for i, obj in enumerate(objectives) if obj[0] == max_obj1 or obj[1] == max_obj2]\n    selected_idx = random.choice(candidates) if candidates else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node exchange\n    if n > 1:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n        new_cost1 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] + distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n        new_cost2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] + distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n        if improvement < 0:\n            # Apply swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This heuristic selects a solution from the archive based on the highest variance in objective values, then applies a novel \"cross-space segment inversion\" local search that inverts segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest variance in objectives\n    objectives = [obj for _, obj in archive]\n    variances = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Invert the segment in the opposite space\n        inverted_segment = segment[::-1]\n\n        # Replace the segment in the solution\n        new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n        # Validate the solution\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5961178995235006,
            0.42093247175216675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest variance in objectives\n    objectives = [obj for _, obj in archive]\n    variances = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Invert the segment in the opposite space\n        inverted_segment = segment[::-1]\n\n        # Replace the segment in the solution\n        new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n        # Validate the solution\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest normalized objective values (by dividing each objective by its maximum in the archive), then applies a novel \"cross-space node insertion\" local search that intelligently inserts nodes from one space into the other while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives) if objectives else 1\n    max_obj2 = max(obj[1] for obj in objectives) if objectives else 1\n\n    normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 2:\n        # Select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Calculate node's contribution in both spaces\n        prev_node = new_solution[node_idx-1]\n        next_node = new_solution[(node_idx+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx+1)%n:\n                continue\n\n            # Calculate potential improvement\n            insert_prev = new_solution[pos-1]\n            insert_next = new_solution[pos]\n\n            new_cost1 = (distance_matrix_1[insert_prev, node] +\n                         distance_matrix_1[node, insert_next] -\n                         distance_matrix_1[insert_prev, insert_next])\n\n            new_cost2 = (distance_matrix_2[insert_prev, node] +\n                         distance_matrix_2[node, insert_next] -\n                         distance_matrix_2[insert_prev, insert_next])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node\n            new_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx+1:]\n            ])\n\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                np.array([node]),\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9827602864682217,
            0.461966335773468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives) if objectives else 1\n    max_obj2 = max(obj[1] for obj in objectives) if objectives else 1\n\n    normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 2:\n        # Select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Calculate node's contribution in both spaces\n        prev_node = new_solution[node_idx-1]\n        next_node = new_solution[(node_idx+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx+1)%n:\n                continue\n\n            # Calculate potential improvement\n            insert_prev = new_solution[pos-1]\n            insert_next = new_solution[pos]\n\n            new_cost1 = (distance_matrix_1[insert_prev, node] +\n                         distance_matrix_1[node, insert_next] -\n                         distance_matrix_1[insert_prev, insert_next])\n\n            new_cost2 = (distance_matrix_2[insert_prev, node] +\n                         distance_matrix_2[node, insert_next] -\n                         distance_matrix_2[insert_prev, insert_next])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node\n            new_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx+1:]\n            ])\n\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                np.array([node]),\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        node1 = random.randint(0, n-1)\n        node2 = random.randint(0, n-1)\n        while node2 == node1:\n            node2 = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        # For first objective space\n        prev1 = new_solution[(node1-1)%n]\n        next1 = new_solution[(node1+1)%n]\n        prev2 = new_solution[(node2-1)%n]\n        next2 = new_solution[(node2+1)%n]\n\n        old_cost1 = (distance_matrix_1[prev1, new_solution[node1]] +\n                     distance_matrix_1[new_solution[node1], next1] +\n                     distance_matrix_1[prev2, new_solution[node2]] +\n                     distance_matrix_1[new_solution[node2], next2])\n\n        new_cost1 = (distance_matrix_1[prev1, new_solution[node2]] +\n                    distance_matrix_1[new_solution[node2], next1] +\n                    distance_matrix_1[prev2, new_solution[node1]] +\n                    distance_matrix_1[new_solution[node1], next2])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev1, new_solution[node1]] +\n                     distance_matrix_2[new_solution[node1], next1] +\n                     distance_matrix_2[prev2, new_solution[node2]] +\n                     distance_matrix_2[new_solution[node2], next2])\n\n        new_cost2 = (distance_matrix_2[prev1, new_solution[node2]] +\n                    distance_matrix_2[new_solution[node2], next1] +\n                    distance_matrix_2[prev2, new_solution[node1]] +\n                    distance_matrix_2[new_solution[node1], next2])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        # Apply swap if beneficial\n        if improvement < 0:\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9046595320031804,
            0.3799316883087158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        node1 = random.randint(0, n-1)\n        node2 = random.randint(0, n-1)\n        while node2 == node1:\n            node2 = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        # For first objective space\n        prev1 = new_solution[(node1-1)%n]\n        next1 = new_solution[(node1+1)%n]\n        prev2 = new_solution[(node2-1)%n]\n        next2 = new_solution[(node2+1)%n]\n\n        old_cost1 = (distance_matrix_1[prev1, new_solution[node1]] +\n                     distance_matrix_1[new_solution[node1], next1] +\n                     distance_matrix_1[prev2, new_solution[node2]] +\n                     distance_matrix_1[new_solution[node2], next2])\n\n        new_cost1 = (distance_matrix_1[prev1, new_solution[node2]] +\n                    distance_matrix_1[new_solution[node2], next1] +\n                    distance_matrix_1[prev2, new_solution[node1]] +\n                    distance_matrix_1[new_solution[node1], next2])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev1, new_solution[node1]] +\n                     distance_matrix_2[new_solution[node1], next1] +\n                     distance_matrix_2[prev2, new_solution[node2]] +\n                     distance_matrix_2[new_solution[node2], next2])\n\n        new_cost2 = (distance_matrix_2[prev1, new_solution[node2]] +\n                    distance_matrix_2[new_solution[node2], next1] +\n                    distance_matrix_2[prev2, new_solution[node1]] +\n                    distance_matrix_2[new_solution[node1], next2])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        # Apply swap if beneficial\n        if improvement < 0:\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms, and also considers the spatial proximity in both spaces to ensure meaningful improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate current and potential costs\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_j = new_solution[(j+1)%n]\n\n        # Current costs\n        current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                         distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n        current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                         distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n        # Potential costs after swap\n        potential_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                          distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n        potential_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                          distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n        # Calculate improvement\n        improvement1 = current_cost1 - potential_cost1\n        improvement2 = current_cost2 - potential_cost2\n\n        # Consider spatial proximity in both spaces\n        node_i_coords = instance[node_i]\n        node_j_coords = instance[node_j]\n        dist1 = np.sqrt((node_i_coords[0] - node_j_coords[0])**2 + (node_i_coords[1] - node_j_coords[1])**2)\n        dist2 = np.sqrt((node_i_coords[2] - node_j_coords[2])**2 + (node_i_coords[3] - node_j_coords[3])**2)\n\n        # Apply swap if it improves both objectives or if nodes are close in at least one space\n        if (improvement1 > 0 and improvement2 > 0) or (dist1 < 10 or dist2 < 10):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8741897622263421,
            0.3616958260536194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate current and potential costs\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_j = new_solution[(j+1)%n]\n\n        # Current costs\n        current_cost1 = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                         distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n        current_cost2 = (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                         distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n        # Potential costs after swap\n        potential_cost1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                          distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j])\n        potential_cost2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                          distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n        # Calculate improvement\n        improvement1 = current_cost1 - potential_cost1\n        improvement2 = current_cost2 - potential_cost2\n\n        # Consider spatial proximity in both spaces\n        node_i_coords = instance[node_i]\n        node_j_coords = instance[node_j]\n        dist1 = np.sqrt((node_i_coords[0] - node_j_coords[0])**2 + (node_i_coords[1] - node_j_coords[1])**2)\n        dist2 = np.sqrt((node_i_coords[2] - node_j_coords[2])**2 + (node_i_coords[3] - node_j_coords[3])**2)\n\n        # Apply swap if it improves both objectives or if nodes are close in at least one space\n        if (improvement1 > 0 and improvement2 > 0) or (dist1 < 10 or dist2 < 10):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest individual objective values in either space, then applies a novel \"cross-space node reinsertion\" local search that strategically reinserts nodes between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest objective in either space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n\n    # Prioritize solutions with extreme values in either space\n    candidates = []\n    for idx, (sol, obj) in enumerate(archive):\n        if obj[0] == max_obj1 or obj[1] == max_obj2:\n            candidates.append(idx)\n\n    if not candidates:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node reinsertion\n    if n > 3:\n        # Select a node to reinsert\n        node_pos = random.randint(1, n-2)\n        node = new_solution[node_pos]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(1, n-1):\n            if pos == node_pos or pos == node_pos-1:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, node] +\n                         distance_matrix_1[node, next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, node] +\n                         distance_matrix_2[node, next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                np.array([node]),\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9228972369605879,
            0.3457369804382324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest objective in either space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n\n    # Prioritize solutions with extreme values in either space\n    candidates = []\n    for idx, (sol, obj) in enumerate(archive):\n        if obj[0] == max_obj1 or obj[1] == max_obj2:\n            candidates.append(idx)\n\n    if not candidates:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node reinsertion\n    if n > 3:\n        # Select a node to reinsert\n        node_pos = random.randint(1, n-2)\n        node = new_solution[node_pos]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(1, n-1):\n            if pos == node_pos or pos == node_pos-1:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, node] +\n                         distance_matrix_1[node, next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, node] +\n                         distance_matrix_2[node, next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                np.array([node]),\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{The heuristic function 'select_neighbor' first identifies the non-dominated solutions in the archive, then intelligently selects one based on its potential for improvement, and applies a hybrid local search combining node insertion and segment rotation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((i, obj))\n\n    if not non_dominated:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Select based on potential for improvement\n        selected_idx = min(non_dominated, key=lambda x: x[1][0] + x[1][1])[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: node insertion and segment rotation\n    segment_size = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Rotate segment within itself\n    rotate_pos = random.randint(0, segment_size - 1)\n    new_solution[insert_pos:insert_pos+segment_size] = np.roll(segment, rotate_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7822248235202981,
            0.49204158782958984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((i, obj))\n\n    if not non_dominated:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Select based on potential for improvement\n        selected_idx = min(non_dominated, key=lambda x: x[1][0] + x[1][1])[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: node insertion and segment rotation\n    segment_size = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Rotate segment within itself\n    rotate_pos = random.randint(0, segment_size - 1)\n    new_solution[insert_pos:insert_pos+segment_size] = np.roll(segment, rotate_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values (combining both objectives with equal weight and normalized by their maximum values), then applies a novel \"cross-space segment inversion\" local search that inverts segments between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized combined objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives) if objectives else 1.0\n    max_obj2 = max(obj[1] for obj in objectives) if objectives else 1.0\n    normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Calculate segment properties in both spaces\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Only accept if there's improvement in at least one objective\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8985694803081092,
            0.5373954772949219
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized combined objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives) if objectives else 1.0\n    max_obj2 = max(obj[1] for obj in objectives) if objectives else 1.0\n    normalized_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Calculate segment properties in both spaces\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Only accept if there's improvement in at least one objective\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a combined score of non-dominated potential and diversity, then applies a hybrid local search combining segment reversal with a novel edge-swap strategy that prioritizes improving the Pareto front by balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-dominated scores and diversity scores\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated_scores = np.zeros(len(archive))\n    diversity_scores = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[j][0] <= objectives[i][0] and objectives[j][1] < objectives[i][1]) or \\\n                   (objectives[j][0] < objectives[i][0] and objectives[j][1] <= objectives[i][1]):\n                    dominated_count += 1\n        non_dominated_scores[i] = dominated_count\n\n        # Calculate diversity score (distance to nearest neighbor in objective space)\n        min_distance = float('inf')\n        for j in range(len(archive)):\n            if i != j:\n                distance = np.linalg.norm(objectives[i] - objectives[j])\n                if distance < min_distance:\n                    min_distance = distance\n        diversity_scores[i] = min_distance\n\n    # Combine scores (higher non-dominated score and higher diversity score preferred)\n    combined_scores = non_dominated_scores + diversity_scores\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Hybrid local search: segment reversal with objective-aware edge swaps\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Objective-aware edge swaps\n    for _ in range(min(5, n // 2)):\n        i, j = random.sample(range(n), 2)\n        # Calculate potential improvement for both objectives\n        old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        delta1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n        delta2 = new_cost2 - old_cost2\n\n        # Accept swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7706874956736978,
            8.442197144031525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate non-dominated scores and diversity scores\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated_scores = np.zeros(len(archive))\n    diversity_scores = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[j][0] <= objectives[i][0] and objectives[j][1] < objectives[i][1]) or \\\n                   (objectives[j][0] < objectives[i][0] and objectives[j][1] <= objectives[i][1]):\n                    dominated_count += 1\n        non_dominated_scores[i] = dominated_count\n\n        # Calculate diversity score (distance to nearest neighbor in objective space)\n        min_distance = float('inf')\n        for j in range(len(archive)):\n            if i != j:\n                distance = np.linalg.norm(objectives[i] - objectives[j])\n                if distance < min_distance:\n                    min_distance = distance\n        diversity_scores[i] = min_distance\n\n    # Combine scores (higher non-dominated score and higher diversity score preferred)\n    combined_scores = non_dominated_scores + diversity_scores\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Hybrid local search: segment reversal with objective-aware edge swaps\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Objective-aware edge swaps\n    for _ in range(min(5, n // 2)):\n        i, j = random.sample(range(n), 2)\n        # Calculate potential improvement for both objectives\n        old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n        new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n        delta1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n        new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n        delta2 = new_cost2 - old_cost2\n\n        # Accept swap if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"multi-objective segment insertion\" local search that intelligently inserts segments from one objective space into another while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment insertion\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in the solution\n        best_pos = -1\n        best_balance = float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential balance improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            # Calculate balance factor (difference between objectives)\n            balance = abs((new_cost1 - old_cost1) - (new_cost2 - old_cost2))\n            if balance < best_balance:\n                best_balance = balance\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8971399648246366,
            0.5136785507202148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment insertion\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in the solution\n        best_pos = -1\n        best_balance = float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential balance improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            # Calculate balance factor (difference between objectives)\n            balance = abs((new_cost1 - old_cost1) - (new_cost2 - old_cost2))\n            if balance < best_balance:\n                best_balance = balance\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a score combining objective values and diversity, applies a hybrid local search operator that combines segment reversal and edge swaps with a probability based on the solution's quality, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Normalize objectives to [0, 1] range\n        norm_obj = (obj[0] / np.max([o[0] for _, o in archive]), obj[1] / np.max([o[1] for _, o in archive]))\n        # Score is a combination of objective values and diversity (higher is better)\n        score = 0.6 * (1 - (norm_obj[0] + norm_obj[1]) / 2) + 0.4 * (1 / (1 + np.sum(np.abs(sol - archive[0][0]))))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Hybrid local search with probability based on solution quality\n    quality = 1 - (scores[selected_idx] - min(scores)) / (max(scores) - min(scores))\n\n    # Segment reversal with higher probability for higher quality solutions\n    if random.random() < quality:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge swaps with lower probability for higher quality solutions\n    if random.random() < (1 - quality):\n        swap_count = random.randint(1, min(3, n // 2))\n        for _ in range(swap_count):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8137895275249877,
            3.167298376560211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Normalize objectives to [0, 1] range\n        norm_obj = (obj[0] / np.max([o[0] for _, o in archive]), obj[1] / np.max([o[1] for _, o in archive]))\n        # Score is a combination of objective values and diversity (higher is better)\n        score = 0.6 * (1 - (norm_obj[0] + norm_obj[1]) / 2) + 0.4 * (1 / (1 + np.sum(np.abs(sol - archive[0][0]))))\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Hybrid local search with probability based on solution quality\n    quality = 1 - (scores[selected_idx] - min(scores)) / (max(scores) - min(scores))\n\n    # Segment reversal with higher probability for higher quality solutions\n    if random.random() < quality:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge swaps with lower probability for higher quality solutions\n    if random.random() < (1 - quality):\n        swap_count = random.randint(1, min(3, n // 2))\n        for _ in range(swap_count):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a novel \"cross-space node insertion\" local search that intelligently reinserts nodes based on their relative improvement in both objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 3:\n        # Select a random node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n        # Find best insertion position based on cross-space improvement\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n-1):\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n\n            # Calculate original costs\n            original_cost1 = distance_matrix_1[prev_node, next_node]\n            original_cost2 = distance_matrix_2[prev_node, next_node]\n\n            # Calculate new costs if node is inserted here\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Calculate improvement (negative means better)\n            improvement = (new_cost1 - original_cost1) + (new_cost2 - original_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7963759989272932,
            3.799580216407776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 3:\n        # Select a random node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n        # Find best insertion position based on cross-space improvement\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n-1):\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n\n            # Calculate original costs\n            original_cost1 = distance_matrix_1[prev_node, next_node]\n            original_cost2 = distance_matrix_2[prev_node, next_node]\n\n            # Calculate new costs if node is inserted here\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Calculate improvement (negative means better)\n            improvement = (new_cost1 - original_cost1) + (new_cost2 - original_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive, applies a hybrid local search combining node swapping and segment reversal to explore the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Randomly select two distinct nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Randomly select a segment and reverse its order\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8785131885874501,
            0.3390249013900757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Randomly select two distinct nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Randomly select a segment and reverse its order\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{The new heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a combined score of objective values and solution diversity, then applies a hybrid local search combining segment reversal and edge swaps with probabilistic acceptance of non-improving moves to escape local optima, while ensuring feasibility through validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Calculate combined scores for selection\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Normalize objectives\n        norm_obj1 = obj1 / distance_matrix_1.sum() if distance_matrix_1.sum() > 0 else 0\n        norm_obj2 = obj2 / distance_matrix_2.sum() if distance_matrix_2.sum() > 0 else 0\n        # Combine objectives with diversity factor\n        diversity = len(np.unique(sol)) / len(sol)\n        score = (norm_obj1 + norm_obj2) * (1 - diversity)\n        scores.append(score)\n\n    # Select based on score with some randomness\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Hybrid local search with probabilistic acceptance\n    for _ in range(3):\n        # Segment reversal\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        candidate = new_solution.copy()\n        candidate[start:end+1] = candidate[start:end+1][::-1]\n\n        # Edge swaps\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Validate and accept if better or with probability\n        if len(np.unique(candidate)) == n:\n            current_obj1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n            current_obj2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n            new_obj1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            new_obj2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            if (new_obj1 < current_obj1 and new_obj2 < current_obj2) or random.random() < 0.3:\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.6157160050981523,
            4.107710301876068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Calculate combined scores for selection\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Normalize objectives\n        norm_obj1 = obj1 / distance_matrix_1.sum() if distance_matrix_1.sum() > 0 else 0\n        norm_obj2 = obj2 / distance_matrix_2.sum() if distance_matrix_2.sum() > 0 else 0\n        # Combine objectives with diversity factor\n        diversity = len(np.unique(sol)) / len(sol)\n        score = (norm_obj1 + norm_obj2) * (1 - diversity)\n        scores.append(score)\n\n    # Select based on score with some randomness\n    selected_idx = np.argmin(scores) if random.random() < 0.7 else random.randint(0, len(archive)-1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Hybrid local search with probabilistic acceptance\n    for _ in range(3):\n        # Segment reversal\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        candidate = new_solution.copy()\n        candidate[start:end+1] = candidate[start:end+1][::-1]\n\n        # Edge swaps\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Validate and accept if better or with probability\n        if len(np.unique(candidate)) == n:\n            current_obj1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n            current_obj2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n            new_obj1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            new_obj2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            if (new_obj1 < current_obj1 and new_obj2 < current_obj2) or random.random() < 0.3:\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a novel \"multi-objective segment inversion\" local search that inverts segments of nodes while carefully balancing improvements across both objective spaces to maintain feasibility and explore the Pareto front effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Calculate inverted segment's properties\n        inverted_segment = segment[::-1]\n        inv_seg_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n        inv_seg_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Calculate potential improvement\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        improvement1 = new_cost1 - old_cost1\n        improvement2 = new_cost2 - old_cost2\n\n        # Apply inversion if it improves at least one objective\n        if improvement1 < 0 or improvement2 < 0:\n            new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8704236993662102,
            2.7409937381744385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Calculate inverted segment's properties\n        inverted_segment = segment[::-1]\n        inv_seg_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n        inv_seg_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Calculate potential improvement\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        improvement1 = new_cost1 - old_cost1\n        improvement2 = new_cost2 - old_cost2\n\n        # Apply inversion if it improves at least one objective\n        if improvement1 < 0 or improvement2 < 0:\n            new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a novel \"cross-space segment inversion\" local search that flips segments between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Calculate segment properties in both spaces before and after inversion\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # If inversion improves both objectives, apply it\n        if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or (random.random() < 0.3):\n            new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n            # Additional local improvement: swap adjacent nodes if it helps\n            swap_pos = random.randint(0, n-2)\n            if (distance_matrix_1[new_solution[swap_pos], new_solution[swap_pos+1]] +\n                distance_matrix_2[new_solution[swap_pos], new_solution[swap_pos+1]]) > \\\n               (distance_matrix_1[new_solution[swap_pos+1], new_solution[swap_pos]] +\n                distance_matrix_2[new_solution[swap_pos+1], new_solution[swap_pos]]):\n                new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5265760254285592,
            0.5145344734191895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Calculate segment properties in both spaces before and after inversion\n        old_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        old_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # If inversion improves both objectives, apply it\n        if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or (random.random() < 0.3):\n            new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n            # Additional local improvement: swap adjacent nodes if it helps\n            swap_pos = random.randint(0, n-2)\n            if (distance_matrix_1[new_solution[swap_pos], new_solution[swap_pos+1]] +\n                distance_matrix_2[new_solution[swap_pos], new_solution[swap_pos+1]]) > \\\n               (distance_matrix_1[new_solution[swap_pos+1], new_solution[swap_pos]] +\n                distance_matrix_2[new_solution[swap_pos+1], new_solution[swap_pos]]):\n                new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted score combining objective values and solution diversity, then applies a hybrid local search combining segment reversal and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution based on weighted score combining objectives and diversity\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / (max(o[0] for _, o in archive) + 1e-6)\n        norm_obj2 = obj[1] / (max(o[1] for _, o in archive) + 1e-6)\n        diversity = sum(sol != archive[0][0]) / len(sol)\n        score = 0.4 * (norm_obj1 + norm_obj2) + 0.6 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    # Segment reversal\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node relocation\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9422953257617052,
            4.241341531276703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution based on weighted score combining objectives and diversity\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / (max(o[0] for _, o in archive) + 1e-6)\n        norm_obj2 = obj[1] / (max(o[1] for _, o in archive) + 1e-6)\n        diversity = sum(sol != archive[0][0]) / len(sol)\n        score = 0.4 * (norm_obj1 + norm_obj2) + 0.6 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    # Segment reversal\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node relocation\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This heuristic first identifies the most diverse solution in the archive by maximizing the difference between its two objective values, then applies a novel \"bi-objective path inversion\" operator that selectively inverts segments based on their contribution to both objectives, ensuring feasibility through careful segment validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with maximum difference between objectives\n    objectives = [obj for _, obj in archive]\n    differences = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(differences)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Bi-objective path inversion\n    if n > 3:\n        # Calculate segment contributions for both objectives\n        segment_contributions = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            segment_contributions.append((cost1, cost2))\n\n        # Find segments where one objective dominates the other\n        for i in range(n-1):\n            cost1, cost2 = segment_contributions[i]\n            if cost1 > cost2:\n                # Invert segment to improve second objective\n                start = i\n                end = i + 1\n                while end < n-1 and segment_contributions[end][0] > segment_contributions[end][1]:\n                    end += 1\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n                break\n            elif cost2 > cost1:\n                # Invert segment to improve first objective\n                start = i\n                end = i + 1\n                while end < n-1 and segment_contributions[end][1] > segment_contributions[end][0]:\n                    end += 1\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n                break\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8184562648414054,
            0.390347957611084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with maximum difference between objectives\n    objectives = [obj for _, obj in archive]\n    differences = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(differences)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Bi-objective path inversion\n    if n > 3:\n        # Calculate segment contributions for both objectives\n        segment_contributions = []\n        for i in range(n-1):\n            cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            segment_contributions.append((cost1, cost2))\n\n        # Find segments where one objective dominates the other\n        for i in range(n-1):\n            cost1, cost2 = segment_contributions[i]\n            if cost1 > cost2:\n                # Invert segment to improve second objective\n                start = i\n                end = i + 1\n                while end < n-1 and segment_contributions[end][0] > segment_contributions[end][1]:\n                    end += 1\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n                break\n            elif cost2 > cost1:\n                # Invert segment to improve first objective\n                start = i\n                end = i + 1\n                while end < n-1 and segment_contributions[end][1] > segment_contributions[end][0]:\n                    end += 1\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n                break\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space node reallocation\" local search that intelligently redistributes nodes between the two objective spaces by considering their relative positions and potential for improving both objectives simultaneously while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Select a node to reallocate\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find best positions in both spaces\n        best_pos1 = -1\n        best_pos2 = -1\n        best_improvement = float('inf')\n\n        for pos in range(n):\n            if pos == node_idx:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos1 = pos\n                best_pos2 = pos\n\n        if best_pos1 != -1 and best_pos2 != -1:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx+1:]\n            ])\n            new_solution = np.concatenate([\n                new_solution[:best_pos1],\n                [node],\n                new_solution[best_pos1:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9260757193099575,
            0.38418352603912354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Select a node to reallocate\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find best positions in both spaces\n        best_pos1 = -1\n        best_pos2 = -1\n        best_improvement = float('inf')\n\n        for pos in range(n):\n            if pos == node_idx:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos1 = pos\n                best_pos2 = pos\n\n        if best_pos1 != -1 and best_pos2 != -1:\n            # Remove node and insert at best position\n            new_solution = np.concatenate([\n                new_solution[:node_idx],\n                new_solution[node_idx+1:]\n            ])\n            new_solution = np.concatenate([\n                new_solution[:best_pos1],\n                [node],\n                new_solution[best_pos1:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines edge-swap and segment-reversal operations to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal with edge swaps\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge swaps to further improve the solution\n    swap_count = random.randint(1, min(3, n // 2))\n    for _ in range(swap_count):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base if invalid\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This algorithm selects a solution from the archive based on its diversity in the objective space, then applies a novel \"objective-aware segment insertion\" local search that intelligently inserts segments from one objective space into the other while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most balanced objectives\n    objectives = [obj for _, obj in archive]\n    balance_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment insertion\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine which objective space the segment is better suited for\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Calculate segment's relative performance in both spaces\n        rel_perf1 = seg_cost1 / (seg_cost1 + seg_cost2)\n        rel_perf2 = seg_cost2 / (seg_cost1 + seg_cost2)\n\n        # Find best insertion point in the space where the segment performs worse\n        target_space = 1 if rel_perf1 > rel_perf2 else 0\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For target space\n            if target_space == 0:\n                old_cost = distance_matrix_1[prev_node, next_node]\n                new_cost = (distance_matrix_1[prev_node, segment[0]] +\n                           distance_matrix_1[segment[-1], next_node])\n            else:\n                old_cost = distance_matrix_2[prev_node, next_node]\n                new_cost = (distance_matrix_2[prev_node, segment[0]] +\n                           distance_matrix_2[segment[-1], next_node])\n\n            improvement = new_cost - old_cost\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8914740541046167,
            0.46991854906082153
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most balanced objectives\n    objectives = [obj for _, obj in archive]\n    balance_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment insertion\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine which objective space the segment is better suited for\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Calculate segment's relative performance in both spaces\n        rel_perf1 = seg_cost1 / (seg_cost1 + seg_cost2)\n        rel_perf2 = seg_cost2 / (seg_cost1 + seg_cost2)\n\n        # Find best insertion point in the space where the segment performs worse\n        target_space = 1 if rel_perf1 > rel_perf2 else 0\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For target space\n            if target_space == 0:\n                old_cost = distance_matrix_1[prev_node, next_node]\n                new_cost = (distance_matrix_1[prev_node, segment[0]] +\n                           distance_matrix_1[segment[-1], next_node])\n            else:\n                old_cost = distance_matrix_2[prev_node, next_node]\n                new_cost = (distance_matrix_2[prev_node, segment[0]] +\n                           distance_matrix_2[segment[-1], next_node])\n\n            improvement = new_cost - old_cost\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a novel \"cross-space node insertion\" local search that intelligently reinserts nodes between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 3:\n        # Select a node to move\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Calculate node's properties in both spaces\n        prev_node = new_solution[node_pos-1]\n        next_node = new_solution[(node_pos+1)%n]\n        current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_pos or pos == (node_pos-1) % n:\n                continue\n\n            # Calculate potential improvement\n            insert_prev = new_solution[pos-1]\n            insert_next = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[insert_prev, insert_next]\n            new_cost1 = (distance_matrix_1[insert_prev, node] +\n                         distance_matrix_1[node, insert_next])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[insert_prev, insert_next]\n            new_cost2 = (distance_matrix_2[insert_prev, node] +\n                         distance_matrix_2[node, insert_next])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:]\n            ])\n\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9192391293834545,
            4.739483177661896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 3:\n        # Select a node to move\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Calculate node's properties in both spaces\n        prev_node = new_solution[node_pos-1]\n        next_node = new_solution[(node_pos+1)%n]\n        current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_pos or pos == (node_pos-1) % n:\n                continue\n\n            # Calculate potential improvement\n            insert_prev = new_solution[pos-1]\n            insert_next = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[insert_prev, insert_next]\n            new_cost1 = (distance_matrix_1[insert_prev, node] +\n                         distance_matrix_1[node, insert_next])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[insert_prev, insert_next]\n            new_cost2 = (distance_matrix_2[insert_prev, node] +\n                         distance_matrix_2[node, insert_next])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:]\n            ])\n\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a novel \"objective-aware path inversion\" local search that intelligently inverts segments based on their relative performance in each objective space while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware path inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(7, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Calculate segment's performance in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        obj_ratio = seg_cost1 / seg_cost2 if seg_cost2 != 0 else float('inf')\n\n        # Decide inversion strategy based on objective ratio\n        if obj_ratio > 1.5:\n            # Invert segment to improve first objective\n            segment = segment[::-1]\n        elif obj_ratio < 0.67:\n            # Invert segment to improve second objective\n            segment = segment[::-1]\n        else:\n            # Randomly decide to invert or not\n            if random.random() < 0.5:\n                segment = segment[::-1]\n\n        # Replace segment in solution\n        new_solution[seg_start:seg_start+seg_length] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7320842881193016,
            0.29544949531555176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware path inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(7, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Calculate segment's performance in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        obj_ratio = seg_cost1 / seg_cost2 if seg_cost2 != 0 else float('inf')\n\n        # Decide inversion strategy based on objective ratio\n        if obj_ratio > 1.5:\n            # Invert segment to improve first objective\n            segment = segment[::-1]\n        elif obj_ratio < 0.67:\n            # Invert segment to improve second objective\n            segment = segment[::-1]\n        else:\n            # Randomly decide to invert or not\n            if random.random() < 0.5:\n                segment = segment[::-1]\n\n        # Replace segment in solution\n        new_solution[seg_start:seg_start+seg_length] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{The new algorithm intelligently selects a non-dominated solution from the archive using a dominance-based selection, then applies a hybrid local search combining node reversal and segment relocation to explore Pareto-optimal regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: node reversal and segment relocation\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random segment to a new position\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9135292268989877,
            0.2968202829360962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: node reversal and segment relocation\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random segment to a new position\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a novel \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two random nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate cost change in both objective spaces\n        prev_i, next_i = new_solution[i-1], new_solution[(i+1)%n]\n        prev_j, next_j = new_solution[j-1], new_solution[(j+1)%n]\n\n        # Original connections\n        original_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                          distance_matrix_1[new_solution[i], next_i] +\n                          distance_matrix_1[prev_j, new_solution[j]] +\n                          distance_matrix_1[new_solution[j], next_j])\n\n        original_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                          distance_matrix_2[new_solution[i], next_i] +\n                          distance_matrix_2[prev_j, new_solution[j]] +\n                          distance_matrix_2[new_solution[j], next_j])\n\n        # Swapped connections\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        swapped_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                        distance_matrix_1[new_solution[i], next_i] +\n                        distance_matrix_1[prev_j, new_solution[j]] +\n                        distance_matrix_1[new_solution[j], next_j])\n\n        swapped_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                        distance_matrix_2[new_solution[i], next_i] +\n                        distance_matrix_2[prev_j, new_solution[j]] +\n                        distance_matrix_2[new_solution[j], next_j])\n\n        # Accept if improvement in at least one objective\n        if (swapped_cost1 + swapped_cost2) < (original_cost1 + original_cost2):\n            pass  # Keep the swap\n        else:\n            # Revert if no improvement\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5831327656445358,
            1.9240065217018127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two random nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate cost change in both objective spaces\n        prev_i, next_i = new_solution[i-1], new_solution[(i+1)%n]\n        prev_j, next_j = new_solution[j-1], new_solution[(j+1)%n]\n\n        # Original connections\n        original_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                          distance_matrix_1[new_solution[i], next_i] +\n                          distance_matrix_1[prev_j, new_solution[j]] +\n                          distance_matrix_1[new_solution[j], next_j])\n\n        original_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                          distance_matrix_2[new_solution[i], next_i] +\n                          distance_matrix_2[prev_j, new_solution[j]] +\n                          distance_matrix_2[new_solution[j], next_j])\n\n        # Swapped connections\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        swapped_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                        distance_matrix_1[new_solution[i], next_i] +\n                        distance_matrix_1[prev_j, new_solution[j]] +\n                        distance_matrix_1[new_solution[j], next_j])\n\n        swapped_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                        distance_matrix_2[new_solution[i], next_i] +\n                        distance_matrix_2[prev_j, new_solution[j]] +\n                        distance_matrix_2[new_solution[j], next_j])\n\n        # Accept if improvement in at least one objective\n        if (swapped_cost1 + swapped_cost2) < (original_cost1 + original_cost2):\n            pass  # Keep the swap\n        else:\n            # Revert if no improvement\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on its Pareto dominance, applies a hybrid local search combining segment reversal and node exchange to generate a neighbor solution, and ensures feasibility by validating the tour structure before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node exchange\n    # Segment reversal\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node exchange\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9067201390664679,
            0.31528449058532715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node exchange\n    # Segment reversal\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node exchange\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space node reinsertion\" local search that intelligently reinserts nodes based on their relative positions in both objective spaces, ensuring feasibility through a validation step that checks for duplicate nodes or skipped nodes.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node reinsertion\n    if n > 2:\n        # Select a node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n        # Calculate node's position in both spaces relative to its neighbors\n        prev_node = new_solution[node_idx-1] if node_idx > 0 else new_solution[-1]\n        next_node = new_solution[node_idx] if node_idx < n-1 else new_solution[0]\n\n        # Calculate potential insertion points based on both spaces\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(n-1):\n            if pos == node_idx or pos == node_idx-1:\n                continue\n\n            # Calculate insertion cost in both spaces\n            prev = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next = new_solution[pos]\n\n            cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next] - distance_matrix_1[prev, next]\n            cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next] - distance_matrix_2[prev, next]\n\n            # Combined score (weighted sum of both costs)\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9456736559129717,
            0.414588987827301
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node reinsertion\n    if n > 2:\n        # Select a node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n        # Calculate node's position in both spaces relative to its neighbors\n        prev_node = new_solution[node_idx-1] if node_idx > 0 else new_solution[-1]\n        next_node = new_solution[node_idx] if node_idx < n-1 else new_solution[0]\n\n        # Calculate potential insertion points based on both spaces\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(n-1):\n            if pos == node_idx or pos == node_idx-1:\n                continue\n\n            # Calculate insertion cost in both spaces\n            prev = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next = new_solution[pos]\n\n            cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next] - distance_matrix_1[prev, next]\n            cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next] - distance_matrix_2[prev, next]\n\n            # Combined score (weighted sum of both costs)\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{The new algorithm selects a solution from the archive based on a crowding distance metric to prioritize under-explored regions, then applies a hybrid local search combining segment reversal and node reinsertion with a bias toward improving the less crowded objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    for sol, obj in archive:\n        crowding = abs(obj[0] - obj[1])\n        crowding_distances.append(crowding)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal with bias toward less crowded objective\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n\n    # Reverse segment with probability based on crowding\n    if random.random() < 0.7:\n        new_solution[start:end+1] = segment[::-1]\n\n    # Reinsert node with bias toward less crowded objective\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9078987150952229,
            0.06703132390975952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    for sol, obj in archive:\n        crowding = abs(obj[0] - obj[1])\n        crowding_distances.append(crowding)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal with bias toward less crowded objective\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n\n    # Reverse segment with probability based on crowding\n    if random.random() < 0.7:\n        new_solution[start:end+1] = segment[::-1]\n\n    # Reinsert node with bias toward less crowded objective\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space node reordering\" local search that intelligently reorders nodes based on their distance characteristics in both spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a node to reorder\n        node_pos = random.randint(1, n-2)\n        node = new_solution[node_pos]\n\n        # Calculate distance characteristics for the node in both spaces\n        prev_node = new_solution[node_pos-1]\n        next_node = new_solution[node_pos+1]\n        dist1_prev = distance_matrix_1[prev_node, node]\n        dist1_next = distance_matrix_1[node, next_node]\n        dist2_prev = distance_matrix_2[prev_node, node]\n        dist2_next = distance_matrix_2[node, next_node]\n\n        # Find best position to insert the node\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_pos or pos == node_pos-1 or pos == node_pos+1:\n                continue\n\n            # Calculate potential improvement\n            if pos == 0:\n                prev = new_solution[-1]\n                next_node_pos = new_solution[pos]\n            elif pos == n-1:\n                prev = new_solution[pos-1]\n                next_node_pos = new_solution[0]\n            else:\n                prev = new_solution[pos-1]\n                next_node_pos = new_solution[pos]\n\n            old_cost1 = distance_matrix_1[prev, next_node_pos]\n            new_cost1 = (distance_matrix_1[prev, node] +\n                        distance_matrix_1[node, next_node_pos])\n            improvement1 = new_cost1 - old_cost1\n\n            old_cost2 = distance_matrix_2[prev, next_node_pos]\n            new_cost2 = (distance_matrix_2[prev, node] +\n                        distance_matrix_2[node, next_node_pos])\n            improvement2 = new_cost2 - old_cost2\n\n            total_improvement = improvement1 + improvement2\n            if total_improvement < best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:]\n            ])\n\n            # Insert node at best position\n            if best_pos >= node_pos:\n                best_pos -= 1\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8836790407885586,
            0.34233665466308594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a node to reorder\n        node_pos = random.randint(1, n-2)\n        node = new_solution[node_pos]\n\n        # Calculate distance characteristics for the node in both spaces\n        prev_node = new_solution[node_pos-1]\n        next_node = new_solution[node_pos+1]\n        dist1_prev = distance_matrix_1[prev_node, node]\n        dist1_next = distance_matrix_1[node, next_node]\n        dist2_prev = distance_matrix_2[prev_node, node]\n        dist2_next = distance_matrix_2[node, next_node]\n\n        # Find best position to insert the node\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos == node_pos or pos == node_pos-1 or pos == node_pos+1:\n                continue\n\n            # Calculate potential improvement\n            if pos == 0:\n                prev = new_solution[-1]\n                next_node_pos = new_solution[pos]\n            elif pos == n-1:\n                prev = new_solution[pos-1]\n                next_node_pos = new_solution[0]\n            else:\n                prev = new_solution[pos-1]\n                next_node_pos = new_solution[pos]\n\n            old_cost1 = distance_matrix_1[prev, next_node_pos]\n            new_cost1 = (distance_matrix_1[prev, node] +\n                        distance_matrix_1[node, next_node_pos])\n            improvement1 = new_cost1 - old_cost1\n\n            old_cost2 = distance_matrix_2[prev, next_node_pos]\n            new_cost2 = (distance_matrix_2[prev, node] +\n                        distance_matrix_2[node, next_node_pos])\n            improvement2 = new_cost2 - old_cost2\n\n            total_improvement = improvement1 + improvement2\n            if total_improvement < best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:]\n            ])\n\n            # Insert node at best position\n            if best_pos >= node_pos:\n                best_pos -= 1\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest variance in objective values, then applies a novel \"cross-space node exchange\" local search that intelligently swaps nodes between clusters formed by their positions in the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest variance in objectives\n    objectives = [obj for _, obj in archive]\n    variances = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cluster nodes based on their positions in both spaces\n    if n > 2:\n        # Calculate centroids for both spaces\n        centroid1 = np.mean(instance[:, :2], axis=0)\n        centroid2 = np.mean(instance[:, 2:], axis=0)\n\n        # Cluster nodes into two groups based on distance to centroids\n        cluster1 = []\n        cluster2 = []\n        for node in new_solution:\n            pos1 = instance[node, :2]\n            pos2 = instance[node, 2:]\n            dist1 = np.linalg.norm(pos1 - centroid1)\n            dist2 = np.linalg.norm(pos2 - centroid2)\n\n            if dist1 < dist2:\n                cluster1.append(node)\n            else:\n                cluster2.append(node)\n\n        # Select nodes to exchange between clusters\n        if len(cluster1) > 1 and len(cluster2) > 1:\n            # Select a node from each cluster\n            node1 = random.choice(cluster1)\n            node2 = random.choice(cluster2)\n\n            # Find positions of these nodes in the solution\n            pos1 = np.where(new_solution == node1)[0][0]\n            pos2 = np.where(new_solution == node2)[0][0]\n\n            # Swap the nodes\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7737866991189575,
            0.7051387429237366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest variance in objectives\n    objectives = [obj for _, obj in archive]\n    variances = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cluster nodes based on their positions in both spaces\n    if n > 2:\n        # Calculate centroids for both spaces\n        centroid1 = np.mean(instance[:, :2], axis=0)\n        centroid2 = np.mean(instance[:, 2:], axis=0)\n\n        # Cluster nodes into two groups based on distance to centroids\n        cluster1 = []\n        cluster2 = []\n        for node in new_solution:\n            pos1 = instance[node, :2]\n            pos2 = instance[node, 2:]\n            dist1 = np.linalg.norm(pos1 - centroid1)\n            dist2 = np.linalg.norm(pos2 - centroid2)\n\n            if dist1 < dist2:\n                cluster1.append(node)\n            else:\n                cluster2.append(node)\n\n        # Select nodes to exchange between clusters\n        if len(cluster1) > 1 and len(cluster2) > 1:\n            # Select a node from each cluster\n            node1 = random.choice(cluster1)\n            node2 = random.choice(cluster2)\n\n            # Find positions of these nodes in the solution\n            pos1 = np.where(new_solution == node1)[0][0]\n            pos2 = np.where(new_solution == node2)[0][0]\n\n            # Swap the nodes\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a high-quality solution from the archive, applies a hybrid local search operator that combines edge reversal and segment inversion to explore diverse regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Invert a random segment (swap nodes in pairs)\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    for i in range(0, len(segment), 2):\n        if i + 1 < len(segment):\n            segment[i], segment[i+1] = segment[i+1], segment[i]\n    new_solution[start:end+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.772104142875315,
            0.24880820512771606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Invert a random segment (swap nodes in pairs)\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    for i in range(0, len(segment), 2):\n        if i + 1 < len(segment):\n            segment[i], segment[i+1] = segment[i+1], segment[i]\n    new_solution[start:end+1] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a solution from the archive, applies a hybrid local search combining segment reversal and node reinsertion, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a node to a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9305554714227509,
            0.1349022388458252
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert a node to a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest individual objective values in either space, then applies a novel \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest individual objective values in either space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    selected_idx = np.argmax([max_obj1 if obj[0] == max_obj1 else obj[1] for obj in objectives])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        # Apply swap if improvement is found\n        if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9693971977427048,
            0.5480435490608215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest individual objective values in either space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    selected_idx = np.argmax([max_obj1 if obj[0] == max_obj1 else obj[1] for obj in objectives])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        # Apply swap if improvement is found\n        if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the most balanced objective values, then applies a novel \"cross-space node swapping\" local search that intelligently swaps nodes between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most balanced objective values\n    objectives = [obj for _, obj in archive]\n    balance_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes for potential swap\n        node1 = random.randint(0, n-1)\n        node2 = random.randint(0, n-1)\n        while node2 == node1:\n            node2 = random.randint(0, n-1)\n\n        # Calculate current costs\n        prev1 = new_solution[node1-1]\n        next1 = new_solution[(node1+1)%n]\n        prev2 = new_solution[node2-1]\n        next2 = new_solution[(node2+1)%n]\n\n        current_cost1 = (distance_matrix_1[prev1, new_solution[node1]] +\n                         distance_matrix_1[new_solution[node1], next1] +\n                         distance_matrix_1[prev2, new_solution[node2]] +\n                         distance_matrix_1[new_solution[node2], next2])\n\n        current_cost2 = (distance_matrix_2[prev1, new_solution[node1]] +\n                         distance_matrix_2[new_solution[node1], next1] +\n                         distance_matrix_2[prev2, new_solution[node2]] +\n                         distance_matrix_2[new_solution[node2], next2])\n\n        # Calculate potential new costs\n        new_cost1 = (distance_matrix_1[prev1, new_solution[node2]] +\n                     distance_matrix_1[new_solution[node2], next1] +\n                     distance_matrix_1[prev2, new_solution[node1]] +\n                     distance_matrix_1[new_solution[node1], next2])\n\n        new_cost2 = (distance_matrix_2[prev1, new_solution[node2]] +\n                     distance_matrix_2[new_solution[node2], next1] +\n                     distance_matrix_2[prev2, new_solution[node1]] +\n                     distance_matrix_2[new_solution[node1], next2])\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8891159229168006,
            0.36516356468200684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most balanced objective values\n    objectives = [obj for _, obj in archive]\n    balance_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes for potential swap\n        node1 = random.randint(0, n-1)\n        node2 = random.randint(0, n-1)\n        while node2 == node1:\n            node2 = random.randint(0, n-1)\n\n        # Calculate current costs\n        prev1 = new_solution[node1-1]\n        next1 = new_solution[(node1+1)%n]\n        prev2 = new_solution[node2-1]\n        next2 = new_solution[(node2+1)%n]\n\n        current_cost1 = (distance_matrix_1[prev1, new_solution[node1]] +\n                         distance_matrix_1[new_solution[node1], next1] +\n                         distance_matrix_1[prev2, new_solution[node2]] +\n                         distance_matrix_1[new_solution[node2], next2])\n\n        current_cost2 = (distance_matrix_2[prev1, new_solution[node1]] +\n                         distance_matrix_2[new_solution[node1], next1] +\n                         distance_matrix_2[prev2, new_solution[node2]] +\n                         distance_matrix_2[new_solution[node2], next2])\n\n        # Calculate potential new costs\n        new_cost1 = (distance_matrix_1[prev1, new_solution[node2]] +\n                     distance_matrix_1[new_solution[node2], next1] +\n                     distance_matrix_1[prev2, new_solution[node1]] +\n                     distance_matrix_1[new_solution[node1], next2])\n\n        new_cost2 = (distance_matrix_2[prev1, new_solution[node2]] +\n                     distance_matrix_2[new_solution[node2], next1] +\n                     distance_matrix_2[prev2, new_solution[node1]] +\n                     distance_matrix_2[new_solution[node1], next2])\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{The new heuristic selects a solution from the archive by prioritizing those with the highest diversity in their tour structure, then applies a \"cross-space segment inversion\" local search that reverses segments of nodes while intelligently balancing improvements in both objective spaces through a multi-objective evaluation criterion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest structural diversity (measured by node sequence entropy)\n    def calculate_diversity(solution):\n        n = len(solution)\n        diversity = 0.0\n        for i in range(n):\n            prev = solution[i-1]\n            curr = solution[i]\n            next_node = solution[(i+1)%n]\n            diversity += abs(distance_matrix_1[prev, curr] - distance_matrix_2[curr, next_node])\n        return diversity\n\n    diversities = [calculate_diversity(sol) for sol, _ in archive]\n    selected_idx = np.argmax(diversities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Calculate segment's properties in both spaces before inversion\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Calculate segment's properties after inversion\n        inv_seg_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n        inv_seg_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Evaluate multi-objective improvement\n        original_cost = (seg_cost1, seg_cost2)\n        new_cost = (inv_seg_cost1, inv_seg_cost2)\n\n        # Only accept if both objectives are non-worse\n        if inv_seg_cost1 <= seg_cost1 and inv_seg_cost2 <= seg_cost2:\n            new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7780972273130479,
            2.6149444580078125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest structural diversity (measured by node sequence entropy)\n    def calculate_diversity(solution):\n        n = len(solution)\n        diversity = 0.0\n        for i in range(n):\n            prev = solution[i-1]\n            curr = solution[i]\n            next_node = solution[(i+1)%n]\n            diversity += abs(distance_matrix_1[prev, curr] - distance_matrix_2[curr, next_node])\n        return diversity\n\n    diversities = [calculate_diversity(sol) for sol, _ in archive]\n    selected_idx = np.argmax(diversities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Calculate segment's properties in both spaces before inversion\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Calculate segment's properties after inversion\n        inv_seg_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n        inv_seg_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Evaluate multi-objective improvement\n        original_cost = (seg_cost1, seg_cost2)\n        new_cost = (inv_seg_cost1, inv_seg_cost2)\n\n        # Only accept if both objectives are non-worse\n        if inv_seg_cost1 <= seg_cost1 and inv_seg_cost2 <= seg_cost2:\n            new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space node exchange\" local search that intelligently swaps nodes between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node exchange\n    if n > 2:\n        # Select two nodes to exchange\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:  # Only accept if there's improvement\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8370509554213903,
            0.43446868658065796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node exchange\n    if n > 2:\n        # Select two nodes to exchange\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:  # Only accept if there's improvement\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a novel \"cross-space node insertion\" local search that intelligently reinserts nodes based on their relative performance in both spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 2:\n        # Select a node to reinsert\n        node_pos = random.randint(1, n-2)\n        node = new_solution[node_pos]\n\n        # Calculate node's performance in both spaces\n        prev_node = new_solution[node_pos-1]\n        next_node = new_solution[node_pos+1]\n        current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Find best insertion point based on cross-space performance\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(1, n):\n            if pos == node_pos or pos == node_pos-1:\n                continue\n\n            # Calculate potential improvement\n            prev_node_new = new_solution[pos-1]\n            next_node_new = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node_new, next_node_new]\n            new_cost1 = (distance_matrix_1[prev_node_new, node] +\n                         distance_matrix_1[node, next_node_new])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node_new, next_node_new]\n            new_cost2 = (distance_matrix_2[prev_node_new, node] +\n                         distance_matrix_2[node, next_node_new])\n\n            # Weight improvement based on relative performance\n            weight1 = 1 - (objectives[selected_idx][0] / sum(objectives[selected_idx]))\n            weight2 = 1 - (objectives[selected_idx][1] / sum(objectives[selected_idx]))\n            improvement = (weight1 * (new_cost1 - old_cost1) + weight2 * (new_cost2 - old_cost2))\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:]\n            ])\n\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9595394585693926,
            1.9088652729988098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 2:\n        # Select a node to reinsert\n        node_pos = random.randint(1, n-2)\n        node = new_solution[node_pos]\n\n        # Calculate node's performance in both spaces\n        prev_node = new_solution[node_pos-1]\n        next_node = new_solution[node_pos+1]\n        current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Find best insertion point based on cross-space performance\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(1, n):\n            if pos == node_pos or pos == node_pos-1:\n                continue\n\n            # Calculate potential improvement\n            prev_node_new = new_solution[pos-1]\n            next_node_new = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node_new, next_node_new]\n            new_cost1 = (distance_matrix_1[prev_node_new, node] +\n                         distance_matrix_1[node, next_node_new])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node_new, next_node_new]\n            new_cost2 = (distance_matrix_2[prev_node_new, node] +\n                         distance_matrix_2[node, next_node_new])\n\n            # Weight improvement based on relative performance\n            weight1 = 1 - (objectives[selected_idx][0] / sum(objectives[selected_idx]))\n            weight2 = 1 - (objectives[selected_idx][1] / sum(objectives[selected_idx]))\n            improvement = (weight1 * (new_cost1 - old_cost1) + weight2 * (new_cost2 - old_cost2))\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node\n            new_solution = np.concatenate([\n                new_solution[:node_pos],\n                new_solution[node_pos+1:]\n            ])\n\n            # Insert node at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                [node],\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This heuristic intelligently selects a solution from the archive based on both objective values and applies a novel \"objective-balanced segment inversion and reinsertion\" local search that dynamically adjusts segment sizes and insertion points to explore the Pareto front while maintaining feasibility through comprehensive validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced objectives\n    objectives = [obj for _, obj in archive]\n    normalized = np.array(objectives) / np.max(objectives, axis=0)\n    scores = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Objective-balanced segment inversion and reinsertion\n    # Select segment size based on objective balance\n    obj_ratio = objectives[selected_idx][0] / objectives[selected_idx][1]\n    seg_size = max(2, min(n-1, int(n / (1 + abs(obj_ratio)))))\n\n    # Select random segment to invert\n    start = random.randint(0, n - seg_size)\n    segment = new_solution[start:start+seg_size]\n    inverted_segment = segment[::-1]\n\n    # Calculate segment costs in both spaces\n    seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(seg_size-1))\n    seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(seg_size-1))\n\n    inv_seg_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(seg_size-1))\n    inv_seg_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(seg_size-1))\n\n    # Calculate potential improvement\n    improvement1 = inv_seg_cost1 - seg_cost1\n    improvement2 = inv_seg_cost2 - seg_cost2\n\n    # Find best insertion point considering both objectives\n    best_pos = -1\n    best_score = float('inf')\n\n    for pos in range(n):\n        if pos >= start and pos < start + seg_size:\n            continue\n\n        # Calculate insertion cost\n        if pos == 0:\n            prev_node = new_solution[-1]\n        else:\n            prev_node = new_solution[pos-1]\n\n        if pos == n - 1:\n            next_node = new_solution[0]\n        else:\n            next_node = new_solution[pos]\n\n        # Original connection cost\n        old_cost1 = distance_matrix_1[prev_node, next_node]\n        old_cost2 = distance_matrix_2[prev_node, next_node]\n\n        # New connection cost after inversion\n        new_cost1 = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_node])\n        new_cost2 = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_node])\n\n        # Calculate combined score considering both objectives\n        cost_diff1 = new_cost1 - old_cost1\n        cost_diff2 = new_cost2 - old_cost2\n        score = abs(cost_diff1 + cost_diff2)\n\n        if score < best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove original segment\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+seg_size:]\n        ])\n\n        # Insert inverted segment at best position\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            inverted_segment,\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8894185276686734,
            0.5357034206390381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced objectives\n    objectives = [obj for _, obj in archive]\n    normalized = np.array(objectives) / np.max(objectives, axis=0)\n    scores = np.mean(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Objective-balanced segment inversion and reinsertion\n    # Select segment size based on objective balance\n    obj_ratio = objectives[selected_idx][0] / objectives[selected_idx][1]\n    seg_size = max(2, min(n-1, int(n / (1 + abs(obj_ratio)))))\n\n    # Select random segment to invert\n    start = random.randint(0, n - seg_size)\n    segment = new_solution[start:start+seg_size]\n    inverted_segment = segment[::-1]\n\n    # Calculate segment costs in both spaces\n    seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(seg_size-1))\n    seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(seg_size-1))\n\n    inv_seg_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(seg_size-1))\n    inv_seg_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(seg_size-1))\n\n    # Calculate potential improvement\n    improvement1 = inv_seg_cost1 - seg_cost1\n    improvement2 = inv_seg_cost2 - seg_cost2\n\n    # Find best insertion point considering both objectives\n    best_pos = -1\n    best_score = float('inf')\n\n    for pos in range(n):\n        if pos >= start and pos < start + seg_size:\n            continue\n\n        # Calculate insertion cost\n        if pos == 0:\n            prev_node = new_solution[-1]\n        else:\n            prev_node = new_solution[pos-1]\n\n        if pos == n - 1:\n            next_node = new_solution[0]\n        else:\n            next_node = new_solution[pos]\n\n        # Original connection cost\n        old_cost1 = distance_matrix_1[prev_node, next_node]\n        old_cost2 = distance_matrix_2[prev_node, next_node]\n\n        # New connection cost after inversion\n        new_cost1 = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_node])\n        new_cost2 = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_node])\n\n        # Calculate combined score considering both objectives\n        cost_diff1 = new_cost1 - old_cost1\n        cost_diff2 = new_cost2 - old_cost2\n        score = abs(cost_diff1 + cost_diff2)\n\n        if score < best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove original segment\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+seg_size:]\n        ])\n\n        # Insert inverted segment at best position\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            inverted_segment,\n            new_solution[best_pos:]\n        ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0498162463126683,
            0.5851778984069824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This heuristic selects a solution from the archive based on its dominance in the objective space, then applies a novel \"cross-space node swapping\" operator that intelligently exchanges nodes between the two objective spaces while maintaining feasibility through a systematic validation and repair process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select non-dominated solution if available, otherwise select randomly\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Cross-space node swapping\n        swap_pos1 = random.randint(0, n-1)\n        swap_pos2 = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        def calculate_improvement(a, b):\n            # Calculate the change in both objective spaces\n            prev_a = new_solution[a-1] if a > 0 else new_solution[-1]\n            next_a = new_solution[a+1] if a < n-1 else new_solution[0]\n            prev_b = new_solution[b-1] if b > 0 else new_solution[-1]\n            next_b = new_solution[b+1] if b < n-1 else new_solution[0]\n\n            old_cost1 = (distance_matrix_1[prev_a, a] + distance_matrix_1[a, next_a] +\n                         distance_matrix_1[prev_b, b] + distance_matrix_1[b, next_b])\n            new_cost1 = (distance_matrix_1[prev_a, b] + distance_matrix_1[b, next_a] +\n                         distance_matrix_1[prev_b, a] + distance_matrix_1[a, next_b])\n\n            old_cost2 = (distance_matrix_2[prev_a, a] + distance_matrix_2[a, next_a] +\n                         distance_matrix_2[prev_b, b] + distance_matrix_2[b, next_b])\n            new_cost2 = (distance_matrix_2[prev_a, b] + distance_matrix_2[b, next_a] +\n                         distance_matrix_2[prev_b, a] + distance_matrix_2[a, next_b])\n\n            return (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        # Try swapping nodes at swap_pos1 and swap_pos2\n        improvement = calculate_improvement(swap_pos1, swap_pos2)\n        if improvement < 0:  # If there's improvement\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8873118906227002,
            5.389925241470337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select non-dominated solution if available, otherwise select randomly\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Cross-space node swapping\n        swap_pos1 = random.randint(0, n-1)\n        swap_pos2 = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        def calculate_improvement(a, b):\n            # Calculate the change in both objective spaces\n            prev_a = new_solution[a-1] if a > 0 else new_solution[-1]\n            next_a = new_solution[a+1] if a < n-1 else new_solution[0]\n            prev_b = new_solution[b-1] if b > 0 else new_solution[-1]\n            next_b = new_solution[b+1] if b < n-1 else new_solution[0]\n\n            old_cost1 = (distance_matrix_1[prev_a, a] + distance_matrix_1[a, next_a] +\n                         distance_matrix_1[prev_b, b] + distance_matrix_1[b, next_b])\n            new_cost1 = (distance_matrix_1[prev_a, b] + distance_matrix_1[b, next_a] +\n                         distance_matrix_1[prev_b, a] + distance_matrix_1[a, next_b])\n\n            old_cost2 = (distance_matrix_2[prev_a, a] + distance_matrix_2[a, next_a] +\n                         distance_matrix_2[prev_b, b] + distance_matrix_2[b, next_b])\n            new_cost2 = (distance_matrix_2[prev_a, b] + distance_matrix_2[b, next_a] +\n                         distance_matrix_2[prev_b, a] + distance_matrix_2[a, next_b])\n\n            return (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        # Try swapping nodes at swap_pos1 and swap_pos2\n        improvement = calculate_improvement(swap_pos1, swap_pos2)\n        if improvement < 0:  # If there's improvement\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a diversity-aware metric, applies a novel hybrid local search operator that combines edge swaps with a guided segment relocation strategy to explore the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high diversity (maximize the sum of distances in both spaces)\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: Edge swap followed by segment relocation\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Relocate a segment to a new position\n    start = random.randint(0, n - 1)\n    length = random.randint(1, min(3, n - start))\n    segment = new_solution[start:start+length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7217218221927295,
            0.2846944332122803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high diversity (maximize the sum of distances in both spaces)\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: Edge swap followed by segment relocation\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Relocate a segment to a new position\n    start = random.randint(0, n - 1)\n    length = random.randint(1, min(3, n - start))\n    segment = new_solution[start:start+length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+length:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This heuristic selects a solution from the archive by combining objective-based selection with a novel \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with best balance between objectives\n    objectives = [obj for _, obj in archive]\n    normalized_scores = [(obj[0] + obj[1]) / (abs(obj[0] - obj[1]) + 1e-6) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Cross-space node swapping\n        node_a = random.randint(0, n-1)\n        node_b = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        prev_a = new_solution[node_a-1]\n        next_a = new_solution[(node_a+1)%n]\n        prev_b = new_solution[node_b-1]\n        next_b = new_solution[(node_b+1)%n]\n\n        # Current costs\n        cost1_before = (distance_matrix_1[prev_a, new_solution[node_a]] +\n                       distance_matrix_1[new_solution[node_a], next_a] +\n                       distance_matrix_1[prev_b, new_solution[node_b]] +\n                       distance_matrix_1[new_solution[node_b], next_b])\n\n        # Potential costs after swap\n        cost1_after = (distance_matrix_1[prev_a, new_solution[node_b]] +\n                      distance_matrix_1[new_solution[node_b], next_a] +\n                      distance_matrix_1[prev_b, new_solution[node_a]] +\n                      distance_matrix_1[new_solution[node_a], next_b])\n\n        # Perform swap if beneficial\n        if cost1_after < cost1_before:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8628208480465847,
            1.3388317823410034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with best balance between objectives\n    objectives = [obj for _, obj in archive]\n    normalized_scores = [(obj[0] + obj[1]) / (abs(obj[0] - obj[1]) + 1e-6) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Cross-space node swapping\n        node_a = random.randint(0, n-1)\n        node_b = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        prev_a = new_solution[node_a-1]\n        next_a = new_solution[(node_a+1)%n]\n        prev_b = new_solution[node_b-1]\n        next_b = new_solution[(node_b+1)%n]\n\n        # Current costs\n        cost1_before = (distance_matrix_1[prev_a, new_solution[node_a]] +\n                       distance_matrix_1[new_solution[node_a], next_a] +\n                       distance_matrix_1[prev_b, new_solution[node_b]] +\n                       distance_matrix_1[new_solution[node_b], next_b])\n\n        # Potential costs after swap\n        cost1_after = (distance_matrix_1[prev_a, new_solution[node_b]] +\n                      distance_matrix_1[new_solution[node_b], next_a] +\n                      distance_matrix_1[prev_b, new_solution[node_a]] +\n                      distance_matrix_1[new_solution[node_a], next_b])\n\n        # Perform swap if beneficial\n        if cost1_after < cost1_before:\n            new_solution[node_a], new_solution[node_b] = new_solution[node_b], new_solution[node_a]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive using a crowding-distance-based selection, applies a hybrid local search combining edge inversion and segment reversal to explore non-dominated regions, and ensures feasibility by validating the generated neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(objectives) - 1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Edge inversion for two random edges\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment reversal for a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7153968468236375,
            0.39552444219589233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(objectives) - 1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Edge inversion for two random edges\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment reversal for a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with the highest sum of raw objective values, then applies a \"cross-space segment reversal\" local search that intelligently reverses segments of the tour while considering both objective spaces to maintain feasibility and potentially improve both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest sum of raw objective values\n    objectives = [obj for _, obj in archive]\n    scores = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 2:\n        # Select segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        segment = new_solution[start:end+1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform reversal if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9684098571404939,
            0.2906554341316223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest sum of raw objective values\n    objectives = [obj for _, obj in archive]\n    scores = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 2:\n        # Select segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        segment = new_solution[start:end+1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform reversal if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the most balanced objective values, then applies a \"multi-space path inversion\" local search that flips segments of the tour in both objective spaces while ensuring feasibility through careful position validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most balanced objective values\n    objectives = [obj for _, obj in archive]\n    balance_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-space path inversion\n    if n > 3:\n        # Select two distinct inversion points\n        inv_start = random.randint(0, n-2)\n        inv_end = random.randint(inv_start+1, n-1)\n\n        # Invert the segment between the points\n        segment = new_solution[inv_start:inv_end]\n        inverted_segment = segment[::-1]\n\n        # Calculate cost changes in both spaces\n        old_cost1 = (distance_matrix_1[new_solution[inv_start-1], new_solution[inv_start]] +\n                     distance_matrix_1[new_solution[inv_end-1], new_solution[inv_end]])\n        new_cost1 = (distance_matrix_1[new_solution[inv_start-1], inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], new_solution[inv_end]])\n\n        old_cost2 = (distance_matrix_2[new_solution[inv_start-1], new_solution[inv_start]] +\n                     distance_matrix_2[new_solution[inv_end-1], new_solution[inv_end]])\n        new_cost2 = (distance_matrix_2[new_solution[inv_start-1], inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], new_solution[inv_end]])\n\n        # Apply inversion if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[inv_start:inv_end] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9277221659775978,
            0.28063517808914185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most balanced objective values\n    objectives = [obj for _, obj in archive]\n    balance_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-space path inversion\n    if n > 3:\n        # Select two distinct inversion points\n        inv_start = random.randint(0, n-2)\n        inv_end = random.randint(inv_start+1, n-1)\n\n        # Invert the segment between the points\n        segment = new_solution[inv_start:inv_end]\n        inverted_segment = segment[::-1]\n\n        # Calculate cost changes in both spaces\n        old_cost1 = (distance_matrix_1[new_solution[inv_start-1], new_solution[inv_start]] +\n                     distance_matrix_1[new_solution[inv_end-1], new_solution[inv_end]])\n        new_cost1 = (distance_matrix_1[new_solution[inv_start-1], inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], new_solution[inv_end]])\n\n        old_cost2 = (distance_matrix_2[new_solution[inv_start-1], new_solution[inv_start]] +\n                     distance_matrix_2[new_solution[inv_end-1], new_solution[inv_end]])\n        new_cost2 = (distance_matrix_2[new_solution[inv_start-1], inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], new_solution[inv_end]])\n\n        # Apply inversion if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[inv_start:inv_end] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The new heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a weighted score of its objectives, applies a hybrid local search combining segment reversal and node relocation, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a node to a new position\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8963710405771965,
            0.25067561864852905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a node to a new position\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This heuristic selects a solution from the archive based on crowding distance in the objective space to promote diversity, then applies a novel \"objective-balanced segment inversion\" operator that reverses a segment of the tour while considering both objectives to maintain balance in the solution's trade-off between the two spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            dist2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n\n        # Calculate cost change for both objectives\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n        # Balance the objectives in the decision\n        if (new_cost1 - old_cost1) + (new_cost2 - old_cost2) < 0 or random.random() < 0.3:\n            # Perform inversion if it improves or with some probability\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9217071756378408,
            0.36966991424560547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance in objective space\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            dist2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n\n        # Calculate cost change for both objectives\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n        # Balance the objectives in the decision\n        if (new_cost1 - old_cost1) + (new_cost2 - old_cost2) < 0 or random.random() < 0.3:\n            # Perform inversion if it improves or with some probability\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive, applies a novel local search operator that combines edge swaps with a biased random walk to explore the solution space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Perform a biased random walk to select a segment\n    current_pos = random.randint(0, n - 1)\n    step_size = random.randint(1, min(3, n - 1))\n    for _ in range(step_size):\n        direction = random.choice([-1, 1])\n        current_pos = (current_pos + direction) % n\n\n    # Step 2: Swap edges in the selected segment\n    start = current_pos\n    end = (current_pos + random.randint(2, min(5, n - 1))) % n\n    if start > end:\n        start, end = end, start\n\n    segment = new_solution[start:end+1]\n    if len(segment) >= 2:\n        swap_pos1 = random.randint(0, len(segment) - 1)\n        swap_pos2 = random.randint(0, len(segment) - 1)\n        segment[swap_pos1], segment[swap_pos2] = segment[swap_pos2], segment[swap_pos1]\n        new_solution[start:end+1] = segment\n\n    # Step 3: Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8895078000779404,
            0.30352121591567993
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Perform a biased random walk to select a segment\n    current_pos = random.randint(0, n - 1)\n    step_size = random.randint(1, min(3, n - 1))\n    for _ in range(step_size):\n        direction = random.choice([-1, 1])\n        current_pos = (current_pos + direction) % n\n\n    # Step 2: Swap edges in the selected segment\n    start = current_pos\n    end = (current_pos + random.randint(2, min(5, n - 1))) % n\n    if start > end:\n        start, end = end, start\n\n    segment = new_solution[start:end+1]\n    if len(segment) >= 2:\n        swap_pos1 = random.randint(0, len(segment) - 1)\n        swap_pos2 = random.randint(0, len(segment) - 1)\n        segment[swap_pos1], segment[swap_pos2] = segment[swap_pos2], segment[swap_pos1]\n        new_solution[start:end+1] = segment\n\n    # Step 3: Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This heuristic selects a solution from the archive by considering both objective values and their trade-offs, then applies a \"multi-segment inversion and reinsertion\" local search that intelligently inverts multiple segments and reinserts them at new positions while ensuring feasibility through careful validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced objective values (considering trade-off)\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select multiple random segments and invert them\n    num_segments = random.randint(1, min(3, n//2))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + n//3, n - 1))\n        segments.append((start, end))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert each segment at a new position\n    for start, end in segments:\n        segment = new_solution[start:end+1]\n        new_solution = np.delete(new_solution, slice(start, end+1))\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6981169992176945,
            0.33237576484680176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced objective values (considering trade-off)\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select multiple random segments and invert them\n    num_segments = random.randint(1, min(3, n//2))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + n//3, n - 1))\n        segments.append((start, end))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert each segment at a new position\n    for start, end in segments:\n        segment = new_solution[start:end+1]\n        new_solution = np.delete(new_solution, slice(start, end+1))\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined improvement potential in both objective spaces, then applies a \"multi-segment inversion and reinsertion\" local search that intelligently inverts multiple segments and reinserts them at new positions while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined improvement potential\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    improvement_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and reinsertion\n    num_segments = random.randint(1, min(3, n//2))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        segments.append((start, end))\n\n    # Invert selected segments\n    for start, end in segments:\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Reinsert segments at new positions\n    for start, end in segments:\n        segment = new_solution[start:end+1]\n        # Remove segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        # Insert at new position\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7397663415635479,
            0.26846158504486084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined improvement potential\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    improvement_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and reinsertion\n    num_segments = random.randint(1, min(3, n//2))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        segments.append((start, end))\n\n    # Invert selected segments\n    for start, end in segments:\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Reinsert segments at new positions\n    for start, end in segments:\n        segment = new_solution[start:end+1]\n        # Remove segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        # Insert at new position\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This heuristic selects a solution from the archive based on the highest combined objective value, then applies a \"cross-space segment reversal\" local search that reverses segments of the tour in one objective space while preserving feasibility, with the potential to improve both objectives through coordinated adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective value\n    objectives = [obj for _, obj in archive]\n    combined_scores = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 3:\n        # Select segment boundaries\n        a = random.randint(0, n-3)\n        b = random.randint(a+1, n-1)\n\n        # Reverse the segment in one objective space\n        space_choice = random.choice([1, 2])\n        if space_choice == 1:\n            # Calculate potential improvement in space 1\n            old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n\n            if new_cost < old_cost:\n                # Reverse the segment\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Calculate potential improvement in space 2\n            old_cost = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if new_cost < old_cost:\n                # Reverse the segment\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9189884531517375,
            0.3672547936439514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective value\n    objectives = [obj for _, obj in archive]\n    combined_scores = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 3:\n        # Select segment boundaries\n        a = random.randint(0, n-3)\n        b = random.randint(a+1, n-1)\n\n        # Reverse the segment in one objective space\n        space_choice = random.choice([1, 2])\n        if space_choice == 1:\n            # Calculate potential improvement in space 1\n            old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n\n            if new_cost < old_cost:\n                # Reverse the segment\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Calculate potential improvement in space 2\n            old_cost = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            new_cost = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n            if new_cost < old_cost:\n                # Reverse the segment\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This algorithm selects a solution from the archive based on the weighted sum of normalized objective values, then applies a \"path segment inversion with cross-space validation\" local search that reverses a random segment of the tour while ensuring feasibility and checking for improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with weighted normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    weighted_scores = [(weights[0]*(obj[0]/max_obj1) + weights[1]*(obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path segment inversion\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n-3)\n        end = random.randint(start+2, n-1)\n\n        # Calculate old and new costs\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            segment = new_solution[start:end+1]\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.890462991586176,
            0.2902079224586487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with weighted normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    weighted_scores = [(weights[0]*(obj[0]/max_obj1) + weights[1]*(obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path segment inversion\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n-3)\n        end = random.randint(start+2, n-1)\n\n        # Calculate old and new costs\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            segment = new_solution[start:end+1]\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest individual objective values in either space, then applies a novel \"cross-space node swap\" local search that intelligently exchanges nodes between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest individual objective values in either space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    candidates = [i for i, obj in enumerate(objectives) if obj[0] == max_obj1 or obj[1] == max_obj2]\n\n    if not candidates:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swap\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Apply the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7790687106760046,
            0.802374541759491
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest individual objective values in either space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    candidates = [i for i, obj in enumerate(objectives) if obj[0] == max_obj1 or obj[1] == max_obj2]\n\n    if not candidates:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swap\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Apply the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node swapping and segment reversal to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select two random nodes and swap their positions\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Select a random segment and reverse it\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9579619560379644,
            0.22191625833511353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select two random nodes and swap their positions\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Select a random segment and reverse it\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a \"cross-space segment reversal\" local search that reverses segments of the tour in both objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    obj1_vals = [obj[0] for obj in objectives]\n    obj2_vals = [obj[1] for obj in objectives]\n    mean_obj1 = np.mean(obj1_vals)\n    mean_obj2 = np.mean(obj2_vals)\n    diversity_scores = [(abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 2:\n        # Select a segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform reversal if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7377570558736335,
            1.0355505347251892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    obj1_vals = [obj[0] for obj in objectives]\n    obj2_vals = [obj[1] for obj in objectives]\n    mean_obj1 = np.mean(obj1_vals)\n    mean_obj2 = np.mean(obj2_vals)\n    diversity_scores = [(abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 2:\n        # Select a segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform reversal if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"multi-segment inversion\" local search that randomly inverts segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_dist = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives)-1:\n            crowding_dist.append(float('inf'))\n        else:\n            dist1 = abs(sorted_obj1[i+1][0] - sorted_obj1[i-1][0])\n            dist2 = abs(sorted_obj2[i+1][1] - sorted_obj2[i-1][1])\n            crowding_dist.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n        # Ensure segments don't overlap\n        if b >= c and d >= a:\n            if random.random() < 0.5:\n                a, c = c, a\n                b, d = d, b\n\n        # Invert segments\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.70309155018392,
            0.33933502435684204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_dist = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives)-1:\n            crowding_dist.append(float('inf'))\n        else:\n            dist1 = abs(sorted_obj1[i+1][0] - sorted_obj1[i-1][0])\n            dist2 = abs(sorted_obj2[i+1][1] - sorted_obj2[i-1][1])\n            crowding_dist.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n        # Ensure segments don't overlap\n        if b >= c and d >= a:\n            if random.random() < 0.5:\n                a, c = c, a\n                b, d = d, b\n\n        # Invert segments\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines path reversal with node relocation to explore the solution space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a trade-off between objectives and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Reverse a random segment to create a new path structure\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position that improves both objectives\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_pos = random.randint(0, n - 1)\n\n    # Ensure the node is moved to a different position\n    if new_pos == node_pos:\n        new_pos = (new_pos + 1) % n\n\n    # Remove the node and insert it at the new position\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8660020419443412,
            0.22555649280548096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a trade-off between objectives and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Reverse a random segment to create a new path structure\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position that improves both objectives\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_pos = random.randint(0, n - 1)\n\n    # Ensure the node is moved to a different position\n    if new_pos == node_pos:\n        new_pos = (new_pos + 1) % n\n\n    # Remove the node and insert it at the new position\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a \"multi-segment inversion and reinsertion\" operator that inverts multiple segments of the tour and reinserts them at different positions while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    std_obj1 = np.std(obj1_values)\n    std_obj2 = np.std(obj2_values)\n    diversity_scores = [std_obj1 * obj[0] + std_obj2 * obj[1] for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple segments to invert\n        num_segments = random.randint(1, min(3, n // 4))\n        segments = []\n        for _ in range(num_segments):\n            start = random.randint(0, n - 2)\n            end = random.randint(start + 1, min(start + n // 3, n - 1))\n            segments.append((start, end))\n\n        # Invert each selected segment\n        for start, end in segments:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Reinsert segments at new positions\n        for start, end in segments:\n            segment = new_solution[start:end+1]\n            # Remove segment from current position\n            new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n            # Insert at new random position\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9588936271760503,
            0.6753323078155518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    std_obj1 = np.std(obj1_values)\n    std_obj2 = np.std(obj2_values)\n    diversity_scores = [std_obj1 * obj[0] + std_obj2 * obj[1] for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple segments to invert\n        num_segments = random.randint(1, min(3, n // 4))\n        segments = []\n        for _ in range(num_segments):\n            start = random.randint(0, n - 2)\n            end = random.randint(start + 1, min(start + n // 3, n - 1))\n            segments.append((start, end))\n\n        # Invert each selected segment\n        for start, end in segments:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Reinsert segments at new positions\n        for start, end in segments:\n            segment = new_solution[start:end+1]\n            # Remove segment from current position\n            new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n            # Insert at new random position\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their objective values (measured by the product of differences from the average objectives), then applies a \"cross-segment relocation\" local search that intelligently moves entire segments of nodes between positions in the tour while considering both objective spaces, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = np.mean([obj[0] for obj in objectives])\n    avg_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [(abs(obj[0] - avg_obj1) * abs(obj[1] - avg_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-segment relocation\n    if n > 3:\n        # Select a segment of nodes\n        segment_start = random.randint(0, n-3)\n        segment_length = random.randint(2, min(5, n-segment_start-1))\n        segment = new_solution[segment_start:segment_start+segment_length]\n\n        # Find a new position to insert the segment\n        new_pos = random.randint(0, n-segment_length)\n        while abs(new_pos - segment_start) < segment_length:\n            new_pos = random.randint(0, n-segment_length)\n\n        # Remove the segment\n        new_solution = np.concatenate([\n            new_solution[:segment_start],\n            new_solution[segment_start+segment_length:]\n        ])\n\n        # Insert the segment at new position\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n        # Calculate potential improvement\n        old_cost1 = 0\n        old_cost2 = 0\n        new_cost1 = 0\n        new_cost2 = 0\n\n        # Original segment connections\n        if segment_start > 0:\n            old_cost1 += distance_matrix_1[new_solution[segment_start-1], segment[0]]\n            old_cost2 += distance_matrix_2[new_solution[segment_start-1], segment[0]]\n        if segment_start + segment_length < n:\n            old_cost1 += distance_matrix_1[segment[-1], new_solution[segment_start+segment_length]]\n            old_cost2 += distance_matrix_2[segment[-1], new_solution[segment_start+segment_length]]\n\n        # New segment connections\n        if new_pos > 0:\n            new_cost1 += distance_matrix_1[new_solution[new_pos-1], segment[0]]\n            new_cost2 += distance_matrix_2[new_solution[new_pos-1], segment[0]]\n        if new_pos + segment_length < n:\n            new_cost1 += distance_matrix_1[segment[-1], new_solution[new_pos+segment_length]]\n            new_cost2 += distance_matrix_2[segment[-1], new_solution[new_pos+segment_length]]\n\n        # Additional connections if segment was moved forward\n        if new_pos < segment_start:\n            if segment_start + segment_length < n:\n                old_cost1 += distance_matrix_1[new_solution[segment_start+segment_length-1], new_solution[segment_start+segment_length]]\n                old_cost2 += distance_matrix_2[new_solution[segment_start+segment_length-1], new_solution[segment_start+segment_length]]\n            if new_pos + segment_length < n:\n                new_cost1 += distance_matrix_1[new_solution[new_pos+segment_length-1], new_solution[new_pos+segment_length]]\n                new_cost2 += distance_matrix_2[new_solution[new_pos+segment_length-1], new_solution[new_pos+segment_length]]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8005822002965473,
            1.5433947443962097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = np.mean([obj[0] for obj in objectives])\n    avg_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [(abs(obj[0] - avg_obj1) * abs(obj[1] - avg_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-segment relocation\n    if n > 3:\n        # Select a segment of nodes\n        segment_start = random.randint(0, n-3)\n        segment_length = random.randint(2, min(5, n-segment_start-1))\n        segment = new_solution[segment_start:segment_start+segment_length]\n\n        # Find a new position to insert the segment\n        new_pos = random.randint(0, n-segment_length)\n        while abs(new_pos - segment_start) < segment_length:\n            new_pos = random.randint(0, n-segment_length)\n\n        # Remove the segment\n        new_solution = np.concatenate([\n            new_solution[:segment_start],\n            new_solution[segment_start+segment_length:]\n        ])\n\n        # Insert the segment at new position\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n        # Calculate potential improvement\n        old_cost1 = 0\n        old_cost2 = 0\n        new_cost1 = 0\n        new_cost2 = 0\n\n        # Original segment connections\n        if segment_start > 0:\n            old_cost1 += distance_matrix_1[new_solution[segment_start-1], segment[0]]\n            old_cost2 += distance_matrix_2[new_solution[segment_start-1], segment[0]]\n        if segment_start + segment_length < n:\n            old_cost1 += distance_matrix_1[segment[-1], new_solution[segment_start+segment_length]]\n            old_cost2 += distance_matrix_2[segment[-1], new_solution[segment_start+segment_length]]\n\n        # New segment connections\n        if new_pos > 0:\n            new_cost1 += distance_matrix_1[new_solution[new_pos-1], segment[0]]\n            new_cost2 += distance_matrix_2[new_solution[new_pos-1], segment[0]]\n        if new_pos + segment_length < n:\n            new_cost1 += distance_matrix_1[segment[-1], new_solution[new_pos+segment_length]]\n            new_cost2 += distance_matrix_2[segment[-1], new_solution[new_pos+segment_length]]\n\n        # Additional connections if segment was moved forward\n        if new_pos < segment_start:\n            if segment_start + segment_length < n:\n                old_cost1 += distance_matrix_1[new_solution[segment_start+segment_length-1], new_solution[segment_start+segment_length]]\n                old_cost2 += distance_matrix_2[new_solution[segment_start+segment_length-1], new_solution[segment_start+segment_length]]\n            if new_pos + segment_length < n:\n                new_cost1 += distance_matrix_1[new_solution[new_pos+segment_length-1], new_solution[new_pos+segment_length]]\n                new_cost2 += distance_matrix_2[new_solution[new_pos+segment_length-1], new_solution[new_pos+segment_length]]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node relocation and segment reversal to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8873080696737043,
            0.46677976846694946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"bi-objective path inversion\" local search that reverses segments of the tour while considering both objective spaces, ensuring feasibility through careful boundary checks and validation, and evaluating improvements based on both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Bi-objective path inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(7, n-seg_start-1))\n\n        # Calculate original costs\n        orig_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_start+seg_length-1))\n        orig_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_start+seg_length-1))\n\n        # Invert the segment\n        inverted_segment = new_solution[seg_start:seg_start+seg_length][::-1]\n        new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_start+seg_length-1))\n        new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_start+seg_length-1))\n\n        # If no improvement in either objective, revert\n        if (new_cost1 >= orig_cost1) and (new_cost2 >= orig_cost2):\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8939752313904099,
            0.5339764952659607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Bi-objective path inversion\n    if n > 3:\n        # Select a segment to invert\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(7, n-seg_start-1))\n\n        # Calculate original costs\n        orig_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_start+seg_length-1))\n        orig_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_start+seg_length-1))\n\n        # Invert the segment\n        inverted_segment = new_solution[seg_start:seg_start+seg_length][::-1]\n        new_solution[seg_start:seg_start+seg_length] = inverted_segment\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_start+seg_length-1))\n        new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_start+seg_length-1))\n\n        # If no improvement in either objective, revert\n        if (new_cost1 >= orig_cost1) and (new_cost2 >= orig_cost2):\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-space segment inversion\" local search that intelligently reverses segments of nodes across both objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n\n        segment = new_solution[start:end+1]\n        reversed_segment = segment[::-1]\n        new_solution[start:end+1] = reversed_segment\n\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, reversed_segment[0]] +\n                     distance_matrix_1[reversed_segment[-1], next_end])\n\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, reversed_segment[0]] +\n                     distance_matrix_2[reversed_segment[-1], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            new_solution[start:end+1] = segment\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8394096059020848,
            0.5434391498565674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n\n        segment = new_solution[start:end+1]\n        reversed_segment = segment[::-1]\n        new_solution[start:end+1] = reversed_segment\n\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, reversed_segment[0]] +\n                     distance_matrix_1[reversed_segment[-1], next_end])\n\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, reversed_segment[0]] +\n                     distance_matrix_2[reversed_segment[-1], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            new_solution[start:end+1] = segment\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"multi-segment inversion and cross-space alignment\" local search that intelligently inverts segments of the tour and aligns nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    obj1_sorted = sorted(objectives, key=lambda x: x[0])\n    obj2_sorted = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(archive)):\n        obj = objectives[i]\n        idx1 = obj1_sorted.index(obj)\n        idx2 = obj2_sorted.index(obj)\n\n        if idx1 == 0 or idx1 == len(obj1_sorted)-1:\n            dist1 = float('inf')\n        else:\n            dist1 = obj1_sorted[idx1+1][0] - obj1_sorted[idx1-1][0]\n\n        if idx2 == 0 or idx2 == len(obj2_sorted)-1:\n            dist2 = float('inf')\n        else:\n            dist2 = obj2_sorted[idx2+1][1] - obj2_sorted[idx2-1][1]\n\n        crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment inversion\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Cross-space alignment\n        for i in range(n):\n            node = new_solution[i]\n            coords = instance[node]\n            x1, y1, x2, y2 = coords\n\n            # Find node with closest coordinates in the other space\n            for j in range(n):\n                if j == i:\n                    continue\n                other_node = new_solution[j]\n                other_coords = instance[other_node]\n                ox1, oy1, ox2, oy2 = other_coords\n\n                # Calculate distances in both spaces\n                dist1 = np.sqrt((x1-ox1)**2 + (y1-oy1)**2)\n                dist2 = np.sqrt((x2-ox2)**2 + (y2-oy2)**2)\n\n                if dist1 < 0.1 and dist2 < 0.1:  # Threshold for alignment\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5384156733590599,
            3.7024840116500854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    obj1_sorted = sorted(objectives, key=lambda x: x[0])\n    obj2_sorted = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(archive)):\n        obj = objectives[i]\n        idx1 = obj1_sorted.index(obj)\n        idx2 = obj2_sorted.index(obj)\n\n        if idx1 == 0 or idx1 == len(obj1_sorted)-1:\n            dist1 = float('inf')\n        else:\n            dist1 = obj1_sorted[idx1+1][0] - obj1_sorted[idx1-1][0]\n\n        if idx2 == 0 or idx2 == len(obj2_sorted)-1:\n            dist2 = float('inf')\n        else:\n            dist2 = obj2_sorted[idx2+1][1] - obj2_sorted[idx2-1][1]\n\n        crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment inversion\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Cross-space alignment\n        for i in range(n):\n            node = new_solution[i]\n            coords = instance[node]\n            x1, y1, x2, y2 = coords\n\n            # Find node with closest coordinates in the other space\n            for j in range(n):\n                if j == i:\n                    continue\n                other_node = new_solution[j]\n                other_coords = instance[other_node]\n                ox1, oy1, ox2, oy2 = other_coords\n\n                # Calculate distances in both spaces\n                dist1 = np.sqrt((x1-ox1)**2 + (y1-oy1)**2)\n                dist2 = np.sqrt((x2-ox2)**2 + (y2-oy2)**2)\n\n                if dist1 < 0.1 and dist2 < 0.1:  # Threshold for alignment\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating its potential for improvement, then applies a hybrid local search combining 2-opt with a novel node reinsertion strategy to explore non-dominated regions, ensuring feasibility by validating the tour structure before returning the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: 2-opt with node reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # 2-opt move\n\n    # Node reinsertion\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0066041589623453,
            0.06425052881240845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: 2-opt with node reinsertion\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # 2-opt move\n\n    # Node reinsertion\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{This heuristic selects a solution from the archive based on its dominance score, then applies a \"multi-segment shuffle and reinsertion\" local search that intelligently reorders and reinserts multiple segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest dominance score (simplified)\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    dominance_scores = [(obj[0]/max_obj1) * (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment shuffle and reinsertion\n    num_segments = random.randint(2, min(4, n//3))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments-1))\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Reinsert segments at new positions\n    for _ in range(2):\n        if len(new_solution) > 3:\n            seg_length = random.randint(1, min(3, len(new_solution)-2))\n            seg_start = random.randint(0, len(new_solution)-seg_length)\n            segment = new_solution[seg_start:seg_start+seg_length]\n            new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_length:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.71717199889092,
            0.3653436303138733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest dominance score (simplified)\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    dominance_scores = [(obj[0]/max_obj1) * (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment shuffle and reinsertion\n    num_segments = random.randint(2, min(4, n//3))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments-1))\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Reinsert segments at new positions\n    for _ in range(2):\n        if len(new_solution) > 3:\n            seg_length = random.randint(1, min(3, len(new_solution)-2))\n            seg_start = random.randint(0, len(new_solution)-seg_length)\n            segment = new_solution[seg_start:seg_start+seg_length]\n            new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_length:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"segment inversion\" local search that reverses a randomly selected segment of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n        new_solution[start:end+1] = inverted_segment\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:end+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6688849531993866,
            0.3473047614097595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n        new_solution[start:end+1] = inverted_segment\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:end+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"segment inversion with cross-space validation\" local search that inverts a random segment of the tour while ensuring feasibility through careful validation and repair mechanisms, while also considering the impact on both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    obj1_sorted = sorted(objectives, key=lambda x: x[0])\n    obj2_sorted = sorted(objectives, key=lambda x: x[1])\n    crowding_distances = []\n\n    for i, obj in enumerate(objectives):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            obj1_prev, obj1_next = obj1_sorted[i-1][0], obj1_sorted[i+1][0]\n            obj2_prev, obj2_next = obj2_sorted[i-1][1], obj2_sorted[i+1][1]\n            crowding_dist = abs(obj1_next - obj1_prev) + abs(obj2_next - obj2_prev)\n            crowding_distances.append(crowding_dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 3:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n        new_solution[start:end+1] = inverted_segment\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement > 0:\n            # Revert if it doesn't improve the solution\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9287160595275767,
            0.5054285526275635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    obj1_sorted = sorted(objectives, key=lambda x: x[0])\n    obj2_sorted = sorted(objectives, key=lambda x: x[1])\n    crowding_distances = []\n\n    for i, obj in enumerate(objectives):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            obj1_prev, obj1_next = obj1_sorted[i-1][0], obj1_sorted[i+1][0]\n            obj2_prev, obj2_next = obj2_sorted[i-1][1], obj2_sorted[i+1][1]\n            crowding_dist = abs(obj1_next - obj1_prev) + abs(obj2_next - obj2_prev)\n            crowding_distances.append(crowding_dist)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 3:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n        new_solution[start:end+1] = inverted_segment\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement > 0:\n            # Revert if it doesn't improve the solution\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This heuristic selects a solution from the archive based on a hybrid score combining objective values and solution diversity, then applies a \"multi-segment inversion\" local search that flips segments of the tour in both objective spaces while preserving feasibility through careful boundary checks and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Hybrid score function: combine objective values and solution diversity\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    diversity_scores = [len(set(sol)) for sol, _ in archive]  # Simple diversity measure\n    hybrid_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) * div for (obj, div) in zip(objectives, diversity_scores)]\n    selected_idx = np.argmax(hybrid_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two distinct segments\n        points = sorted(random.sample(range(n), 4))\n        a, b, c, d = points[0], points[1], points[2], points[3]\n\n        # Create new segments\n        segment1 = new_solution[a:b][::-1]\n        segment2 = new_solution[c:d][::-1]\n\n        # Apply inversion to both segments\n        new_solution[a:b] = segment1\n        new_solution[c:d] = segment2\n\n        # Validate feasibility\n        if len(set(new_solution)) == n:\n            # Check if inversion improves at least one objective\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            # Calculate new cost (approximate)\n            new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 <= old_cost1) or (new_cost2 <= old_cost2):\n                return new_solution\n\n    return base_solution\n\n",
        "score": [
            -0.9193189305461646,
            0.8943418860435486
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Hybrid score function: combine objective values and solution diversity\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    diversity_scores = [len(set(sol)) for sol, _ in archive]  # Simple diversity measure\n    hybrid_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) * div for (obj, div) in zip(objectives, diversity_scores)]\n    selected_idx = np.argmax(hybrid_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two distinct segments\n        points = sorted(random.sample(range(n), 4))\n        a, b, c, d = points[0], points[1], points[2], points[3]\n\n        # Create new segments\n        segment1 = new_solution[a:b][::-1]\n        segment2 = new_solution[c:d][::-1]\n\n        # Apply inversion to both segments\n        new_solution[a:b] = segment1\n        new_solution[c:d] = segment2\n\n        # Validate feasibility\n        if len(set(new_solution)) == n:\n            # Check if inversion improves at least one objective\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            # Calculate new cost (approximate)\n            new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 <= old_cost1) or (new_cost2 <= old_cost2):\n                return new_solution\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"multi-segment reversal\" local search that randomly reverses segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    if n > 2:\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7246653186740688,
            0.48091357946395874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    if n > 2:\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective value improvement potential, then applies a \"multi-segment inversion\" local search that randomly inverts segments of the tour in both objective spaces while carefully maintaining feasibility through segment validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest potential for improvement\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    potential_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) * (1 - min(obj[0], obj[1])/max(max_obj1, max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Randomly select two points to define inversion segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments don't overlap\n        if b <= c or d <= a:\n            # Invert first segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n            # Invert second segment\n            new_solution[c:d] = new_solution[c:d][::-1]\n        else:\n            # If segments overlap, invert the union\n            new_solution[a:d] = new_solution[a:d][::-1]\n\n        # Validate solution\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5713883306120717,
            0.5983263254165649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest potential for improvement\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    potential_scores = [(obj[0]/max_obj1 + obj[1]/max_obj2) * (1 - min(obj[0], obj[1])/max(max_obj1, max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Randomly select two points to define inversion segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments don't overlap\n        if b <= c or d <= a:\n            # Invert first segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n            # Invert second segment\n            new_solution[c:d] = new_solution[c:d][::-1]\n        else:\n            # If segments overlap, invert the union\n            new_solution[a:d] = new_solution[a:d][::-1]\n\n        # Validate solution\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"cross-space segment reversal\" local search that reverses segments of the tour in one space while maintaining feasibility and potentially improving the other space's cost.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 2:\n        # Select a random segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        segment = new_solution[start:end+1]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[start:end+1] = reversed_segment\n\n        # Calculate potential improvement\n        def calculate_cost(solution, distance_matrix):\n            total_cost = 0\n            for i in range(n):\n                total_cost += distance_matrix[solution[i-1], solution[i]]\n            return total_cost\n\n        old_cost1 = calculate_cost(base_solution, distance_matrix_1)\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        old_cost2 = calculate_cost(base_solution, distance_matrix_2)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if it doesn't improve the solution\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8537046500823543,
            4.116377949714661
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 2:\n        # Select a random segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        segment = new_solution[start:end+1]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[start:end+1] = reversed_segment\n\n        # Calculate potential improvement\n        def calculate_cost(solution, distance_matrix):\n            total_cost = 0\n            for i in range(n):\n                total_cost += distance_matrix[solution[i-1], solution[i]]\n            return total_cost\n\n        old_cost1 = calculate_cost(base_solution, distance_matrix_1)\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        old_cost2 = calculate_cost(base_solution, distance_matrix_2)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if it doesn't improve the solution\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a combined objective score, applies a novel local search operator that combines segment reversal with node swapping, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_scores = [sum(obj) for _, obj in archive]\n    selected_idx = combined_scores.index(min(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8304897199523558,
            0.2787421941757202
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    combined_scores = [sum(obj) for _, obj in archive]\n    selected_idx = combined_scores.index(min(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment inversion\" local search that intelligently inverts segments of the tour between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end]\n\n        # Calculate potential improvement\n        prev = new_solution[start-1]\n        next_ = new_solution[end%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev, new_solution[start]] +\n                     distance_matrix_1[new_solution[end-1], next_])\n\n        new_cost1 = (distance_matrix_1[prev, new_solution[end-1]] +\n                     distance_matrix_1[new_solution[start], next_])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev, new_solution[start]] +\n                     distance_matrix_2[new_solution[end-1], next_])\n\n        new_cost2 = (distance_matrix_2[prev, new_solution[end-1]] +\n                     distance_matrix_2[new_solution[start], next_])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9111395434573256,
            0.8268114328384399
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end]\n\n        # Calculate potential improvement\n        prev = new_solution[start-1]\n        next_ = new_solution[end%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev, new_solution[start]] +\n                     distance_matrix_1[new_solution[end-1], next_])\n\n        new_cost1 = (distance_matrix_1[prev, new_solution[end-1]] +\n                     distance_matrix_1[new_solution[start], next_])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev, new_solution[start]] +\n                     distance_matrix_2[new_solution[end-1], next_])\n\n        new_cost2 = (distance_matrix_2[prev, new_solution[end-1]] +\n                     distance_matrix_2[new_solution[start], next_])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a novel \"multi-space segment inversion\" local search that reverses segments of the tour while considering both objective spaces, ensuring feasibility through careful segment validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(sorted_indices) - 1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5641273296143939,
            2.8339141607284546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(sorted_indices) - 1):\n            crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on objective diversity, applies a hybrid local search operator that combines node swap and segment reversal to explore the solution space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Randomly select two distinct nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random segment to explore different orderings\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9297197889176662,
            1.473626732826233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Randomly select two distinct nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random segment to explore different orderings\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"multi-segment inversion\" local search that randomly inverts segments of the tour while ensuring feasibility through careful boundary checks and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            dist2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Randomly select two points and invert the segment between them\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6547385847195039,
            0.6538481116294861
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            dist2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Randomly select two points and invert the segment between them\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment reversal\" local search that reverses segments of the tour in one objective space while maintaining feasibility, combined with a \"node insertion\" mechanism in the other objective space to balance improvements across both spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal and node insertion\n    if n > 3:\n        # Select a random segment to reverse in one space\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate improvement in first space\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Select a node to reinsert in second space\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Calculate improvement in second space\n        old_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9657145290527815,
            0.4918060898780823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal and node insertion\n    if n > 3:\n        # Select a random segment to reverse in one space\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Calculate improvement in first space\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # Select a node to reinsert in second space\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Calculate improvement in second space\n        old_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a score function combining crowding distance and objective improvements, then applies a hybrid local search combining segment reversal and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate scores for each solution in the archive\n    scores = []\n    for sol, obj in archive:\n        # Crowding distance (approximate)\n        crowding = sum(abs(obj[0] - o[0]) + abs(obj[1] - o[1]) for s, o in archive if s is not sol)\n        # Objective improvement potential (simplified)\n        improvement = (obj[0] + obj[1]) / (len(sol) * len(sol))\n        scores.append(crowding * improvement)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Hybrid local search: segment reversal + node relocation\n    # Segment reversal\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node relocation\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_pos = random.randint(0, n - 1)\n    if new_pos > node_pos:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:new_pos+1], [node], new_solution[new_pos+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:node_pos], new_solution[node_pos+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5909274464546048,
            8.343777179718018
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate scores for each solution in the archive\n    scores = []\n    for sol, obj in archive:\n        # Crowding distance (approximate)\n        crowding = sum(abs(obj[0] - o[0]) + abs(obj[1] - o[1]) for s, o in archive if s is not sol)\n        # Objective improvement potential (simplified)\n        improvement = (obj[0] + obj[1]) / (len(sol) * len(sol))\n        scores.append(crowding * improvement)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Hybrid local search: segment reversal + node relocation\n    # Segment reversal\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node relocation\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_pos = random.randint(0, n - 1)\n    if new_pos > node_pos:\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:new_pos+1], [node], new_solution[new_pos+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:node_pos], new_solution[node_pos+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"cross-space segment inversion\" local search that flips a random segment of nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, base_solution[start]] +\n                     distance_matrix_1[base_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, base_solution[start]] +\n                     distance_matrix_2[base_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5901987324717615,
            4.141409635543823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, base_solution[start]] +\n                     distance_matrix_1[base_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, base_solution[start]] +\n                     distance_matrix_2[base_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment inversion\" local search that intelligently inverts segments of nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0 or random.random() < 0.3:  # Allow some non-improving moves\n            new_solution[start:end+1] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8758461477353792,
            0.37208443880081177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0 or random.random() < 0.3:  # Allow some non-improving moves\n            new_solution[start:end+1] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a novel \"multi-space segment inversion and relocation\" operator that flips and repositions segments of the tour in both objective spaces simultaneously to explore diverse regions of the Pareto front while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Step 1: Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance\n        sorted_idx1 = np.argsort(objectives[:, 0])\n        sorted_idx2 = np.argsort(objectives[:, 1])\n        crowding = np.zeros(len(archive))\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx1[i]] += (objectives[sorted_idx1[i+1], 0] - objectives[sorted_idx1[i-1], 0])\n            crowding[sorted_idx2[i]] += (objectives[sorted_idx2[i+1], 1] - objectives[sorted_idx2[i-1], 1])\n\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 2: Multi-space segment inversion and relocation\n    # Select a segment and invert it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate potential improvement in both spaces\n    prev_node = new_solution[start-1]\n    next_node = new_solution[(end+1)%n]\n\n    old_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                 distance_matrix_1[segment[-1], next_node])\n    old_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                 distance_matrix_2[segment[-1], next_node])\n\n    new_cost1 = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                 distance_matrix_1[inverted_segment[-1], next_node])\n    new_cost2 = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                 distance_matrix_2[inverted_segment[-1], next_node])\n\n    improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n    if improvement < 0:\n        new_solution[start:end+1] = inverted_segment\n\n    # Relocate the segment to a new position\n    if random.random() < 0.5:\n        new_pos = random.randint(0, n - 1)\n        if new_pos < start:\n            relocated_segment = np.concatenate([new_solution[new_pos:start], inverted_segment, new_solution[start:end+1], new_solution[end+1:]])\n        else:\n            relocated_segment = np.concatenate([new_solution[:start], new_solution[end+1:new_pos+1], inverted_segment, new_solution[new_pos+1:]])\n        new_solution = relocated_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8304565625226996,
            1.2743691802024841
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Step 1: Select solution with highest crowding distance in objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance\n        sorted_idx1 = np.argsort(objectives[:, 0])\n        sorted_idx2 = np.argsort(objectives[:, 1])\n        crowding = np.zeros(len(archive))\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx1[i]] += (objectives[sorted_idx1[i+1], 0] - objectives[sorted_idx1[i-1], 0])\n            crowding[sorted_idx2[i]] += (objectives[sorted_idx2[i+1], 1] - objectives[sorted_idx2[i-1], 1])\n\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 2: Multi-space segment inversion and relocation\n    # Select a segment and invert it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate potential improvement in both spaces\n    prev_node = new_solution[start-1]\n    next_node = new_solution[(end+1)%n]\n\n    old_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                 distance_matrix_1[segment[-1], next_node])\n    old_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                 distance_matrix_2[segment[-1], next_node])\n\n    new_cost1 = (distance_matrix_1[prev_node, inverted_segment[0]] +\n                 distance_matrix_1[inverted_segment[-1], next_node])\n    new_cost2 = (distance_matrix_2[prev_node, inverted_segment[0]] +\n                 distance_matrix_2[inverted_segment[-1], next_node])\n\n    improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n    if improvement < 0:\n        new_solution[start:end+1] = inverted_segment\n\n    # Relocate the segment to a new position\n    if random.random() < 0.5:\n        new_pos = random.randint(0, n - 1)\n        if new_pos < start:\n            relocated_segment = np.concatenate([new_solution[new_pos:start], inverted_segment, new_solution[start:end+1], new_solution[end+1:]])\n        else:\n            relocated_segment = np.concatenate([new_solution[:start], new_solution[end+1:new_pos+1], inverted_segment, new_solution[new_pos+1:]])\n        new_solution = relocated_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"cross-space segment inversion\" local search that reverses segments of the tour in one objective space while preserving feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_i, segment[0]] + distance_matrix_1[segment[-1], next_j]\n        new_cost1 = distance_matrix_1[prev_i, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_j]\n\n        old_cost2 = distance_matrix_2[prev_i, segment[0]] + distance_matrix_2[segment[-1], next_j]\n        new_cost2 = distance_matrix_2[prev_i, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            new_solution = base_solution.copy()\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5916079851335968,
            0.8757529258728027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_i, segment[0]] + distance_matrix_1[segment[-1], next_j]\n        new_cost1 = distance_matrix_1[prev_i, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_j]\n\n        old_cost2 = distance_matrix_2[prev_i, segment[0]] + distance_matrix_2[segment[-1], next_j]\n        new_cost2 = distance_matrix_2[prev_i, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            new_solution = base_solution.copy()\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective diversity, then applies a \"multi-segment inversion\" local search that intelligently inverts multiple non-adjacent segments of the tour while ensuring feasibility through careful segment boundary validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective diversity\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Determine number of segments to invert (2-3 segments)\n        num_segments = random.randint(2, min(3, n//2))\n\n        # Generate random segment boundaries\n        boundaries = sorted(random.sample(range(1, n), num_segments - 1))\n        segments = []\n        prev = 0\n        for b in boundaries + [n]:\n            segments.append(new_solution[prev:b])\n            prev = b\n\n        # Invert segments in random order\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Validate and repair if necessary\n        if len(set(new_solution)) != n:\n            # If invalid, revert to base solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5531141706926652,
            0.7417817115783691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective diversity\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Determine number of segments to invert (2-3 segments)\n        num_segments = random.randint(2, min(3, n//2))\n\n        # Generate random segment boundaries\n        boundaries = sorted(random.sample(range(1, n), num_segments - 1))\n        segments = []\n        prev = 0\n        for b in boundaries + [n]:\n            segments.append(new_solution[prev:b])\n            prev = b\n\n        # Invert segments in random order\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Validate and repair if necessary\n        if len(set(new_solution)) != n:\n            # If invalid, revert to base solution\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment inversion\" local search that reverses segments of the tour in both objective spaces simultaneously while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))  # Limit segment length to 5 for efficiency\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        segment = new_solution[start:end+1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8591448970585098,
            0.4322932958602905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))  # Limit segment length to 5 for efficiency\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        segment = new_solution[start:end+1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{The heuristic function 'select_neighbor' selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search that combines node relocation and path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Relocate a randomly selected node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Reverse a random segment to explore different paths\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9132768534080151,
            0.487194299697876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Relocate a randomly selected node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Reverse a random segment to explore different paths\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a \"cross-segment inversion\" local search that inverts segments of the tour between two randomly chosen nodes while ensuring feasibility through careful boundary handling and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [(abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-segment inversion\n    if n > 2:\n        # Select two distinct nodes\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Invert the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, base_solution[i]] +\n                     distance_matrix_1[base_solution[j], next_j])\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, base_solution[i]] +\n                     distance_matrix_2[base_solution[j], next_j])\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6920429609439387,
            2.323086977005005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [(abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-segment inversion\n    if n > 2:\n        # Select two distinct nodes\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Invert the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, base_solution[i]] +\n                     distance_matrix_1[base_solution[j], next_j])\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, base_solution[i]] +\n                     distance_matrix_2[base_solution[j], next_j])\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on the most promising trade-off between objectives, then applies a hybrid local search combining edge swaps and segment reversals to explore non-dominated regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate normalized objectives for selection\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n        scores = normalized[:, 0] - normalized[:, 1]  # Simple trade-off metric\n        selected_idx = np.argmin(scores)  # Prefer solutions with better balance\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: edge swap + segment reversal\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Edge swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment reversal with probability\n    if random.random() < 0.5:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7842173825496027,
            0.26515668630599976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate normalized objectives for selection\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n        scores = normalized[:, 0] - normalized[:, 1]  # Simple trade-off metric\n        selected_idx = np.argmin(scores)  # Prefer solutions with better balance\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: edge swap + segment reversal\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Edge swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment reversal with probability\n    if random.random() < 0.5:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies an \"objective-balanced node insertion\" local search that intelligently reinserts nodes to balance improvements across both objectives while maintaining feasibility through careful validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-balanced node insertion\n    if n > 2:\n        # Select a node to reinsert\n        k = random.randint(0, n-1)\n        removed_node = new_solution[k]\n        temp_solution = np.delete(new_solution, k)\n\n        # Find best insertion position to balance objectives\n        best_pos = -1\n        best_balance = float('inf')\n\n        for i in range(n-1):\n            # Insert node at position i\n            candidate = np.insert(temp_solution, i, removed_node)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[j+1]] for j in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[j+1]] for j in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Balance metric: minimize the difference between normalized costs\n            balance = abs((cost1 - mean_obj1) / mean_obj1) + abs((cost2 - mean_obj2) / mean_obj2)\n\n            if balance < best_balance:\n                best_balance = balance\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(temp_solution, best_pos, removed_node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8794619700324886,
            1.172348141670227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-balanced node insertion\n    if n > 2:\n        # Select a node to reinsert\n        k = random.randint(0, n-1)\n        removed_node = new_solution[k]\n        temp_solution = np.delete(new_solution, k)\n\n        # Find best insertion position to balance objectives\n        best_pos = -1\n        best_balance = float('inf')\n\n        for i in range(n-1):\n            # Insert node at position i\n            candidate = np.insert(temp_solution, i, removed_node)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[j+1]] for j in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[j+1]] for j in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Balance metric: minimize the difference between normalized costs\n            balance = abs((cost1 - mean_obj1) / mean_obj1) + abs((cost2 - mean_obj2) / mean_obj2)\n\n            if balance < best_balance:\n                best_balance = balance\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.insert(temp_solution, best_pos, removed_node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{The new heuristic function intelligently selects a solution from the archive based on a combination of objective values and solution diversity, then applies a hybrid local search combining segment reversal and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Calculate diversity score (distance to other solutions)\n        diversity = sum(np.sum(np.abs(sol - other_sol[0])) for other_sol in archive)\n        # Combine with objective values (normalized)\n        score = (obj[0] + obj[1]) / diversity if diversity > 0 else float('inf')\n        scores.append(score)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a randomly selected node\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_pos = random.randint(0, n - 2)\n    if new_pos >= node_idx:\n        new_pos += 1\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8958974089076348,
            2.873855173587799
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Calculate diversity score (distance to other solutions)\n        diversity = sum(np.sum(np.abs(sol - other_sol[0])) for other_sol in archive)\n        # Combine with objective values (normalized)\n        score = (obj[0] + obj[1]) / diversity if diversity > 0 else float('inf')\n        scores.append(score)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a randomly selected node\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_pos = random.randint(0, n - 2)\n    if new_pos >= node_idx:\n        new_pos += 1\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel \"segment inversion and reinsertion\" local search that inverts a random segment of nodes and reinserts it at a different position, while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective score\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    combined_scores = [(obj[0]/max_obj1) + (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Segment inversion and reinsertion\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n\n    # Remove segment from original position\n    temp_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Insert inverted segment at a new random position\n    insert_pos = random.randint(0, len(temp_solution))\n    new_solution = np.concatenate([temp_solution[:insert_pos], inverted_segment, temp_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9072183699051559,
            1.0772112011909485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective score\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    combined_scores = [(obj[0]/max_obj1) + (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Segment inversion and reinsertion\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    inverted_segment = segment[::-1]\n\n    # Remove segment from original position\n    temp_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Insert inverted segment at a new random position\n    insert_pos = random.randint(0, len(temp_solution))\n    new_solution = np.concatenate([temp_solution[:insert_pos], inverted_segment, temp_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{The heuristic function selects a solution from the archive, applies a novel local search operator that combines node swapping and segment inversion to explore non-dominated regions, ensuring feasibility by validating the neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7806737780597139,
            0.4941924810409546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Invert a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment reversal\" local search that intelligently reverses segments of nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_i, segment[0]] + distance_matrix_1[segment[-1], next_j]\n        new_cost1 = distance_matrix_1[prev_i, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_j]\n\n        old_cost2 = distance_matrix_2[prev_i, segment[0]] + distance_matrix_2[segment[-1], next_j]\n        new_cost2 = distance_matrix_2[prev_i, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            new_solution[i:j+1] = segment\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9744768492830328,
            0.8588535785675049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_i, segment[0]] + distance_matrix_1[segment[-1], next_j]\n        new_cost1 = distance_matrix_1[prev_i, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_j]\n\n        old_cost2 = distance_matrix_2[prev_i, segment[0]] + distance_matrix_2[segment[-1], next_j]\n        new_cost2 = distance_matrix_2[prev_i, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            new_solution[i:j+1] = segment\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of crowding distance and objective value diversity, then applies a hybrid local search that combines adaptive segment reversal and cross-space node relocation to explore non-dominated regions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with high crowding distance and diverse objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [(obj[0]/max_obj1) * (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Cross-space node relocation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                    distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n        new_cost = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                    distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j])\n\n        if new_cost < old_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9048799409659734,
            0.7957767248153687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with high crowding distance and diverse objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [(obj[0]/max_obj1) * (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Cross-space node relocation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i:\n            j = random.randint(0, n-1)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                    distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n        new_cost = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                    distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j])\n\n        if new_cost < old_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This new algorithm selects a solution from the archive, applies a hybrid local search combining segment reversal and node swapping, ensuring feasibility by validating the neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8658759006232241,
            0.2811843752861023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This heuristic selects a solution from the archive using a diversity-aware selection strategy, then applies a novel \"segment inversion and cross-space node reinsertion\" local search that combines segment inversion with intelligent node reinsertion across both objective spaces while maintaining feasibility through careful validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Diversity-aware selection\n    objectives = [obj for _, obj in archive]\n    if len(archive) > 1:\n        # Select solution with highest crowding distance in objective space\n        crowding_distances = []\n        for i in range(len(archive)):\n            left = max(0, i-1)\n            right = min(len(archive)-1, i+1)\n            dist = (objectives[right][0] - objectives[left][0]) + (objectives[right][1] - objectives[left][1])\n            crowding_distances.append(dist)\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Select a node and reinsert it at a new position considering both objective spaces\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n\n    # Find best insertion position considering both objectives\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(n - 1):\n        candidate = np.insert(new_solution, pos, node)\n        cost1 = 0\n        cost2 = 0\n        for i in range(n):\n            prev = candidate[i-1]\n            curr = candidate[i]\n            cost1 += distance_matrix_1[prev, curr]\n            cost2 += distance_matrix_2[prev, curr]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7036403763190064,
            1.112618863582611
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Diversity-aware selection\n    objectives = [obj for _, obj in archive]\n    if len(archive) > 1:\n        # Select solution with highest crowding distance in objective space\n        crowding_distances = []\n        for i in range(len(archive)):\n            left = max(0, i-1)\n            right = min(len(archive)-1, i+1)\n            dist = (objectives[right][0] - objectives[left][0]) + (objectives[right][1] - objectives[left][1])\n            crowding_distances.append(dist)\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and invert it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Select a node and reinsert it at a new position considering both objective spaces\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n\n    # Find best insertion position considering both objectives\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(n - 1):\n        candidate = np.insert(new_solution, pos, node)\n        cost1 = 0\n        cost2 = 0\n        for i in range(n):\n            prev = candidate[i-1]\n            curr = candidate[i]\n            cost1 += distance_matrix_1[prev, curr]\n            cost2 += distance_matrix_2[prev, curr]\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This new heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"segment reversal with cross-space validation\" local search that reverses a random segment of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with cross-space validation\n    if n > 2:\n        # Select a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_i, segment[0]] + distance_matrix_1[segment[-1], next_j]\n        new_cost1 = distance_matrix_1[prev_i, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_j]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_i, segment[0]] + distance_matrix_2[segment[-1], next_j]\n        new_cost2 = distance_matrix_2[prev_i, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[i:j+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7154840660769732,
            0.5342447757720947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with cross-space validation\n    if n > 2:\n        # Select a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_i, segment[0]] + distance_matrix_1[segment[-1], next_j]\n        new_cost1 = distance_matrix_1[prev_i, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_j]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_i, segment[0]] + distance_matrix_2[segment[-1], next_j]\n        new_cost2 = distance_matrix_2[prev_i, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[i:j+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment inversion\" local search that reverses segments of the tour in one objective space while carefully optimizing the other space's cost through intelligent segment selection and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment to invert\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n\n        # Calculate potential improvement\n        prev = new_solution[start-1]\n        next_ = new_solution[(end+1)%n]\n\n        old_cost1 = (distance_matrix_1[prev, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_])\n        new_cost1 = (distance_matrix_1[prev, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_])\n\n        old_cost2 = (distance_matrix_2[prev, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_])\n        new_cost2 = (distance_matrix_2[prev, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9602163834341116,
            0.3172069787979126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment to invert\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n\n        # Calculate potential improvement\n        prev = new_solution[start-1]\n        next_ = new_solution[(end+1)%n]\n\n        old_cost1 = (distance_matrix_1[prev, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_])\n        new_cost1 = (distance_matrix_1[prev, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_])\n\n        old_cost2 = (distance_matrix_2[prev, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_])\n        new_cost2 = (distance_matrix_2[prev, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search operator that combines edge swapping with a novel segment reversal strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high dominance and diversity\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: edge swap + segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge swap\n    if j + 1 < n:\n        new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8440586623564779,
            0.434128999710083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high dominance and diversity\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: edge swap + segment reversal\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge swap\n    if j + 1 < n:\n        new_solution[j], new_solution[j+1] = new_solution[j+1], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity (measured by the number of unique segments in both objective spaces) and applies a \"cross-space segment inversion\" local search that inverts a random segment of nodes while considering the combined impact on both objectives, ensuring feasibility through a repair mechanism that maintains tour continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (unique segments in both spaces)\n    diversity_scores = []\n    for sol, _ in archive:\n        n = len(sol)\n        unique_segments1 = set()\n        unique_segments2 = set()\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            seg1 = (prev, curr, next_node)\n            seg2 = (distance_matrix_1[prev, curr], distance_matrix_1[curr, next_node])\n            unique_segments1.add(seg1)\n            unique_segments2.add(seg2)\n        diversity_scores.append(len(unique_segments1) + len(unique_segments2))\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start = random.randint(0, n-1)\n        length = random.randint(2, min(5, n//2))\n        end = (start + length) % n\n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            segment = segment[::-1]\n            new_solution[start:] = segment[:n-start]\n            new_solution[:end] = segment[n-start:]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[end%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end%n-1], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end%n-1]] + distance_matrix_1[new_solution[start], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end%n-1], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end%n-1]] + distance_matrix_2[new_solution[start], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            if start < end:\n                new_solution[start:end] = new_solution[start:end][::-1]\n            else:\n                segment = np.concatenate([new_solution[start:], new_solution[:end]])\n                segment = segment[::-1]\n                new_solution[start:] = segment[:n-start]\n                new_solution[:end] = segment[n-start:]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9692136689572677,
            3.8560327291488647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (unique segments in both spaces)\n    diversity_scores = []\n    for sol, _ in archive:\n        n = len(sol)\n        unique_segments1 = set()\n        unique_segments2 = set()\n        for i in range(n):\n            prev = sol[i-1]\n            curr = sol[i]\n            next_node = sol[(i+1)%n]\n            seg1 = (prev, curr, next_node)\n            seg2 = (distance_matrix_1[prev, curr], distance_matrix_1[curr, next_node])\n            unique_segments1.add(seg1)\n            unique_segments2.add(seg2)\n        diversity_scores.append(len(unique_segments1) + len(unique_segments2))\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start = random.randint(0, n-1)\n        length = random.randint(2, min(5, n//2))\n        end = (start + length) % n\n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            segment = segment[::-1]\n            new_solution[start:] = segment[:n-start]\n            new_solution[:end] = segment[n-start:]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[end%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end%n-1], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end%n-1]] + distance_matrix_1[new_solution[start], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end%n-1], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end%n-1]] + distance_matrix_2[new_solution[start], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            if start < end:\n                new_solution[start:end] = new_solution[start:end][::-1]\n            else:\n                segment = np.concatenate([new_solution[start:], new_solution[:end]])\n                segment = segment[::-1]\n                new_solution[start:] = segment[:n-start]\n                new_solution[:end] = segment[n-start:]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{The new algorithm intelligently selects a non-dominated solution from the archive, applies a hybrid local search combining edge reversal and node relocation, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, len(non_dominated) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9724004264099676,
            0.27439045906066895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = random.randint(0, len(non_dominated) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment inversion\" local search that inverts segments of the tour in both objective spaces simultaneously while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n        end = start + segment_length\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[end%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end-1], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end-1]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end-1], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end-1]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9474347742806005,
            0.3913571834564209
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n        end = start + segment_length\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[end%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end-1], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end-1]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end-1], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end-1]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This heuristic selects solutions from the archive based on their diversity and applies a \"multi-segment inversion\" local search that reverses segments of the tour while considering both objective spaces to create diverse, high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (most different objective values)\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [(abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        def calculate_cost(sol, mat1, mat2):\n            cost1 = sum(mat1[sol[i], sol[i+1]] for i in range(n-1)) + mat1[sol[-1], sol[0]]\n            cost2 = sum(mat2[sol[i], sol[i+1]] for i in range(n-1)) + mat2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        old_cost = calculate_cost(new_solution, distance_matrix_1, distance_matrix_2)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b] = candidate[a:b][::-1]\n        candidate[c:d] = candidate[c:d][::-1]\n\n        new_cost = calculate_cost(candidate, distance_matrix_1, distance_matrix_2)\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6391593112473843,
            1.3386036157608032
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (most different objective values)\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [(abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        def calculate_cost(sol, mat1, mat2):\n            cost1 = sum(mat1[sol[i], sol[i+1]] for i in range(n-1)) + mat1[sol[-1], sol[0]]\n            cost2 = sum(mat2[sol[i], sol[i+1]] for i in range(n-1)) + mat2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        old_cost = calculate_cost(new_solution, distance_matrix_1, distance_matrix_2)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b] = candidate[a:b][::-1]\n        candidate[c:d] = candidate[c:d][::-1]\n\n        new_cost = calculate_cost(candidate, distance_matrix_1, distance_matrix_2)\n\n        if new_cost < old_cost:\n            new_solution = candidate\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{The new algorithm intelligently selects a non-dominated solution from the archive, applies a hybrid local search operator combining segment reversal and node relocation to explore diverse regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol, obj in archive if all(obj[0] <= other_obj[0] and obj[1] <= other_obj[1] for _, other_obj in archive)]\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = archive[random.randint(0, len(archive) - 1)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a randomly selected node\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9608695131883401,
            0.4534282088279724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol, obj in archive if all(obj[0] <= other_obj[0] and obj[1] <= other_obj[1] for _, other_obj in archive)]\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = archive[random.randint(0, len(archive) - 1)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a randomly selected node\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest diversity in their tour structure, then applies a \"segment inversion with cross-space validation\" local search that inverts a random segment of the tour while ensuring feasibility and checking for improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (longest unique segments)\n    def calculate_diversity(sol):\n        segments = []\n        for i in range(len(sol)):\n            seg = tuple(sorted((sol[i], sol[(i+1)%len(sol)])))\n            segments.append(seg)\n        return len(set(segments))\n\n    diversities = [calculate_diversity(sol) for sol, _ in archive]\n    selected_idx = np.argmax(diversities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 3:\n        # Select random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate old cost for both objectives\n        old_cost1 = 0\n        old_cost2 = 0\n        for i in range(n):\n            j = (i+1)%n\n            old_cost1 += distance_matrix_1[new_solution[i], new_solution[j]]\n            old_cost2 += distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Create inverted segment\n        inverted_segment = new_solution[start:end+1][::-1]\n        new_solution[start:end+1] = inverted_segment\n\n        # Calculate new cost for both objectives\n        new_cost1 = 0\n        new_cost2 = 0\n        for i in range(n):\n            j = (i+1)%n\n            new_cost1 += distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 += distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Revert if no improvement in either objective\n        if new_cost1 >= old_cost1 and new_cost2 >= old_cost2:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8170905232128227,
            3.11192923784256
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (longest unique segments)\n    def calculate_diversity(sol):\n        segments = []\n        for i in range(len(sol)):\n            seg = tuple(sorted((sol[i], sol[(i+1)%len(sol)])))\n            segments.append(seg)\n        return len(set(segments))\n\n    diversities = [calculate_diversity(sol) for sol, _ in archive]\n    selected_idx = np.argmax(diversities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 3:\n        # Select random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate old cost for both objectives\n        old_cost1 = 0\n        old_cost2 = 0\n        for i in range(n):\n            j = (i+1)%n\n            old_cost1 += distance_matrix_1[new_solution[i], new_solution[j]]\n            old_cost2 += distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Create inverted segment\n        inverted_segment = new_solution[start:end+1][::-1]\n        new_solution[start:end+1] = inverted_segment\n\n        # Calculate new cost for both objectives\n        new_cost1 = 0\n        new_cost2 = 0\n        for i in range(n):\n            j = (i+1)%n\n            new_cost1 += distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 += distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Revert if no improvement in either objective\n        if new_cost1 >= old_cost1 and new_cost2 >= old_cost2:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a novel \"cross-space segment inversion\" local search that reverses segments of the tour while considering the impact on both objective spaces, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    # Sort objectives\n    sorted_idx1 = np.argsort(obj1)\n    sorted_idx2 = np.argsort(obj2)\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (obj1[sorted_idx1[i+1]] - obj1[sorted_idx1[i-1]]) + (obj2[sorted_idx2[i+1]] - obj2[sorted_idx2[i-1]])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        prev_segment = segment[0]\n        next_segment = segment[-1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end] +\n                     distance_matrix_1[prev_segment, segment[1]] +\n                     distance_matrix_1[segment[-2], next_segment])\n\n        new_cost1 = (distance_matrix_1[prev_start, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_end] +\n                     distance_matrix_1[inverted_segment[0], inverted_segment[1]] +\n                     distance_matrix_1[inverted_segment[-2], inverted_segment[-1]])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end] +\n                     distance_matrix_2[prev_segment, segment[1]] +\n                     distance_matrix_2[segment[-2], next_segment])\n\n        new_cost2 = (distance_matrix_2[prev_start, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_end] +\n                     distance_matrix_2[inverted_segment[0], inverted_segment[1]] +\n                     distance_matrix_2[inverted_segment[-2], inverted_segment[-1]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9288016928722049,
            0.8604183793067932
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distances for each solution\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    # Sort objectives\n    sorted_idx1 = np.argsort(obj1)\n    sorted_idx2 = np.argsort(obj2)\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (obj1[sorted_idx1[i+1]] - obj1[sorted_idx1[i-1]]) + (obj2[sorted_idx2[i+1]] - obj2[sorted_idx2[i-1]])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        prev_segment = segment[0]\n        next_segment = segment[-1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end] +\n                     distance_matrix_1[prev_segment, segment[1]] +\n                     distance_matrix_1[segment[-2], next_segment])\n\n        new_cost1 = (distance_matrix_1[prev_start, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_end] +\n                     distance_matrix_1[inverted_segment[0], inverted_segment[1]] +\n                     distance_matrix_1[inverted_segment[-2], inverted_segment[-1]])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end] +\n                     distance_matrix_2[prev_segment, segment[1]] +\n                     distance_matrix_2[segment[-2], next_segment])\n\n        new_cost2 = (distance_matrix_2[prev_start, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_end] +\n                     distance_matrix_2[inverted_segment[0], inverted_segment[1]] +\n                     distance_matrix_2[inverted_segment[-2], inverted_segment[-1]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment inversion\" local search that intelligently inverts segments of the tour in both objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n\n        prev_a = new_solution[a-1]\n        next_b = new_solution[(b+1)%n]\n        old_cost1 = distance_matrix_1[prev_a, segment[0]] + distance_matrix_1[segment[-1], next_b]\n        new_cost1 = distance_matrix_1[prev_a, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_b]\n\n        old_cost2 = distance_matrix_2[prev_a, segment[0]] + distance_matrix_2[segment[-1], next_b]\n        new_cost2 = distance_matrix_2[prev_a, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_b]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            new_solution[a:b+1] = inverted_segment\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8445633995050925,
            0.8252469897270203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n\n        prev_a = new_solution[a-1]\n        next_b = new_solution[(b+1)%n]\n        old_cost1 = distance_matrix_1[prev_a, segment[0]] + distance_matrix_1[segment[-1], next_b]\n        new_cost1 = distance_matrix_1[prev_a, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_b]\n\n        old_cost2 = distance_matrix_2[prev_a, segment[0]] + distance_matrix_2[segment[-1], next_b]\n        new_cost2 = distance_matrix_2[prev_a, inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], next_b]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            new_solution[a:b+1] = inverted_segment\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a \"multi-space segment reversal\" local search that intelligently reverses segments of the tour in both objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    diversity_scores = [(max(obj1_values) - min(obj1_values)) + (max(obj2_values) - min(obj2_values)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-space segment reversal\n    if n > 3:\n        # Select segment to reverse\n        start = random.randint(0, n-2)\n        length = random.randint(2, min(5, n-start))\n        end = start + length\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[end%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end-1], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end-1]] + distance_matrix_1[new_solution[start], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end-1], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end-1]] + distance_matrix_2[new_solution[start], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment reversal if it improves the solution\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9087226400318487,
            3.024566411972046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    diversity_scores = [(max(obj1_values) - min(obj1_values)) + (max(obj2_values) - min(obj2_values)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-space segment reversal\n    if n > 3:\n        # Select segment to reverse\n        start = random.randint(0, n-2)\n        length = random.randint(2, min(5, n-start))\n        end = start + length\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[end%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end-1], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end-1]] + distance_matrix_1[new_solution[start], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end-1], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end-1]] + distance_matrix_2[new_solution[start], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment reversal if it improves the solution\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"multi-swap\" local search that intelligently exchanges multiple nodes between segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distance for each solution\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    sorted_indices1 = np.argsort(obj1_values)\n    sorted_indices2 = np.argsort(obj2_values)\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        # Find neighbors in sorted order\n        idx1 = np.where(sorted_indices1 == i)[0][0]\n        idx2 = np.where(sorted_indices2 == i)[0][0]\n\n        # Calculate crowding distance\n        if idx1 == 0 or idx1 == len(archive)-1:\n            dist1 = float('inf')\n        else:\n            dist1 = obj1_values[sorted_indices1[idx1+1]] - obj1_values[sorted_indices1[idx1-1]]\n\n        if idx2 == 0 or idx2 == len(archive)-1:\n            dist2 = float('inf')\n        else:\n            dist2 = obj2_values[sorted_indices2[idx2+1]] - obj2_values[sorted_indices2[idx2-1]]\n\n        crowding_distances[i] = dist1 + dist2\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-swap local search\n    if n > 3:\n        # Select a segment and swap multiple nodes\n        start = random.randint(0, n-3)\n        length = random.randint(2, min(5, n-start-1))\n\n        segment1 = new_solution[start:start+length]\n        segment2 = new_solution[start+length:start+2*length]\n\n        if len(segment2) == len(segment1):\n            new_solution[start:start+length] = segment2\n            new_solution[start+length:start+2*length] = segment1\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9568945240255354,
            7.470791220664978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distance for each solution\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    sorted_indices1 = np.argsort(obj1_values)\n    sorted_indices2 = np.argsort(obj2_values)\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        # Find neighbors in sorted order\n        idx1 = np.where(sorted_indices1 == i)[0][0]\n        idx2 = np.where(sorted_indices2 == i)[0][0]\n\n        # Calculate crowding distance\n        if idx1 == 0 or idx1 == len(archive)-1:\n            dist1 = float('inf')\n        else:\n            dist1 = obj1_values[sorted_indices1[idx1+1]] - obj1_values[sorted_indices1[idx1-1]]\n\n        if idx2 == 0 or idx2 == len(archive)-1:\n            dist2 = float('inf')\n        else:\n            dist2 = obj2_values[sorted_indices2[idx2+1]] - obj2_values[sorted_indices2[idx2-1]]\n\n        crowding_distances[i] = dist1 + dist2\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-swap local search\n    if n > 3:\n        # Select a segment and swap multiple nodes\n        start = random.randint(0, n-3)\n        length = random.randint(2, min(5, n-start-1))\n\n        segment1 = new_solution[start:start+length]\n        segment2 = new_solution[start+length:start+2*length]\n\n        if len(segment2) == len(segment1):\n            new_solution[start:start+length] = segment2\n            new_solution[start+length:start+2*length] = segment1\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a \"segment inversion\" local search that reverses a random segment of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    std_obj1 = np.std([obj[0] for obj in objectives])\n    std_obj2 = np.std([obj[1] for obj in objectives])\n    diversity_scores = [(obj[0]/std_obj1) + (obj[1]/std_obj2) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9522582686165456,
            0.8677204847335815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    std_obj1 = np.std([obj[0] for obj in objectives])\n    std_obj2 = np.std([obj[1] for obj in objectives])\n    diversity_scores = [(obj[0]/std_obj1) + (obj[1]/std_obj2) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This heuristic selects a solution from the archive based on its crowding distance in the objective space, then applies a \"segment inversion with adaptive length\" local search that inverts segments of varying lengths while ensuring feasibility through careful boundary checks and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distances for each solution in the archive\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(archive)):\n        obj1 = objectives[i][0]\n        obj2 = objectives[i][1]\n\n        # Find neighbors in objective space\n        idx1 = [j for j, x in enumerate(sorted_obj1) if x[0] == obj1][0]\n        idx2 = [j for j, x in enumerate(sorted_obj2) if x[1] == obj2][0]\n\n        # Calculate crowding distance\n        if idx1 == 0 or idx1 == len(sorted_obj1) - 1:\n            dist1 = float('inf')\n        else:\n            dist1 = sorted_obj1[idx1+1][0] - sorted_obj1[idx1-1][0]\n\n        if idx2 == 0 or idx2 == len(sorted_obj2) - 1:\n            dist2 = float('inf')\n        else:\n            dist2 = sorted_obj2[idx2+1][1] - sorted_obj2[idx2-1][1]\n\n        crowding_distances.append(dist1 + dist2)\n\n    # Select solution with maximum crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Adaptive segment inversion\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length - 1\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6230886550929758,
            3.340602457523346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distances for each solution in the archive\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(archive)):\n        obj1 = objectives[i][0]\n        obj2 = objectives[i][1]\n\n        # Find neighbors in objective space\n        idx1 = [j for j, x in enumerate(sorted_obj1) if x[0] == obj1][0]\n        idx2 = [j for j, x in enumerate(sorted_obj2) if x[1] == obj2][0]\n\n        # Calculate crowding distance\n        if idx1 == 0 or idx1 == len(sorted_obj1) - 1:\n            dist1 = float('inf')\n        else:\n            dist1 = sorted_obj1[idx1+1][0] - sorted_obj1[idx1-1][0]\n\n        if idx2 == 0 or idx2 == len(sorted_obj2) - 1:\n            dist2 = float('inf')\n        else:\n            dist2 = sorted_obj2[idx2+1][1] - sorted_obj2[idx2-1][1]\n\n        crowding_distances.append(dist1 + dist2)\n\n    # Select solution with maximum crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Adaptive segment inversion\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length - 1\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment relocation\" local search that intelligently moves segments of the tour between different objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n        pos = random.randint(0, len(remaining)-1)\n        new_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n        prev_a = new_solution[a-1] if a > 0 else new_solution[-1]\n        next_b = new_solution[b] if b < n-1 else new_solution[0]\n        prev_pos = remaining[pos-1] if pos > 0 else remaining[-1]\n        next_pos = remaining[pos] if pos < len(remaining) else remaining[0]\n\n        old_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                     distance_matrix_1[new_solution[b-1], next_b])\n        new_cost1 = (distance_matrix_1[prev_a, segment[0]] +\n                     distance_matrix_1[segment[-1], next_b] +\n                     distance_matrix_1[prev_pos, segment[0]] +\n                     distance_matrix_1[segment[-1], next_pos])\n\n        old_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], next_b])\n        new_cost2 = (distance_matrix_2[prev_a, segment[0]] +\n                     distance_matrix_2[segment[-1], next_b] +\n                     distance_matrix_2[prev_pos, segment[0]] +\n                     distance_matrix_2[segment[-1], next_pos])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            new_solution = base_solution.copy()\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9693029894840656,
            1.0360539555549622
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n        pos = random.randint(0, len(remaining)-1)\n        new_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n        prev_a = new_solution[a-1] if a > 0 else new_solution[-1]\n        next_b = new_solution[b] if b < n-1 else new_solution[0]\n        prev_pos = remaining[pos-1] if pos > 0 else remaining[-1]\n        next_pos = remaining[pos] if pos < len(remaining) else remaining[0]\n\n        old_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                     distance_matrix_1[new_solution[b-1], next_b])\n        new_cost1 = (distance_matrix_1[prev_a, segment[0]] +\n                     distance_matrix_1[segment[-1], next_b] +\n                     distance_matrix_1[prev_pos, segment[0]] +\n                     distance_matrix_1[segment[-1], next_pos])\n\n        old_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], next_b])\n        new_cost2 = (distance_matrix_2[prev_a, segment[0]] +\n                     distance_matrix_2[segment[-1], next_b] +\n                     distance_matrix_2[prev_pos, segment[0]] +\n                     distance_matrix_2[segment[-1], next_pos])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            new_solution = base_solution.copy()\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a hybrid score combining objective values and diversity, then applies a combination of node relocation and segment reversal to explore non-dominated regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [sum(obj) * (1 + 0.1 * np.random.rand()) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: node relocation with segment reversal\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Relocate segment [i:j] to a new position\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Reverse a random segment\n    rev_start = random.randint(0, n - 2)\n    rev_end = random.randint(rev_start + 1, n - 1)\n    new_solution[rev_start:rev_end+1] = new_solution[rev_start:rev_end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9488839905393751,
            0.8086584806442261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [sum(obj) * (1 + 0.1 * np.random.rand()) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: node relocation with segment reversal\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Relocate segment [i:j] to a new position\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Reverse a random segment\n    rev_start = random.randint(0, n - 2)\n    rev_end = random.randint(rev_start + 1, n - 1)\n    new_solution[rev_start:rev_end+1] = new_solution[rev_start:rev_end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This heuristic selects a solution from the archive based on its dominance score (number of solutions it dominates) and applies a \"cross-space segment inversion\" local search that reverses segments of the tour while considering the impact on both objective spaces to potentially improve both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest dominance score\n    dominance_scores = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = 0\n        for j, (_, obj_j) in enumerate(archive):\n            if i != j and (obj_i[0] >= obj_j[0] and obj_i[1] >= obj_j[1] and (obj_i[0] > obj_j[0] or obj_i[1] > obj_j[1])):\n                dominated += 1\n        dominance_scores.append(dominated)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[segment[-1], new_solution[(start+1)%n]]\n        new_cost1 = distance_matrix_1[prev_start, segment[0]] + distance_matrix_1[new_solution[(end)%n], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[segment[-1], new_solution[(start+1)%n]]\n        new_cost2 = distance_matrix_2[prev_start, segment[0]] + distance_matrix_2[new_solution[(end)%n], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:end+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8983822228043642,
            4.0163832902908325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest dominance score\n    dominance_scores = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = 0\n        for j, (_, obj_j) in enumerate(archive):\n            if i != j and (obj_i[0] >= obj_j[0] and obj_i[1] >= obj_j[1] and (obj_i[0] > obj_j[0] or obj_i[1] > obj_j[1])):\n                dominated += 1\n        dominance_scores.append(dominated)\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[segment[-1], new_solution[(start+1)%n]]\n        new_cost1 = distance_matrix_1[prev_start, segment[0]] + distance_matrix_1[new_solution[(end)%n], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[segment[-1], new_solution[(start+1)%n]]\n        new_cost2 = distance_matrix_2[prev_start, segment[0]] + distance_matrix_2[new_solution[(end)%n], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:end+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a combination of solution quality and diversity, then applies a hybrid local search operator that combines edge swapping and node reinsertion to explore the solution space while ensuring feasibility through careful validation of the generated neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    inverse_weights = 1.0 / (normalized_obj + 1e-10)\n    selection_prob = inverse_weights[:, 0] * inverse_weights[:, 1]\n    selection_prob = selection_prob / selection_prob.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Edge swapping\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8524349076675903,
            1.263777256011963
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    inverse_weights = 1.0 / (normalized_obj + 1e-10)\n    selection_prob = inverse_weights[:, 0] * inverse_weights[:, 1]\n    selection_prob = selection_prob / selection_prob.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Edge swapping\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node reinsertion\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-segment insertion\" local search that intelligently moves segments of nodes between different positions in the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-segment_length-1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8463172598979742,
            1.0829752087593079
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-segment_length-1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This heuristic selects a solution from the archive based on its dominance count and applies a \"multi-segment inversion with cross-space validation\" local search that reverses multiple segments while considering both objective spaces, ensuring feasibility through dominance-based repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest dominance count (simplified for this example)\n    objectives = [obj for _, obj in archive]\n    selected_idx = 0\n    for i in range(1, len(archive)):\n        if objectives[i][0] < objectives[selected_idx][0] and objectives[i][1] < objectives[selected_idx][1]:\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion with cross-space validation\n    num_segments = random.randint(1, min(3, n//2))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        segments.append((start, end))\n\n    # Apply inversions\n    for start, end in sorted(segments, reverse=True):\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    # Cross-space validation\n    for i in range(n-1):\n        node1 = new_solution[i]\n        node2 = new_solution[i+1]\n        if (distance_matrix_1[node1, node2] > distance_matrix_2[node1, node2] and\n            distance_matrix_1[new_solution[i-1], node1] > distance_matrix_2[new_solution[i-1], node1]):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7335970307379426,
            0.9585314989089966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest dominance count (simplified for this example)\n    objectives = [obj for _, obj in archive]\n    selected_idx = 0\n    for i in range(1, len(archive)):\n        if objectives[i][0] < objectives[selected_idx][0] and objectives[i][1] < objectives[selected_idx][1]:\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion with cross-space validation\n    num_segments = random.randint(1, min(3, n//2))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+5, n-1))\n        segments.append((start, end))\n\n    # Apply inversions\n    for start, end in sorted(segments, reverse=True):\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    # Cross-space validation\n    for i in range(n-1):\n        node1 = new_solution[i]\n        node2 = new_solution[i+1]\n        if (distance_matrix_1[node1, node2] > distance_matrix_2[node1, node2] and\n            distance_matrix_1[new_solution[i-1], node1] > distance_matrix_2[new_solution[i-1], node1]):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"multi-segment reversal\" local search that reverses segments of the tour in both objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[segment[-1], next_j]\n        new_cost1 = distance_matrix_1[prev_i, segment[-1]] + distance_matrix_1[segment[0], next_j]\n\n        old_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[segment[-1], next_j]\n        new_cost2 = distance_matrix_2[prev_i, segment[-1]] + distance_matrix_2[segment[0], next_j]\n\n        if (new_cost1 - old_cost1) + (new_cost2 - old_cost2) >= 0:\n            new_solution[i:j+1] = segment\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7845030877028158,
            1.0795632600784302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        i, j = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[segment[-1], next_j]\n        new_cost1 = distance_matrix_1[prev_i, segment[-1]] + distance_matrix_1[segment[0], next_j]\n\n        old_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[segment[-1], next_j]\n        new_cost2 = distance_matrix_2[prev_i, segment[-1]] + distance_matrix_2[segment[0], next_j]\n\n        if (new_cost1 - old_cost1) + (new_cost2 - old_cost2) >= 0:\n            new_solution[i:j+1] = segment\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"multi-segment inversion\" local search that randomly inverts segments of the tour while ensuring feasibility through careful segment validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Invert the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[j-1]] +\n                     distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[i], next_i])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[j-1]] +\n                     distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[i], next_i])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8618699452750385,
            1.0845481753349304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Randomly select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Invert the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[j-1]] +\n                     distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[i], next_i])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[j-1]] +\n                     distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[i], next_i])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"multi-segment reversal and rotation\" local search that intelligently reverses and rotates multiple segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n\n    crowding_distances = []\n    for obj in objectives:\n        dist1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        dist2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple segments to reverse and rotate\n        num_segments = random.randint(1, min(3, n // 3))\n        segment_indices = sorted(random.sample(range(1, n-1), num_segments))\n\n        for i in segment_indices:\n            start = i\n            end = min(i + random.randint(2, n//2), n-1)\n            segment = new_solution[start:end+1]\n\n            # Reverse the segment\n            new_solution[start:end+1] = segment[::-1]\n\n            # Rotate the segment\n            rotation = random.randint(1, len(segment) - 1)\n            new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.74343596834027,
            1.2717625498771667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n\n    crowding_distances = []\n    for obj in objectives:\n        dist1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0\n        dist2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0\n        crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple segments to reverse and rotate\n        num_segments = random.randint(1, min(3, n // 3))\n        segment_indices = sorted(random.sample(range(1, n-1), num_segments))\n\n        for i in segment_indices:\n            start = i\n            end = min(i + random.randint(2, n//2), n-1)\n            segment = new_solution[start:end+1]\n\n            # Reverse the segment\n            new_solution[start:end+1] = segment[::-1]\n\n            # Rotate the segment\n            rotation = random.randint(1, len(segment) - 1)\n            new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{The new heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a crowding distance score to prioritize solutions in less explored regions, applies a hybrid local search combining 3-opt and node relocation to generate neighbors, and ensures feasibility by validating the solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: 3-opt and node relocation\n    if random.random() < 0.5:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n        new_solution[j:k+1] = base_solution[j:k+1][::-1]\n    else:\n        # Node relocation\n        node = random.choice(new_solution)\n        pos = random.randint(0, n - 1)\n        new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9460200195792472,
            1.5307430028915405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: 3-opt and node relocation\n    if random.random() < 0.5:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n        new_solution[j:k+1] = base_solution[j:k+1][::-1]\n    else:\n        # Node relocation\n        node = random.choice(new_solution)\n        pos = random.randint(0, n - 1)\n        new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This heuristic selects a solution from the archive based on the diversity of its objective values, then applies a \"cross-space node relocation\" local search that intelligently repositions nodes between the two objective spaces while ensuring feasibility through a novel validation and repair mechanism that maintains tour continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most diverse objective values\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    std_obj1 = np.std(obj1_values)\n    std_obj2 = np.std(obj2_values)\n    selected_idx = np.argmax([std_obj1 + std_obj2])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Cross-space node relocation\n    # Select a node to relocate\n    node_to_relocate = random.choice(new_solution)\n\n    # Find its current position and remove it\n    pos = np.where(new_solution == node_to_relocate)[0][0]\n    new_solution = np.delete(new_solution, pos)\n\n    # Calculate potential insertion positions\n    possible_positions = list(range(n-1))\n\n    # Evaluate each potential insertion\n    best_pos = None\n    best_improvement = float('inf')\n\n    for new_pos in possible_positions:\n        # Create temporary solution\n        temp_solution = np.insert(new_solution, new_pos, node_to_relocate)\n\n        # Calculate costs for first objective space\n        prev_node = temp_solution[new_pos-1] if new_pos > 0 else temp_solution[-1]\n        next_node = temp_solution[(new_pos+1)%(n-1)]\n        new_cost1 = (distance_matrix_1[prev_node, node_to_relocate] +\n                    distance_matrix_1[node_to_relocate, next_node])\n\n        # Calculate costs for second objective space\n        new_cost2 = (distance_matrix_2[prev_node, node_to_relocate] +\n                    distance_matrix_2[node_to_relocate, next_node])\n\n        # Calculate total improvement\n        improvement = new_cost1 + new_cost2\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_pos = new_pos\n\n    if best_pos is not None:\n        new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9436919178919542,
            1.4584733247756958
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most diverse objective values\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    std_obj1 = np.std(obj1_values)\n    std_obj2 = np.std(obj2_values)\n    selected_idx = np.argmax([std_obj1 + std_obj2])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Cross-space node relocation\n    # Select a node to relocate\n    node_to_relocate = random.choice(new_solution)\n\n    # Find its current position and remove it\n    pos = np.where(new_solution == node_to_relocate)[0][0]\n    new_solution = np.delete(new_solution, pos)\n\n    # Calculate potential insertion positions\n    possible_positions = list(range(n-1))\n\n    # Evaluate each potential insertion\n    best_pos = None\n    best_improvement = float('inf')\n\n    for new_pos in possible_positions:\n        # Create temporary solution\n        temp_solution = np.insert(new_solution, new_pos, node_to_relocate)\n\n        # Calculate costs for first objective space\n        prev_node = temp_solution[new_pos-1] if new_pos > 0 else temp_solution[-1]\n        next_node = temp_solution[(new_pos+1)%(n-1)]\n        new_cost1 = (distance_matrix_1[prev_node, node_to_relocate] +\n                    distance_matrix_1[node_to_relocate, next_node])\n\n        # Calculate costs for second objective space\n        new_cost2 = (distance_matrix_2[prev_node, node_to_relocate] +\n                    distance_matrix_2[node_to_relocate, next_node])\n\n        # Calculate total improvement\n        improvement = new_cost1 + new_cost2\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_pos = new_pos\n\n    if best_pos is not None:\n        new_solution = np.insert(new_solution, best_pos, node_to_relocate)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a \"cross-space segment reversal\" local search that reverses segments of nodes while considering both objective spaces, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 2:\n        # Select a random segment to reverse\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 5, n - 1))  # Limit segment size to 5 for efficiency\n\n        # Calculate potential improvement\n        prev_start = new_solution[start - 1]\n        next_end = new_solution[(end + 1) % n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform reversal if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8956392310852604,
            0.8528748154640198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 2:\n        # Select a random segment to reverse\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, min(start + 5, n - 1))  # Limit segment size to 5 for efficiency\n\n        # Calculate potential improvement\n        prev_start = new_solution[start - 1]\n        next_end = new_solution[(end + 1) % n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform reversal if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment inversion and adaptive node relocation\" local search that intelligently inverts segments of the tour and relocates nodes based on their potential to improve both objectives while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 2:\n        return new_solution\n\n    # Multi-segment inversion\n    if random.random() < 0.5:\n        num_segments = random.randint(1, min(3, n//2))\n        segment_lengths = [random.randint(2, n//num_segments) for _ in range(num_segments)]\n        segment_lengths[-1] = n - sum(segment_lengths[:-1]) if sum(segment_lengths[:-1]) < n else segment_lengths[-1]\n\n        current_pos = 0\n        for length in segment_lengths:\n            if current_pos + length > n:\n                break\n            segment = new_solution[current_pos:current_pos+length]\n            new_solution[current_pos:current_pos+length] = segment[::-1]\n            current_pos += length\n\n    # Adaptive node relocation\n    else:\n        num_relocations = random.randint(1, min(3, n//2))\n        for _ in range(num_relocations):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n\n            # Calculate potential improvement\n            prev_i = new_solution[i-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[(j+1)%n]\n\n            old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                         distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] +\n                         distance_matrix_1[new_solution[j], next_j])\n\n            new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                         distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] +\n                         distance_matrix_1[new_solution[i], next_j])\n\n            old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                         distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] +\n                         distance_matrix_2[new_solution[j], next_j])\n\n            new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                         distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] +\n                         distance_matrix_2[new_solution[i], next_j])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7634208071441665,
            1.1082649230957031
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 2:\n        return new_solution\n\n    # Multi-segment inversion\n    if random.random() < 0.5:\n        num_segments = random.randint(1, min(3, n//2))\n        segment_lengths = [random.randint(2, n//num_segments) for _ in range(num_segments)]\n        segment_lengths[-1] = n - sum(segment_lengths[:-1]) if sum(segment_lengths[:-1]) < n else segment_lengths[-1]\n\n        current_pos = 0\n        for length in segment_lengths:\n            if current_pos + length > n:\n                break\n            segment = new_solution[current_pos:current_pos+length]\n            new_solution[current_pos:current_pos+length] = segment[::-1]\n            current_pos += length\n\n    # Adaptive node relocation\n    else:\n        num_relocations = random.randint(1, min(3, n//2))\n        for _ in range(num_relocations):\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n\n            # Calculate potential improvement\n            prev_i = new_solution[i-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[(j+1)%n]\n\n            old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                         distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] +\n                         distance_matrix_1[new_solution[j], next_j])\n\n            new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                         distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] +\n                         distance_matrix_1[new_solution[i], next_j])\n\n            old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                         distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] +\n                         distance_matrix_2[new_solution[j], next_j])\n\n            new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                         distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] +\n                         distance_matrix_2[new_solution[i], next_j])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment reversal\" local search that reverses segments of nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 2:\n        # Select two random positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment reversal if it improves the solution\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9886147285144942,
            0.686015784740448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 2:\n        # Select two random positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment reversal if it improves the solution\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a non-dominated solution from the archive, applies a hybrid local search operator that combines segment inversion and node relocation to explore the Pareto front, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_value = archive[0][1][0] + archive[0][1][1]\n    for i in range(1, len(archive)):\n        current_value = archive[i][1][0] + archive[i][1][1]\n        if current_value < best_value:\n            best_idx = i\n            best_value = current_value\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7844840528286412,
            0.9057222604751587
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_value = archive[0][1][0] + archive[0][1][1]\n    for i in range(1, len(archive)):\n        current_value = archive[i][1][0] + archive[i][1][1]\n        if current_value < best_value:\n            best_idx = i\n            best_value = current_value\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a \"multi-segment relocation\" local search that intelligently moves segments of the tour between random positions while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    min_obj1 = min(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    diversity_scores = [(obj[0] - min_obj1) / (max_obj1 - min_obj1) + (obj[1] - min_obj2) / (max_obj2 - min_obj2) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    if n > 3:\n        # Select segment boundaries\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n\n        # Remove segment\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Insert segment at new position\n        insert_pos = c - (b - a)\n        if insert_pos < 0:\n            insert_pos = 0\n        elif insert_pos > len(remaining):\n            insert_pos = len(remaining)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8690252946465582,
            0.9135540127754211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    min_obj1 = min(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    diversity_scores = [(obj[0] - min_obj1) / (max_obj1 - min_obj1) + (obj[1] - min_obj2) / (max_obj2 - min_obj2) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    if n > 3:\n        # Select segment boundaries\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n\n        # Remove segment\n        remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n        # Insert segment at new position\n        insert_pos = c - (b - a)\n        if insert_pos < 0:\n            insert_pos = 0\n        elif insert_pos > len(remaining):\n            insert_pos = len(remaining)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive with high potential for improvement, then applies a hybrid local search combining segment reversal and node swapping, while ensuring feasibility by validating the solution and reverting to the original if invalid.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    top_solutions = sorted_archive[:max(1, len(archive) // 5)]\n    selected_idx = random.randint(0, len(top_solutions) - 1)\n    base_solution = top_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment to explore new configurations\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random nodes to further explore the solution space\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8701911036839887,
            0.7211595773696899
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    top_solutions = sorted_archive[:max(1, len(archive) // 5)]\n    selected_idx = random.randint(0, len(top_solutions) - 1)\n    base_solution = top_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment to explore new configurations\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two random nodes to further explore the solution space\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment inversion\" local search that reverses segments of the tour in both objective spaces simultaneously, ensuring feasibility through careful validation and repair mechanisms while considering the combined impact on both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select random segment to reverse\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        old_cost1 = distance_matrix_1[prev_start, segment[0]] + distance_matrix_1[segment[-1], next_end]\n        new_cost1 = distance_matrix_1[prev_start, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_end]\n\n        old_cost2 = distance_matrix_2[prev_start, segment[0]] + distance_matrix_2[segment[-1], next_end]\n        new_cost2 = distance_matrix_2[prev_start, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = reversed_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7808937733860468,
            0.7102239727973938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select random segment to reverse\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        reversed_segment = segment[::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        old_cost1 = distance_matrix_1[prev_start, segment[0]] + distance_matrix_1[segment[-1], next_end]\n        new_cost1 = distance_matrix_1[prev_start, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_end]\n\n        old_cost2 = distance_matrix_2[prev_start, segment[0]] + distance_matrix_2[segment[-1], next_end]\n        new_cost2 = distance_matrix_2[prev_start, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = reversed_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{The new algorithm selects a solution from the archive based on a score combining objective values and diversity, applies a hybrid local search combining segment reversal and node relocation, and ensures feasibility by validating the generated neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol, obj):\n        return (obj[0] + obj[1]) / (1 + np.sum(sol != archive[0][0]))\n\n    # Select solution with highest score\n    selected = max(archive, key=lambda x: score(x[0], x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0022661651506668,
            0.9227895736694336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(sol, obj):\n        return (obj[0] + obj[1]) / (1 + np.sum(sol != archive[0][0]))\n\n    # Select solution with highest score\n    selected = max(archive, key=lambda x: score(x[0], x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"segment inversion with cross-space validation\" local search that inverts a random segment of the tour while ensuring feasibility and validating improvements across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance (approximated by normalized objective difference)\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        sorted_obj1 = sorted([obj[0] for obj in objectives])\n        sorted_obj2 = sorted([obj[1] for obj in objectives])\n        crowding = []\n        for obj in objectives:\n            idx1 = sorted_obj1.index(obj[0])\n            idx2 = sorted_obj2.index(obj[1])\n            crowding.append((idx1 / len(objectives)) + (idx2 / len(objectives)))\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 2:\n        # Select random segment\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate old cost\n        old_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        # Invert segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Calculate new cost\n        new_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9127629879434049,
            1.079670786857605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance (approximated by normalized objective difference)\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        sorted_obj1 = sorted([obj[0] for obj in objectives])\n        sorted_obj2 = sorted([obj[1] for obj in objectives])\n        crowding = []\n        for obj in objectives:\n            idx1 = sorted_obj1.index(obj[0])\n            idx2 = sorted_obj2.index(obj[1])\n            crowding.append((idx1 / len(objectives)) + (idx2 / len(objectives)))\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 2:\n        # Select random segment\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate old cost\n        old_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        # Invert segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Calculate new cost\n        new_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{The new algorithm selects a solution from the archive based on a fitness score combining both objectives, then applies a hybrid local search combining segment reversal and node reinsertion with adaptive segment sizes to explore diverse regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate fitness scores (normalized sum of objectives)\n    scores = [(sol[1][0] + sol[1][1]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2)) for sol in archive]\n    selected_idx = np.argmin(scores)  # Select solution with lowest normalized score\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 3, int(np.sqrt(n))))\n\n    # Hybrid local search: segment reversal + node reinsertion\n    for _ in range(2):  # Perform two operations per call\n        op = random.random()\n        if op < 0.5:  # Segment reversal with adaptive size\n            start = random.randint(0, n - segment_size)\n            end = min(start + segment_size, n - 1)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n        else:  # Node reinsertion\n            node_pos = random.randint(0, n - 1)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            new_pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8485117206250562,
            0.8866982460021973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate fitness scores (normalized sum of objectives)\n    scores = [(sol[1][0] + sol[1][1]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2)) for sol in archive]\n    selected_idx = np.argmin(scores)  # Select solution with lowest normalized score\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment size based on solution quality\n    segment_size = max(2, min(n // 3, int(np.sqrt(n))))\n\n    # Hybrid local search: segment reversal + node reinsertion\n    for _ in range(2):  # Perform two operations per call\n        op = random.random()\n        if op < 0.5:  # Segment reversal with adaptive size\n            start = random.randint(0, n - segment_size)\n            end = min(start + segment_size, n - 1)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n        else:  # Node reinsertion\n            node_pos = random.randint(0, n - 1)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            new_pos = random.randint(0, n - 2)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"cross-space segment inversion\" local search that inverts a randomly selected segment of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, base_solution[start]] +\n                     distance_matrix_1[base_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, base_solution[start]] +\n                     distance_matrix_2[base_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5630947716794645,
            3.8805806040763855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, base_solution[start]] +\n                     distance_matrix_1[base_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, base_solution[start]] +\n                     distance_matrix_2[base_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"multi-segment reversal\" local search that randomly reverses segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [(obj[0]/min_obj1) + (obj[1]/min_obj2) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    if n > 3:\n        # Randomly select segment boundaries\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments are valid and non-overlapping\n        if a < b < c < d:\n            # Reverse segments\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7278136136887389,
            4.540377616882324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [(obj[0]/min_obj1) + (obj[1]/min_obj2) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    if n > 3:\n        # Randomly select segment boundaries\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments are valid and non-overlapping\n        if a < b < c < d:\n            # Reverse segments\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"cross-space segment reversal\" local search that reverses segments of nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 3:\n        # Select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment reversal if it improves the solution\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.633709188396209,
            7.6611523032188416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment reversal\n    if n > 3:\n        # Select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment reversal if it improves the solution\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment inversion and reinsertion\" local search that randomly inverts multiple segments of the tour and reinserts them at new positions while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and reinsertion\n    num_segments = random.randint(1, min(3, n//2))\n    segments = []\n\n    # Select and invert random segments\n    for _ in range(num_segments):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n        segments.append((start, end, inverted_segment))\n\n    # Reinsert segments at new positions\n    for start, end, segment in segments:\n        # Remove the original segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        # Insert the inverted segment at a new random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.822871078695876,
            0.4551013708114624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and reinsertion\n    num_segments = random.randint(1, min(3, n//2))\n    segments = []\n\n    # Select and invert random segments\n    for _ in range(num_segments):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n        segments.append((start, end, inverted_segment))\n\n    # Reinsert segments at new positions\n    for start, end, segment in segments:\n        # Remove the original segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        # Insert the inverted segment at a new random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{The new heuristic function selects a promising solution from the archive and generates a neighbor by performing a guided segment reversal and node reinsertion, ensuring feasibility while exploring diverse regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Reinsert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9736209228265913,
            0.07137268781661987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Reinsert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest hypervolume contribution, then applies a \"multi-segment inversion and reinsertion\" local search that intelligently inverts multiple segments and reinserts them at new positions while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest hypervolume contribution (approximated by normalized product of objectives)\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    hypervolume_scores = [(obj[0]/max_obj1) * (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(hypervolume_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and reinsertion\n    if n > 3:\n        # Select two random segments\n        seg1_start = random.randint(0, n - 3)\n        seg1_end = random.randint(seg1_start + 1, n - 2)\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2_start = random.randint(0, n - 3)\n        seg2_end = random.randint(seg2_start + 1, n - 2)\n        seg2 = new_solution[seg2_start:seg2_end+1]\n\n        # Invert both segments\n        inverted_seg1 = seg1[::-1]\n        inverted_seg2 = seg2[::-1]\n\n        # Reinsert segments at new positions\n        new_solution[seg1_start:seg1_end+1] = inverted_seg1\n        new_solution[seg2_start:seg2_end+1] = inverted_seg2\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8942020386939578,
            1.2875707149505615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest hypervolume contribution (approximated by normalized product of objectives)\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    hypervolume_scores = [(obj[0]/max_obj1) * (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(hypervolume_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and reinsertion\n    if n > 3:\n        # Select two random segments\n        seg1_start = random.randint(0, n - 3)\n        seg1_end = random.randint(seg1_start + 1, n - 2)\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2_start = random.randint(0, n - 3)\n        seg2_end = random.randint(seg2_start + 1, n - 2)\n        seg2 = new_solution[seg2_start:seg2_end+1]\n\n        # Invert both segments\n        inverted_seg1 = seg1[::-1]\n        inverted_seg2 = seg2[::-1]\n\n        # Reinsert segments at new positions\n        new_solution[seg1_start:seg1_end+1] = inverted_seg1\n        new_solution[seg2_start:seg2_end+1] = inverted_seg2\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment reversal\" local search that reverses segments of the tour in one space while intelligently adjusting the other space to maintain feasibility and potentially improve both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement for both spaces\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment reversal if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.918414503479023,
            0.6980355381965637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement for both spaces\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment reversal if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a non-dominated solution from the archive, applies a hybrid local search operator that combines edge inversion and node relocation to explore diverse regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for idx, (sol, obj) in enumerate(archive):\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(idx)\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Invert a random edge\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Relocate a random node\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9896878153169653,
            0.7103680372238159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for idx, (sol, obj) in enumerate(archive):\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(idx)\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Invert a random edge\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Relocate a random node\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity (measured by the number of unique node pairs in segments), then applies a \"segmented inversion\" local search that reverses a randomly chosen segment of the tour while ensuring feasibility through careful boundary checks and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (most unique node pairs in segments)\n    diversity_scores = []\n    for sol, _ in archive:\n        n = len(sol)\n        unique_pairs = set()\n        for i in range(n):\n            unique_pairs.add((sol[i], sol[(i+1)%n]))\n        diversity_scores.append(len(unique_pairs))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segmented inversion\n    if n > 2:\n        # Randomly select segment boundaries\n        a, b = sorted(random.sample(range(n), 2))\n\n        # Invert the segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9167527138966329,
            1.9437272548675537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (most unique node pairs in segments)\n    diversity_scores = []\n    for sol, _ in archive:\n        n = len(sol)\n        unique_pairs = set()\n        for i in range(n):\n            unique_pairs.add((sol[i], sol[(i+1)%n]))\n        diversity_scores.append(len(unique_pairs))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segmented inversion\n    if n > 2:\n        # Randomly select segment boundaries\n        a, b = sorted(random.sample(range(n), 2))\n\n        # Invert the segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{The new heuristic function 'select_neighbor' intelligently selects a solution from the archive using a score-based selection mechanism that prioritizes solutions with high potential for improvement, applies a hybrid local search operator that combines node swapping and segment reversal to explore the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Score-based selection: prioritize solutions with high potential for improvement\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        # Calculate improvement potential (simplified for demonstration)\n        total_cost = cost1 + cost2\n        improvement_potential = total_cost / len(sol)\n        scores.append(improvement_potential)\n\n    selected_idx = np.argmax(scores) if scores else random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: combine node swapping and segment reversal\n    # Step 1: Randomly swap two nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Randomly reverse a segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8930806715878035,
            0.3779911994934082
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Score-based selection: prioritize solutions with high potential for improvement\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        # Calculate improvement potential (simplified for demonstration)\n        total_cost = cost1 + cost2\n        improvement_potential = total_cost / len(sol)\n        scores.append(improvement_potential)\n\n    selected_idx = np.argmax(scores) if scores else random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: combine node swapping and segment reversal\n    # Step 1: Randomly swap two nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Randomly reverse a segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This heuristic selects a non-dominated solution from the archive, applies a \"multi-segment reversal\" local search that reverses multiple non-overlapping segments of the tour while ensuring feasibility through careful validation and repair mechanisms, and evaluates the neighbor solution based on both objectives before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select non-dominated solution\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Determine number of segments to reverse (1 to 3)\n        num_segments = random.randint(1, min(3, n // 3))\n\n        # Generate non-overlapping segments\n        segments = []\n        positions = sorted(random.sample(range(n), num_segments * 2))\n        for i in range(0, len(positions), 2):\n            start, end = positions[i], positions[i+1]\n            if start != end:\n                segments.append((start, end))\n\n        # Reverse each segment\n        for start, end in segments:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8584378934607262,
            0.40837162733078003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select non-dominated solution\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = random.choice(non_dominated)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Determine number of segments to reverse (1 to 3)\n        num_segments = random.randint(1, min(3, n // 3))\n\n        # Generate non-overlapping segments\n        segments = []\n        positions = sorted(random.sample(range(n), num_segments * 2))\n        for i in range(0, len(positions), 2):\n            start, end = positions[i], positions[i+1]\n            if start != end:\n                segments.append((start, end))\n\n        # Reverse each segment\n        for start, end in segments:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a \"cross-space node insertion\" local search that intelligently reinserts nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    max_obj1 = max(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n\n    diversity_scores = [((obj[0] - min_obj1) / (max_obj1 - min_obj1) - (obj[1] - min_obj2) / (max_obj2 - min_obj2)) ** 2 for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 2:\n        # Select a node to remove and a position to insert\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n\n        # Remove node at i and insert it before j\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Validate the new solution\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5982565477924172,
            0.4289712905883789
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    max_obj1 = max(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n\n    diversity_scores = [((obj[0] - min_obj1) / (max_obj1 - min_obj1) - (obj[1] - min_obj2) / (max_obj2 - min_obj2)) ** 2 for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 2:\n        # Select a node to remove and a position to insert\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while i == j:\n            j = random.randint(0, n-1)\n\n        # Remove node at i and insert it before j\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        new_solution = np.insert(new_solution, j, node)\n\n        # Validate the new solution\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined dominance score, then applies a \"bi-objective segment inversion and cross-space insertion\" local search that inverts segments in one space and inserts nodes in the other, while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined dominance score\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    dominance_scores = [(obj[0]/max_obj1) * (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Bi-objective segment inversion and cross-space insertion\n        # Select a random segment to invert in one space\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-2)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Insert a random node from the other space at a new position\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:pos], [node_to_insert], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9034569809227484,
            0.25508028268814087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined dominance score\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    dominance_scores = [(obj[0]/max_obj1) * (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Bi-objective segment inversion and cross-space insertion\n        # Select a random segment to invert in one space\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-2)\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Insert a random node from the other space at a new position\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:pos], [node_to_insert], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"multi-segment reversal with cross-space validation\" local search that intelligently reverses multiple segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            dist2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal with cross-space validation\n    if n > 3:\n        # Select multiple segments to reverse\n        num_segments = random.randint(1, min(3, n // 2))\n        segment_starts = sorted(random.sample(range(1, n-1), num_segments))\n\n        for start in segment_starts:\n            end = random.randint(start, n-1)\n            segment = new_solution[start:end+1]\n\n            # Calculate potential improvement\n            prev_start = new_solution[start-1]\n            next_end = new_solution[(end+1)%n]\n\n            old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n            new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n\n            old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n            new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < 0:\n                # Perform reversal if it improves the solution\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8425683949804237,
            3.3892370462417603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = sorted_obj1[i+1][0] - sorted_obj1[i-1][0]\n            dist2 = sorted_obj2[i+1][1] - sorted_obj2[i-1][1]\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal with cross-space validation\n    if n > 3:\n        # Select multiple segments to reverse\n        num_segments = random.randint(1, min(3, n // 2))\n        segment_starts = sorted(random.sample(range(1, n-1), num_segments))\n\n        for start in segment_starts:\n            end = random.randint(start, n-1)\n            segment = new_solution[start:end+1]\n\n            # Calculate potential improvement\n            prev_start = new_solution[start-1]\n            next_end = new_solution[(end+1)%n]\n\n            old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n            new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n\n            old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n            new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < 0:\n                # Perform reversal if it improves the solution\n                new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a novel hybrid local search operator that combines node swapping with objective-aware segment reversal to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        score = 0.5 * obj[0] + 0.5 * obj[1]  # Equal weighting for simplicity\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Identify a segment where swapping nodes could improve both objectives\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n\n    # Step 2: Swap nodes in the segment based on their contribution to both objectives\n    for i in range(len(segment)):\n        for j in range(i + 1, len(segment)):\n            node_i = segment[i]\n            node_j = segment[j]\n            prev_i = segment[i-1] if i > 0 else segment[-1]\n            next_i = segment[i+1] if i < len(segment)-1 else segment[0]\n            prev_j = segment[j-1] if j > 0 else segment[-1]\n            next_j = segment[j+1] if j < len(segment)-1 else segment[0]\n\n            # Calculate potential improvement in both objectives\n            delta_1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                       distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]) - \\\n                      (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                       distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n\n            delta_2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                       distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]) - \\\n                      (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                       distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            # If swapping improves both objectives, perform the swap\n            if delta_1 < 0 and delta_2 < 0:\n                segment[i], segment[j] = segment[j], segment[i]\n\n    # Step 3: Reverse the segment if it improves both objectives\n    reversed_segment = segment[::-1]\n    delta_1 = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[segment[0], segment[1]]) - \\\n              (distance_matrix_1[segment[-1], segment[1]] + distance_matrix_1[segment[0], segment[-1]])\n    delta_2 = (distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[segment[0], segment[1]]) - \\\n              (distance_matrix_2[segment[-1], segment[1]] + distance_matrix_2[segment[0], segment[-1]])\n\n    if delta_1 < 0 and delta_2 < 0:\n        new_solution[start:end+1] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8282223189832979,
            0.7026693224906921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        score = 0.5 * obj[0] + 0.5 * obj[1]  # Equal weighting for simplicity\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Identify a segment where swapping nodes could improve both objectives\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n\n    # Step 2: Swap nodes in the segment based on their contribution to both objectives\n    for i in range(len(segment)):\n        for j in range(i + 1, len(segment)):\n            node_i = segment[i]\n            node_j = segment[j]\n            prev_i = segment[i-1] if i > 0 else segment[-1]\n            next_i = segment[i+1] if i < len(segment)-1 else segment[0]\n            prev_j = segment[j-1] if j > 0 else segment[-1]\n            next_j = segment[j+1] if j < len(segment)-1 else segment[0]\n\n            # Calculate potential improvement in both objectives\n            delta_1 = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                       distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]) - \\\n                      (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                       distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j])\n\n            delta_2 = (distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                       distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]) - \\\n                      (distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                       distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            # If swapping improves both objectives, perform the swap\n            if delta_1 < 0 and delta_2 < 0:\n                segment[i], segment[j] = segment[j], segment[i]\n\n    # Step 3: Reverse the segment if it improves both objectives\n    reversed_segment = segment[::-1]\n    delta_1 = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[segment[0], segment[1]]) - \\\n              (distance_matrix_1[segment[-1], segment[1]] + distance_matrix_1[segment[0], segment[-1]])\n    delta_2 = (distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[segment[0], segment[1]]) - \\\n              (distance_matrix_2[segment[-1], segment[1]] + distance_matrix_2[segment[0], segment[-1]])\n\n    if delta_1 < 0 and delta_2 < 0:\n        new_solution[start:end+1] = reversed_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a \"multi-segment inversion and reinsertion\" local search that intelligently reorders and reinserts multiple segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    min_obj1 = min(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    diversity_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) - (obj[1] - min_obj2)/(max_obj2 - min_obj2) for obj in objectives]\n    selected_idx = np.argmax(np.abs(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and reinsertion\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - 5)\n        seg1_end = random.randint(seg1_start + 1, n - 4)\n        seg2_start = random.randint(seg1_end + 1, n - 3)\n        seg2_end = random.randint(seg2_start + 1, n - 2)\n\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2 = new_solution[seg2_start:seg2_end+1]\n\n        # Invert both segments\n        seg1_inv = seg1[::-1]\n        seg2_inv = seg2[::-1]\n\n        # Reinsert inverted segments at new positions\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            seg2_inv,\n            new_solution[seg1_end+1:seg2_start],\n            seg1_inv,\n            new_solution[seg2_end+1:]\n        ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6273291391010036,
            0.8483202457427979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    min_obj1 = min(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    diversity_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) - (obj[1] - min_obj2)/(max_obj2 - min_obj2) for obj in objectives]\n    selected_idx = np.argmax(np.abs(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and reinsertion\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - 5)\n        seg1_end = random.randint(seg1_start + 1, n - 4)\n        seg2_start = random.randint(seg1_end + 1, n - 3)\n        seg2_end = random.randint(seg2_start + 1, n - 2)\n\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2 = new_solution[seg2_start:seg2_end+1]\n\n        # Invert both segments\n        seg1_inv = seg1[::-1]\n        seg2_inv = seg2[::-1]\n\n        # Reinsert inverted segments at new positions\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            seg2_inv,\n            new_solution[seg1_end+1:seg2_start],\n            seg1_inv,\n            new_solution[seg2_end+1:]\n        ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a \"multi-segment inversion\" local search that randomly selects a contiguous segment of nodes and reverses their order while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    diversity_scores = [(max(obj1_values) - obj[0])**2 + (max(obj2_values) - obj[1])**2 for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Randomly select segment start and length\n        start = random.randint(0, n-2)\n        length = random.randint(2, min(5, n-1))\n        end = min(start + length, n)\n\n        # Reverse the selected segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7321934130587167,
            1.7912734746932983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    diversity_scores = [(max(obj1_values) - obj[0])**2 + (max(obj2_values) - obj[1])**2 for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Randomly select segment start and length\n        start = random.randint(0, n-2)\n        length = random.randint(2, min(5, n-1))\n        end = min(start + length, n)\n\n        # Reverse the selected segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a weighted random selection favoring solutions with lower combined objective values, then applies a hybrid local search combining segment reversal and node reinsertion with feasibility checks to generate a diverse neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj[0] + obj[1] for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy()\n\n    min_obj = min(objectives)\n    max_obj = max(objectives)\n    if max_obj == min_obj:\n        weights = [1.0 for _ in objectives]\n    else:\n        weights = [(max_obj - obj + 1) / (max_obj - min_obj + 1) for obj in objectives]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node reinsertion\n    if random.random() < 0.5:\n        # Segment reversal\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Node reinsertion\n        pos = random.randint(0, n - 1)\n        node = new_solution[pos]\n        new_pos = random.randint(0, n - 2)\n        if new_pos >= pos:\n            new_pos += 1\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9011053203728439,
            0.9475440382957458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj[0] + obj[1] for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy()\n\n    min_obj = min(objectives)\n    max_obj = max(objectives)\n    if max_obj == min_obj:\n        weights = [1.0 for _ in objectives]\n    else:\n        weights = [(max_obj - obj + 1) / (max_obj - min_obj + 1) for obj in objectives]\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node reinsertion\n    if random.random() < 0.5:\n        # Segment reversal\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Node reinsertion\n        pos = random.randint(0, n - 1)\n        node = new_solution[pos]\n        new_pos = random.randint(0, n - 2)\n        if new_pos >= pos:\n            new_pos += 1\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating the trade-off between the two objectives, then applies a hybrid local search operator that combines segment reversal and node displacement to generate a neighbor solution while ensuring feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on trade-off between objectives\n    def trade_off(obj):\n        return obj[0] + obj[1]  # Simple sum for trade-off evaluation\n\n    archive_sorted = sorted(archive, key=lambda x: trade_off(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node displacement\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Displace a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8676708835536125,
            0.5965003371238708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on trade-off between objectives\n    def trade_off(obj):\n        return obj[0] + obj[1]  # Simple sum for trade-off evaluation\n\n    archive_sorted = sorted(archive, key=lambda x: trade_off(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node displacement\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Displace a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{The new heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a hybrid score combining objective values and diversity, then applies a novel segment reversal and node swap operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate hybrid scores for selection\n    scores = []\n    for sol, obj in archive:\n        score = obj[0] * 0.6 + obj[1] * 0.4  # Weighted sum of objectives\n        diversity = np.sum(np.abs(sol - archive[0][0]))  # Simple diversity measure\n        scores.append(score + diversity * 0.1)\n\n    selected_idx = np.argmin(scores)  # Select solution with lowest hybrid score\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8338657919581373,
            1.4166927337646484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate hybrid scores for selection\n    scores = []\n    for sol, obj in archive:\n        score = obj[0] * 0.6 + obj[1] * 0.4  # Weighted sum of objectives\n        diversity = np.sum(np.abs(sol - archive[0][0]))  # Simple diversity measure\n        scores.append(score + diversity * 0.1)\n\n    selected_idx = np.argmin(scores)  # Select solution with lowest hybrid score\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a \"multi-segment inversion and relocation\" local search that intelligently inverts and relocates multiple non-adjacent segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Selection based on crowding distance and objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    n = len(solutions)\n\n    if n == 1:\n        return solutions[0].copy()\n\n    # Calculate crowding distance for each objective\n    obj1_sorted = sorted(range(n), key=lambda i: objectives[i][0])\n    obj2_sorted = sorted(range(n), key=lambda i: objectives[i][1])\n\n    crowding_dist = [0.0] * n\n    for obj_idx, sorted_idx in [(0, obj1_sorted), (1, obj2_sorted)]:\n        crowding_dist[sorted_idx[0]] = float('inf')\n        crowding_dist[sorted_idx[-1]] = float('inf')\n        for i in range(1, n-1):\n            if objectives[sorted_idx[i+1]][obj_idx] == objectives[sorted_idx[i-1]][obj_idx]:\n                continue\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1]][obj_idx] - objectives[sorted_idx[i-1]][obj_idx])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and relocation\n    num_segments = random.randint(1, min(3, n//4))\n    segment_indices = sorted(random.sample(range(n), num_segments))\n\n    for i in segment_indices:\n        # Randomly select a segment length\n        segment_length = random.randint(2, min(5, n//2))\n\n        # Find segment boundaries\n        start = i\n        end = min(start + segment_length - 1, n - 1)\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Relocate segments to new positions\n    for i in segment_indices:\n        # Randomly select a segment length\n        segment_length = random.randint(2, min(5, n//2))\n\n        # Find segment boundaries\n        start = i\n        end = min(start + segment_length - 1, n - 1)\n\n        # Extract the segment\n        segment = new_solution[start:end+1]\n\n        # Remove the segment from its original position\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n        # Insert the segment at a new random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7332214223147461,
            0.856397807598114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Selection based on crowding distance and objective diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    n = len(solutions)\n\n    if n == 1:\n        return solutions[0].copy()\n\n    # Calculate crowding distance for each objective\n    obj1_sorted = sorted(range(n), key=lambda i: objectives[i][0])\n    obj2_sorted = sorted(range(n), key=lambda i: objectives[i][1])\n\n    crowding_dist = [0.0] * n\n    for obj_idx, sorted_idx in [(0, obj1_sorted), (1, obj2_sorted)]:\n        crowding_dist[sorted_idx[0]] = float('inf')\n        crowding_dist[sorted_idx[-1]] = float('inf')\n        for i in range(1, n-1):\n            if objectives[sorted_idx[i+1]][obj_idx] == objectives[sorted_idx[i-1]][obj_idx]:\n                continue\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1]][obj_idx] - objectives[sorted_idx[i-1]][obj_idx])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and relocation\n    num_segments = random.randint(1, min(3, n//4))\n    segment_indices = sorted(random.sample(range(n), num_segments))\n\n    for i in segment_indices:\n        # Randomly select a segment length\n        segment_length = random.randint(2, min(5, n//2))\n\n        # Find segment boundaries\n        start = i\n        end = min(start + segment_length - 1, n - 1)\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Relocate segments to new positions\n    for i in segment_indices:\n        # Randomly select a segment length\n        segment_length = random.randint(2, min(5, n//2))\n\n        # Find segment boundaries\n        start = i\n        end = min(start + segment_length - 1, n - 1)\n\n        # Extract the segment\n        segment = new_solution[start:end+1]\n\n        # Remove the segment from its original position\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n        # Insert the segment at a new random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This new heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"multi-segment inversion\" local search that reverses a randomly selected segment of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n\n        # Perform inversion\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        new_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if it doesn't improve the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6440563461544278,
            6.5103344321250916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n\n        # Perform inversion\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        new_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if it doesn't improve the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a novel \"bi-objective segment inversion\" local search that flips segments of the tour while considering both objectives, ensuring feasibility through careful boundary preservation and cost validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance and objective diversity\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    # Calculate crowding distance\n    crowding = []\n    for i in range(len(archive)):\n        left = max(0, i-1)\n        right = min(len(archive)-1, i+1)\n        crowding.append(abs(obj1[right] - obj1[left]) + abs(obj2[right] - obj2[left]))\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0 or random.random() < 0.2:  # Accept with some probability if not improving\n            # Perform inversion\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7206774507811755,
            1.5216289162635803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance and objective diversity\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    # Calculate crowding distance\n    crowding = []\n    for i in range(len(archive)):\n        left = max(0, i-1)\n        right = min(len(archive)-1, i+1)\n        crowding.append(abs(obj1[right] - obj1[left]) + abs(obj2[right] - obj2[left]))\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0 or random.random() < 0.2:  # Accept with some probability if not improving\n            # Perform inversion\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a \"multi-segment inversion and cross-space node relocation\" strategy that intelligently inverts segments of the tour and relocates nodes between objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced objectives and good diversity\n    objectives = [obj for _, obj in archive]\n    min_obj1, max_obj1 = min(obj[0] for obj in objectives), max(obj[0] for obj in objectives)\n    min_obj2, max_obj2 = min(obj[1] for obj in objectives), max(obj[1] for obj in objectives)\n\n    # Normalize and combine objectives\n    scores = []\n    for obj in objectives:\n        norm1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        score = (norm1 + norm2) / 2  # Balanced score\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and cross-space node relocation\n    for _ in range(2):  # Perform two operations for more exploration\n        op = random.choice(['invert', 'relocate'])\n\n        if op == 'invert':\n            # Invert a random segment\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 1, n - 2)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n        else:\n            # Relocate a node to a position that improves both objectives\n            i = random.randint(0, n - 1)\n            node = new_solution[i]\n\n            # Find best insertion position considering both objectives\n            best_pos = i\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == i or pos == (i - 1) % n or pos == (i + 1) % n:\n                    continue\n\n                # Calculate potential improvement for both objectives\n                prev_i = new_solution[i-1]\n                next_i = new_solution[(i+1)%n]\n                prev_pos = new_solution[pos-1]\n                next_pos = new_solution[pos]\n\n                old_cost1 = (distance_matrix_1[prev_i, node] + distance_matrix_1[node, next_i] +\n                           distance_matrix_1[prev_pos, new_solution[pos]] + distance_matrix_1[new_solution[pos], next_pos])\n                new_cost1 = (distance_matrix_1[prev_i, next_i] +\n                           distance_matrix_1[prev_pos, node] + distance_matrix_1[node, next_pos])\n\n                old_cost2 = (distance_matrix_2[prev_i, node] + distance_matrix_2[node, next_i] +\n                           distance_matrix_2[prev_pos, new_solution[pos]] + distance_matrix_2[new_solution[pos], next_pos])\n                new_cost2 = (distance_matrix_2[prev_i, next_i] +\n                           distance_matrix_2[prev_pos, node] + distance_matrix_2[node, next_pos])\n\n                improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            # Perform relocation if beneficial\n            if best_improvement < 0:\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8973429554996063,
            0.8492972254753113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced objectives and good diversity\n    objectives = [obj for _, obj in archive]\n    min_obj1, max_obj1 = min(obj[0] for obj in objectives), max(obj[0] for obj in objectives)\n    min_obj2, max_obj2 = min(obj[1] for obj in objectives), max(obj[1] for obj in objectives)\n\n    # Normalize and combine objectives\n    scores = []\n    for obj in objectives:\n        norm1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        score = (norm1 + norm2) / 2  # Balanced score\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and cross-space node relocation\n    for _ in range(2):  # Perform two operations for more exploration\n        op = random.choice(['invert', 'relocate'])\n\n        if op == 'invert':\n            # Invert a random segment\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 1, n - 2)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n        else:\n            # Relocate a node to a position that improves both objectives\n            i = random.randint(0, n - 1)\n            node = new_solution[i]\n\n            # Find best insertion position considering both objectives\n            best_pos = i\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == i or pos == (i - 1) % n or pos == (i + 1) % n:\n                    continue\n\n                # Calculate potential improvement for both objectives\n                prev_i = new_solution[i-1]\n                next_i = new_solution[(i+1)%n]\n                prev_pos = new_solution[pos-1]\n                next_pos = new_solution[pos]\n\n                old_cost1 = (distance_matrix_1[prev_i, node] + distance_matrix_1[node, next_i] +\n                           distance_matrix_1[prev_pos, new_solution[pos]] + distance_matrix_1[new_solution[pos], next_pos])\n                new_cost1 = (distance_matrix_1[prev_i, next_i] +\n                           distance_matrix_1[prev_pos, node] + distance_matrix_1[node, next_pos])\n\n                old_cost2 = (distance_matrix_2[prev_i, node] + distance_matrix_2[node, next_i] +\n                           distance_matrix_2[prev_pos, new_solution[pos]] + distance_matrix_2[new_solution[pos], next_pos])\n                new_cost2 = (distance_matrix_2[prev_i, next_i] +\n                           distance_matrix_2[prev_pos, node] + distance_matrix_2[node, next_pos])\n\n                improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            # Perform relocation if beneficial\n            if best_improvement < 0:\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment inversion\" local search that intelligently reverses segments of nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        segment = new_solution[start:end+1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9017286638366794,
            0.5238616466522217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        segment = new_solution[start:end+1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive and applies a hybrid local search operator that combines segment reversal and node relocation to explore diverse non-dominated regions in the bi-objective space while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                crowding_distances[i] += abs(archive[i][1][0] - archive[j][1][0]) + abs(archive[i][1][1] - archive[j][1][1])\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7574662342135705,
            4.041963219642639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = [0] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                crowding_distances[i] += abs(archive[i][1][0] - archive[j][1][0]) + abs(archive[i][1][1] - archive[j][1][1])\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective improvement potential, then applies a \"cross-space segment inversion\" local search that reverses segments of the tour in one space while preserving feasibility, with the goal of finding trade-offs between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest potential for improvement\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    improvement_scores = [(max_obj1 - obj[0] + max_obj2 - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to invert in one space\n        space = random.choice([distance_matrix_1, distance_matrix_2])\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n\n        # Calculate cost before inversion\n        old_cost = 0\n        for i in range(start, end + 1):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            old_cost += space[prev, curr] + space[curr, next_node]\n\n        # Invert the segment\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Calculate cost after inversion\n        new_cost = 0\n        for i in range(start, end + 1):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            new_cost += space[prev, curr] + space[curr, next_node]\n\n        # Revert if no improvement\n        if new_cost >= old_cost:\n            new_solution[start:end+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8779918256441122,
            0.548011839389801
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest potential for improvement\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    improvement_scores = [(max_obj1 - obj[0] + max_obj2 - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to invert in one space\n        space = random.choice([distance_matrix_1, distance_matrix_2])\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n\n        # Calculate cost before inversion\n        old_cost = 0\n        for i in range(start, end + 1):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            old_cost += space[prev, curr] + space[curr, next_node]\n\n        # Invert the segment\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Calculate cost after inversion\n        new_cost = 0\n        for i in range(start, end + 1):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            new_cost += space[prev, curr] + space[curr, next_node]\n\n        # Revert if no improvement\n        if new_cost >= old_cost:\n            new_solution[start:end+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest normalized objective values and then applies a \"multi-segment inversion\" local search that reverses segments of the tour while considering both objective spaces to find improved solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two random segments to invert\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n        # Ensure segments don't overlap\n        if (a < c < b < d) or (c < a < d < b):\n            # Calculate potential improvement\n            old_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                         distance_matrix_1[new_solution[d-1], new_solution[d]])\n\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] +\n                         distance_matrix_1[new_solution[a], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[d-1]] +\n                         distance_matrix_1[new_solution[c], new_solution[d]])\n\n            old_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                         distance_matrix_2[new_solution[d-1], new_solution[d]])\n\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b-1]] +\n                         distance_matrix_2[new_solution[a], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[d-1]] +\n                         distance_matrix_2[new_solution[c], new_solution[d]])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < 0:\n                # Perform inversion if it improves the solution\n                new_solution[a:b] = new_solution[a:b][::-1]\n                new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8993758397474333,
            0.5343512892723083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two random segments to invert\n        a, b = sorted(random.sample(range(1, n), 2))\n        c, d = sorted(random.sample(range(1, n), 2))\n\n        # Ensure segments don't overlap\n        if (a < c < b < d) or (c < a < d < b):\n            # Calculate potential improvement\n            old_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                         distance_matrix_1[new_solution[d-1], new_solution[d]])\n\n            new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] +\n                         distance_matrix_1[new_solution[a], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[d-1]] +\n                         distance_matrix_1[new_solution[c], new_solution[d]])\n\n            old_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                         distance_matrix_2[new_solution[d-1], new_solution[d]])\n\n            new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b-1]] +\n                         distance_matrix_2[new_solution[a], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[d-1]] +\n                         distance_matrix_2[new_solution[c], new_solution[d]])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < 0:\n                # Perform inversion if it improves the solution\n                new_solution[a:b] = new_solution[a:b][::-1]\n                new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a high-quality solution from the archive, applies a hybrid local search operator that combines segment reversal and node relocation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_score(obj):\n        return 0.6 * obj[0] + 0.4 * obj[1]\n\n    best_idx = min(range(len(archive)), key=lambda i: objective_score(archive[i][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7890687343458863,
            0.38152873516082764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def objective_score(obj):\n        return 0.6 * obj[0] + 0.4 * obj[1]\n\n    best_idx = min(range(len(archive)), key=lambda i: objective_score(archive[i][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment inversion\" local search that inverts contiguous segments of the tour while considering both objective spaces to balance improvements across both dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Select two distinct random positions\n        a, b = sorted(random.sample(range(n), 2))\n        segment_length = min(3, n - b - 1)  # Limit segment length to 3 for practicality\n\n        # Determine inversion range\n        start = a\n        end = b + segment_length\n\n        # Calculate old and new costs for both objectives\n        old_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_1[new_solution[end], new_solution[(end+1)%n]])\n        old_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_2[new_solution[end], new_solution[(end+1)%n]])\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        new_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_1[new_solution[end], new_solution[(end+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_2[new_solution[end], new_solution[(end+1)%n]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.032172648026389,
            0.3723459243774414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Select two distinct random positions\n        a, b = sorted(random.sample(range(n), 2))\n        segment_length = min(3, n - b - 1)  # Limit segment length to 3 for practicality\n\n        # Determine inversion range\n        start = a\n        end = b + segment_length\n\n        # Calculate old and new costs for both objectives\n        old_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_1[new_solution[end], new_solution[(end+1)%n]])\n        old_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_2[new_solution[end], new_solution[(end+1)%n]])\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        new_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_1[new_solution[end], new_solution[(end+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_2[new_solution[end], new_solution[(end+1)%n]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"multi-segment reversal\" local search that reverses segments of the tour in both objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [(obj[0]/min_obj1) + (obj[1]/min_obj2) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    if n > 3:\n        # Select two distinct segments\n        a, b, c, d = sorted(random.sample(range(n), 4))\n\n        # Reverse segments in both objective spaces\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Calculate potential improvement\n        # For first objective space\n        old_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                     distance_matrix_1[new_solution[d-1], new_solution[d]])\n\n        new_cost1 = (distance_matrix_1[new_solution[a-1], segment1[-1]] +\n                     distance_matrix_1[segment1[0], new_solution[b]] +\n                     distance_matrix_1[new_solution[c-1], segment2[-1]] +\n                     distance_matrix_1[segment2[0], new_solution[d]])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                     distance_matrix_2[new_solution[d-1], new_solution[d]])\n\n        new_cost2 = (distance_matrix_2[new_solution[a-1], segment1[-1]] +\n                     distance_matrix_2[segment1[0], new_solution[b]] +\n                     distance_matrix_2[new_solution[c-1], segment2[-1]] +\n                     distance_matrix_2[segment2[0], new_solution[d]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform reversal if it improves the solution\n            new_solution[a:b] = segment1[::-1]\n            new_solution[c:d] = segment2[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6744934858892166,
            2.8371917605400085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [(obj[0]/min_obj1) + (obj[1]/min_obj2) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    if n > 3:\n        # Select two distinct segments\n        a, b, c, d = sorted(random.sample(range(n), 4))\n\n        # Reverse segments in both objective spaces\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n\n        # Calculate potential improvement\n        # For first objective space\n        old_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                     distance_matrix_1[new_solution[d-1], new_solution[d]])\n\n        new_cost1 = (distance_matrix_1[new_solution[a-1], segment1[-1]] +\n                     distance_matrix_1[segment1[0], new_solution[b]] +\n                     distance_matrix_1[new_solution[c-1], segment2[-1]] +\n                     distance_matrix_1[segment2[0], new_solution[d]])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[c]] +\n                     distance_matrix_2[new_solution[d-1], new_solution[d]])\n\n        new_cost2 = (distance_matrix_2[new_solution[a-1], segment1[-1]] +\n                     distance_matrix_2[segment1[0], new_solution[b]] +\n                     distance_matrix_2[new_solution[c-1], segment2[-1]] +\n                     distance_matrix_2[segment2[0], new_solution[d]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform reversal if it improves the solution\n            new_solution[a:b] = segment1[::-1]\n            new_solution[c:d] = segment2[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"cross-space segment inversion\" local search that inverts segments of the tour in both objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select two distinct positions\n        i, j = sorted(random.sample(range(1, n), 2))\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5942143382770781,
            3.7685425877571106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select two distinct positions\n        i, j = sorted(random.sample(range(1, n), 2))\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment relocation\" local search that intelligently moves entire segments of nodes between different positions in the tour while considering both objective spaces, ensuring feasibility through careful segment validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to move\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))\n        segment = new_solution[seg_start:seg_end+1]\n\n        # Select a new position to insert the segment\n        insert_pos = random.randint(0, n-1)\n        while insert_pos >= seg_start and insert_pos <= seg_end:\n            insert_pos = random.randint(0, n-1)\n\n        # Remove the segment from its current position\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Calculate potential improvement\n        # For simplicity, we'll just check if the new solution is feasible\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8883034388268805,
            0.3854137659072876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to move\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))\n        segment = new_solution[seg_start:seg_end+1]\n\n        # Select a new position to insert the segment\n        insert_pos = random.randint(0, n-1)\n        while insert_pos >= seg_start and insert_pos <= seg_end:\n            insert_pos = random.randint(0, n-1)\n\n        # Remove the segment from its current position\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Calculate potential improvement\n        # For simplicity, we'll just check if the new solution is feasible\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a \"multi-segment inversion\" local search that flips randomly selected segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [(abs(obj[0]-mean_obj1) + abs(obj[1]-mean_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Select two random segments\n        start1, end1 = sorted(random.sample(range(n), 2))\n        start2, end2 = sorted(random.sample(range(n), 2))\n\n        # Invert the segments\n        new_solution[start1:end1+1] = new_solution[start1:end1+1][::-1]\n        new_solution[start2:end2+1] = new_solution[start2:end2+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7064778586453996,
            0.3901379704475403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [(abs(obj[0]-mean_obj1) + abs(obj[1]-mean_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Select two random segments\n        start1, end1 = sorted(random.sample(range(n), 2))\n        start2, end2 = sorted(random.sample(range(n), 2))\n\n        # Invert the segments\n        new_solution[start1:end1+1] = new_solution[start1:end1+1][::-1]\n        new_solution[start2:end2+1] = new_solution[start2:end2+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"segment inversion\" local search that intelligently reverses a random segment of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 2:\n        # Select segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5705168211810276,
            3.192991256713867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 2:\n        # Select segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a novel local search operator that combines path reversal with a biased random walk to explore the solution space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform a biased random walk to explore new regions\n    current_pos = random.randint(0, n - 1)\n    steps = random.randint(1, min(5, n // 2))\n    for _ in range(steps):\n        next_pos = (current_pos + random.choice([-1, 1])) % n\n        if random.random() < 0.5:\n            new_solution[current_pos], new_solution[next_pos] = new_solution[next_pos], new_solution[current_pos]\n        current_pos = next_pos\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8745847239781808,
            0.40548640489578247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform a biased random walk to explore new regions\n    current_pos = random.randint(0, n - 1)\n    steps = random.randint(1, min(5, n // 2))\n    for _ in range(steps):\n        next_pos = (current_pos + random.choice([-1, 1])) % n\n        if random.random() < 0.5:\n            new_solution[current_pos], new_solution[next_pos] = new_solution[next_pos], new_solution[current_pos]\n        current_pos = next_pos\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"segment inversion\" local search that reverses a randomly selected segment of the tour while ensuring feasibility through careful boundary handling and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distances\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = (sorted_obj1[i+1][0] - sorted_obj1[i-1][0]) / (sorted_obj1[-1][0] - sorted_obj1[0][0] + 1e-10)\n            dist2 = (sorted_obj2[i+1][1] - sorted_obj2[i-1][1]) / (sorted_obj2[-1][1] - sorted_obj2[0][1] + 1e-10)\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6807541065575904,
            0.5145739912986755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distances\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n    crowding_distances = []\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = (sorted_obj1[i+1][0] - sorted_obj1[i-1][0]) / (sorted_obj1[-1][0] - sorted_obj1[0][0] + 1e-10)\n            dist2 = (sorted_obj2[i+1][1] - sorted_obj2[i-1][1]) / (sorted_obj2[-1][1] - sorted_obj2[0][1] + 1e-10)\n            crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This heuristic selects a solution from the archive based on the worst normalized objective values, then applies a \"cross-space segment inversion\" local search that inverts segments of nodes between the two objective spaces while carefully validating and repairing the solution to maintain feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with worst normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select two distinct positions to define a segment\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Invert the segment\n        new_solution[i:j+1] = segment[::-1]\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[i:j+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8269331171059594,
            0.3296758532524109
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with worst normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select two distinct positions to define a segment\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Invert the segment\n        new_solution[i:j+1] = segment[::-1]\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[i:j+1] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"segment inversion\" local search that reverses a random segment of the tour while ensuring feasibility through careful validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 2:\n        # Select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Invert the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Validate feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8891649592844603,
            0.3631476163864136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 2:\n        # Select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Invert the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Validate feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space path reversal\" local search that reverses a segment of the tour while considering both objective spaces to potentially improve both costs simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space path reversal\n    if n > 2:\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate potential improvement\n        prev_a = new_solution[a-1]\n        next_b = new_solution[(b+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                     distance_matrix_1[new_solution[b], next_b])\n        new_cost1 = (distance_matrix_1[prev_a, new_solution[b]] +\n                     distance_matrix_1[new_solution[a], next_b])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                     distance_matrix_2[new_solution[b], next_b])\n        new_cost2 = (distance_matrix_2[prev_a, new_solution[b]] +\n                     distance_matrix_2[new_solution[a], next_b])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform reversal if it improves the solution\n            new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8942559652955835,
            0.35627293586730957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space path reversal\n    if n > 2:\n        # Select a random segment to reverse\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Calculate potential improvement\n        prev_a = new_solution[a-1]\n        next_b = new_solution[(b+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                     distance_matrix_1[new_solution[b], next_b])\n        new_cost1 = (distance_matrix_1[prev_a, new_solution[b]] +\n                     distance_matrix_1[new_solution[a], next_b])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                     distance_matrix_2[new_solution[b], next_b])\n        new_cost2 = (distance_matrix_2[prev_a, new_solution[b]] +\n                     distance_matrix_2[new_solution[a], next_b])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform reversal if it improves the solution\n            new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment inversion and reinsertion\" local search that inverts multiple segments and reinserts them at different positions while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select multiple segments and invert them\n    num_segments = random.randint(1, min(3, n // 2))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments))\n\n    for i in range(num_segments):\n        start = segment_indices[i]\n        end = random.randint(start + 1, min(start + 5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert segments at new positions\n    for i in range(num_segments):\n        start = segment_indices[i]\n        end = random.randint(start + 1, min(start + 5, n-1))\n        segment = new_solution[start:end+1]\n        new_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7872710616532292,
            0.3942735195159912
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select multiple segments and invert them\n    num_segments = random.randint(1, min(3, n // 2))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments))\n\n    for i in range(num_segments):\n        start = segment_indices[i]\n        end = random.randint(start + 1, min(start + 5, n-1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Reinsert segments at new positions\n    for i in range(num_segments):\n        start = segment_indices[i]\n        end = random.randint(start + 1, min(start + 5, n-1))\n        segment = new_solution[start:end+1]\n        new_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive, identifies critical nodes based on their contribution to both objectives, and applies a hybrid local search that combines segment reversal and node swapping to explore diverse non-dominated regions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Identify critical nodes (high contribution to both objectives)\n    critical_nodes = set()\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        if (distance_matrix_1[prev][curr] + distance_matrix_1[curr][next_node] > 1.5 * np.mean(distance_matrix_1) or\n            distance_matrix_2[prev][curr] + distance_matrix_2[curr][next_node] > 1.5 * np.mean(distance_matrix_2)):\n            critical_nodes.add(curr)\n\n    # Apply segment reversal on critical nodes\n    if critical_nodes:\n        critical_indices = [i for i, node in enumerate(new_solution) if node in critical_nodes]\n        if len(critical_indices) >= 2:\n            start, end = sorted(random.sample(critical_indices, 2))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply node swapping between critical and non-critical nodes\n    if critical_nodes and len(new_solution) - len(critical_nodes) > 0:\n        non_critical = [node for node in new_solution if node not in critical_nodes]\n        if non_critical:\n            swap_critical = random.choice(list(critical_nodes))\n            swap_non_critical = random.choice(non_critical)\n            idx_critical = np.where(new_solution == swap_critical)[0][0]\n            idx_non_critical = np.where(new_solution == swap_non_critical)[0][0]\n            new_solution[idx_critical], new_solution[idx_non_critical] = new_solution[idx_non_critical], new_solution[idx_critical]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5664344156290955,
            0.7085767388343811
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Identify critical nodes (high contribution to both objectives)\n    critical_nodes = set()\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        if (distance_matrix_1[prev][curr] + distance_matrix_1[curr][next_node] > 1.5 * np.mean(distance_matrix_1) or\n            distance_matrix_2[prev][curr] + distance_matrix_2[curr][next_node] > 1.5 * np.mean(distance_matrix_2)):\n            critical_nodes.add(curr)\n\n    # Apply segment reversal on critical nodes\n    if critical_nodes:\n        critical_indices = [i for i, node in enumerate(new_solution) if node in critical_nodes]\n        if len(critical_indices) >= 2:\n            start, end = sorted(random.sample(critical_indices, 2))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply node swapping between critical and non-critical nodes\n    if critical_nodes and len(new_solution) - len(critical_nodes) > 0:\n        non_critical = [node for node in new_solution if node not in critical_nodes]\n        if non_critical:\n            swap_critical = random.choice(list(critical_nodes))\n            swap_non_critical = random.choice(non_critical)\n            idx_critical = np.where(new_solution == swap_critical)[0][0]\n            idx_non_critical = np.where(new_solution == swap_non_critical)[0][0]\n            new_solution[idx_critical], new_solution[idx_non_critical] = new_solution[idx_non_critical], new_solution[idx_critical]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node relocation and segment reversal to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n        # Select solution with the smallest sum of normalized objectives\n        selected_idx = np.argmin(normalized.sum(axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Reverse a random segment to explore different tour structures\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8434538982784356,
            0.2649044990539551
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n        # Select solution with the smallest sum of normalized objectives\n        selected_idx = np.argmin(normalized.sum(axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Reverse a random segment to explore different tour structures\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This new heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"segment inversion with cross-space validation\" local search that inverts a random segment of the tour while ensuring feasibility through careful cross-space distance checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 2:\n        # Select random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Store original segment\n        original_segment = new_solution[start:end+1].copy()\n\n        # Invert the segment\n        new_solution[start:end+1] = original_segment[::-1]\n\n        # Validate cross-space distances\n        valid = True\n        for i in range(n):\n            prev_node = new_solution[i-1]\n            curr_node = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            # Check if the new tour is valid in both spaces\n            if (distance_matrix_1[prev_node, curr_node] == 0 or\n                distance_matrix_1[curr_node, next_node] == 0 or\n                distance_matrix_2[prev_node, curr_node] == 0 or\n                distance_matrix_2[curr_node, next_node] == 0):\n                valid = False\n                break\n\n        if not valid:\n            # Revert to original if invalid\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7000767929097916,
            0.31078505516052246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 2:\n        # Select random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Store original segment\n        original_segment = new_solution[start:end+1].copy()\n\n        # Invert the segment\n        new_solution[start:end+1] = original_segment[::-1]\n\n        # Validate cross-space distances\n        valid = True\n        for i in range(n):\n            prev_node = new_solution[i-1]\n            curr_node = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            # Check if the new tour is valid in both spaces\n            if (distance_matrix_1[prev_node, curr_node] == 0 or\n                distance_matrix_1[curr_node, next_node] == 0 or\n                distance_matrix_2[prev_node, curr_node] == 0 or\n                distance_matrix_2[curr_node, next_node] == 0):\n                valid = False\n                break\n\n        if not valid:\n            # Revert to original if invalid\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This heuristic intelligently selects a solution from the archive by prioritizing those with balanced objective values, then applies a \"multi-segment reversal and insertion\" local search that combines segment reversal with node insertion to explore diverse regions of the bi-objective space while ensuring feasibility through careful validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced objective values\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = sum(obj[0] for obj in objectives) / len(objectives)\n    avg_obj2 = sum(obj[1] for obj in objectives) / len(objectives)\n    balance_scores = [abs(obj[0] - avg_obj1) + abs(obj[1] - avg_obj2) for obj in objectives]\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment reversal and insertion\n    # Step 1: Reverse multiple segments\n    num_segments = random.randint(1, min(3, n // 3))\n    for _ in range(num_segments):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert nodes from another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        nodes_to_insert = random.sample(list(other_solution), min(3, len(other_solution) // 2))\n        for node in nodes_to_insert:\n            pos = random.randint(0, n - 1)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8211127325011478,
            0.1307355761528015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced objective values\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = sum(obj[0] for obj in objectives) / len(objectives)\n    avg_obj2 = sum(obj[1] for obj in objectives) / len(objectives)\n    balance_scores = [abs(obj[0] - avg_obj1) + abs(obj[1] - avg_obj2) for obj in objectives]\n    selected_idx = np.argmin(balance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment reversal and insertion\n    # Step 1: Reverse multiple segments\n    num_segments = random.randint(1, min(3, n // 3))\n    for _ in range(num_segments):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert nodes from another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        nodes_to_insert = random.sample(list(other_solution), min(3, len(other_solution) // 2))\n        for node in nodes_to_insert:\n            pos = random.randint(0, n - 1)\n            new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"double-bridge\" local search that creates two disjoint segments by removing two random edges and reconnecting them in a novel way, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance (approximate)\n    objectives = [obj for _, obj in archive]\n    obj1_sorted = sorted(objectives, key=lambda x: x[0])\n    obj2_sorted = sorted(objectives, key=lambda x: x[1])\n\n    crowding = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives)-1:\n            crowding.append(float('inf'))\n        else:\n            crowding.append((obj1_sorted[i+1][0] - obj1_sorted[i-1][0]) + (obj2_sorted[i+1][1] - obj2_sorted[i-1][1]))\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Double-bridge local search\n    if n > 4:\n        # Select two random edges to remove\n        edges = list(range(n))\n        i1, i2 = random.sample(edges, 2)\n\n        # Create two segments\n        segment1 = new_solution[:i1+1]\n        segment2 = new_solution[i1+1:i2+1]\n        segment3 = new_solution[i2+1:]\n\n        # Reconnect segments in a novel way\n        new_solution = np.concatenate([segment1, segment3, segment2])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.761123890788862,
            0.3330625295639038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance (approximate)\n    objectives = [obj for _, obj in archive]\n    obj1_sorted = sorted(objectives, key=lambda x: x[0])\n    obj2_sorted = sorted(objectives, key=lambda x: x[1])\n\n    crowding = []\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives)-1:\n            crowding.append(float('inf'))\n        else:\n            crowding.append((obj1_sorted[i+1][0] - obj1_sorted[i-1][0]) + (obj2_sorted[i+1][1] - obj2_sorted[i-1][1]))\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Double-bridge local search\n    if n > 4:\n        # Select two random edges to remove\n        edges = list(range(n))\n        i1, i2 = random.sample(edges, 2)\n\n        # Create two segments\n        segment1 = new_solution[:i1+1]\n        segment2 = new_solution[i1+1:i2+1]\n        segment3 = new_solution[i2+1:]\n\n        # Reconnect segments in a novel way\n        new_solution = np.concatenate([segment1, segment3, segment2])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a non-dominated solution from the archive, applies a hybrid local search operator that combines edge swaps and segment reversals to explore diverse regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]:\n                    dominated[i] = True\n                    break\n        non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Perform edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.857617804539019,
            0.8734890818595886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]:\n                    dominated[i] = True\n                    break\n        non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Perform edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"multi-segment inversion\" local search that randomly inverts segments of the tour while carefully validating and repairing the solution to ensure feasibility and potential improvement in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Randomly select segment boundaries\n        a, b = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_a = new_solution[a-1]\n        next_b = new_solution[(b+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                     distance_matrix_1[new_solution[b], next_b])\n\n        new_cost1 = (distance_matrix_1[prev_a, new_solution[b]] +\n                     distance_matrix_1[new_solution[a], next_b])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                     distance_matrix_2[new_solution[b], next_b])\n\n        new_cost2 = (distance_matrix_2[prev_a, new_solution[b]] +\n                     distance_matrix_2[new_solution[a], next_b])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5129741694469205,
            3.7831954956054688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Randomly select segment boundaries\n        a, b = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_a = new_solution[a-1]\n        next_b = new_solution[(b+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                     distance_matrix_1[new_solution[b], next_b])\n\n        new_cost1 = (distance_matrix_1[prev_a, new_solution[b]] +\n                     distance_matrix_1[new_solution[a], next_b])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                     distance_matrix_2[new_solution[b], next_b])\n\n        new_cost2 = (distance_matrix_2[prev_a, new_solution[b]] +\n                     distance_matrix_2[new_solution[a], next_b])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a hybrid scoring function that combines crowding distance and objective diversity, then applies a segment reversal and node swap operator to generate a feasible neighbor solution while exploring non-dominated regions in the bi-objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Crowding distance in objective space\n        crowding = (obj[0] + obj[1]) * 0.5\n        # Objective diversity (difference between objectives)\n        diversity = abs(obj[0] - obj[1])\n        scores.append(crowding + diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Segment reversal\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6496563101147348,
            0.30382341146469116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Crowding distance in objective space\n        crowding = (obj[0] + obj[1]) * 0.5\n        # Objective diversity (difference between objectives)\n        diversity = abs(obj[0] - obj[1])\n        scores.append(crowding + diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Segment reversal\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Node swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment inversion with cross-space evaluation\" local search that randomly selects a segment of nodes to invert and evaluates the improvement across both objective spaces, accepting the inversion if it shows combined improvement in either space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with cross-space evaluation\n    if n > 2:\n        # Randomly select segment length and starting point\n        segment_length = random.randint(2, max(2, n // 3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Store original segment\n        original_segment = new_solution[start:end].copy()\n\n        # Invert the segment\n        new_solution[start:end] = original_segment[::-1]\n\n        # Calculate costs before and after inversion\n        # For first objective space\n        old_cost1 = 0\n        new_cost1 = 0\n\n        # Calculate edges affected by inversion\n        prev_start = new_solution[start-1]\n        next_end = new_solution[end%n]\n\n        # Original edges\n        old_cost1 += distance_matrix_1[prev_start, original_segment[0]]\n        old_cost1 += distance_matrix_1[original_segment[-1], next_end]\n\n        # New edges\n        new_cost1 += distance_matrix_1[prev_start, original_segment[-1]]\n        new_cost1 += distance_matrix_1[original_segment[0], next_end]\n\n        # For second objective space\n        old_cost2 = 0\n        new_cost2 = 0\n\n        # Original edges\n        old_cost2 += distance_matrix_2[prev_start, original_segment[0]]\n        old_cost2 += distance_matrix_2[original_segment[-1], next_end]\n\n        # New edges\n        new_cost2 += distance_matrix_2[prev_start, original_segment[-1]]\n        new_cost2 += distance_matrix_2[original_segment[0], next_end]\n\n        # Calculate total improvement\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        # Revert if no improvement\n        if improvement >= 0:\n            new_solution[start:end] = original_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9712447257248515,
            0.37645602226257324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion with cross-space evaluation\n    if n > 2:\n        # Randomly select segment length and starting point\n        segment_length = random.randint(2, max(2, n // 3))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Store original segment\n        original_segment = new_solution[start:end].copy()\n\n        # Invert the segment\n        new_solution[start:end] = original_segment[::-1]\n\n        # Calculate costs before and after inversion\n        # For first objective space\n        old_cost1 = 0\n        new_cost1 = 0\n\n        # Calculate edges affected by inversion\n        prev_start = new_solution[start-1]\n        next_end = new_solution[end%n]\n\n        # Original edges\n        old_cost1 += distance_matrix_1[prev_start, original_segment[0]]\n        old_cost1 += distance_matrix_1[original_segment[-1], next_end]\n\n        # New edges\n        new_cost1 += distance_matrix_1[prev_start, original_segment[-1]]\n        new_cost1 += distance_matrix_1[original_segment[0], next_end]\n\n        # For second objective space\n        old_cost2 = 0\n        new_cost2 = 0\n\n        # Original edges\n        old_cost2 += distance_matrix_2[prev_start, original_segment[0]]\n        old_cost2 += distance_matrix_2[original_segment[-1], next_end]\n\n        # New edges\n        new_cost2 += distance_matrix_2[prev_start, original_segment[-1]]\n        new_cost2 += distance_matrix_2[original_segment[0], next_end]\n\n        # Calculate total improvement\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        # Revert if no improvement\n        if improvement >= 0:\n            new_solution[start:end] = original_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"multi-segment inversion and reinsertion\" local search that intelligently inverts multiple segments of the tour and reinserts them at new positions while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance (approximated by objective diversity)\n    objectives = [obj for _, obj in archive]\n    obj1_vals = [obj[0] for obj in objectives]\n    obj2_vals = [obj[1] for obj in objectives]\n    crowding_scores = [(max(obj1_vals) - min(obj1_vals)) + (max(obj2_vals) - min(obj2_vals)) for _ in objectives]\n    selected_idx = np.argmax(crowding_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and reinsertion\n    num_segments = random.randint(1, min(3, n // 2))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        segments.append((start, end))\n\n    # Sort segments by start index and merge overlapping segments\n    segments.sort()\n    merged_segments = []\n    for seg in segments:\n        if not merged_segments:\n            merged_segments.append(seg)\n        else:\n            last_start, last_end = merged_segments[-1]\n            current_start, current_end = seg\n            if current_start <= last_end:\n                merged_segments[-1] = (last_start, max(last_end, current_end))\n            else:\n                merged_segments.append(seg)\n\n    # Invert and reinsert segments\n    for start, end in merged_segments:\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n        new_pos = random.randint(0, n - len(inverted_segment))\n        new_solution = np.concatenate([new_solution[:new_pos], inverted_segment, new_solution[new_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9067485517691956,
            1.786588966846466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance (approximated by objective diversity)\n    objectives = [obj for _, obj in archive]\n    obj1_vals = [obj[0] for obj in objectives]\n    obj2_vals = [obj[1] for obj in objectives]\n    crowding_scores = [(max(obj1_vals) - min(obj1_vals)) + (max(obj2_vals) - min(obj2_vals)) for _ in objectives]\n    selected_idx = np.argmax(crowding_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and reinsertion\n    num_segments = random.randint(1, min(3, n // 2))\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        segments.append((start, end))\n\n    # Sort segments by start index and merge overlapping segments\n    segments.sort()\n    merged_segments = []\n    for seg in segments:\n        if not merged_segments:\n            merged_segments.append(seg)\n        else:\n            last_start, last_end = merged_segments[-1]\n            current_start, current_end = seg\n            if current_start <= last_end:\n                merged_segments[-1] = (last_start, max(last_end, current_end))\n            else:\n                merged_segments.append(seg)\n\n    # Invert and reinsert segments\n    for start, end in merged_segments:\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n        new_pos = random.randint(0, n - len(inverted_segment))\n        new_solution = np.concatenate([new_solution[:new_pos], inverted_segment, new_solution[new_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{The new algorithm intelligently selects a non-dominated solution from the archive, applies a hybrid local search combining edge swapping and path reversal to explore diverse regions, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        crowding = 0\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j:\n                crowding += abs(obj[0] - other_obj[0]) + abs(obj[1] - other_obj[1])\n        crowding_distances.append(crowding)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Randomly swap two edges\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6209624707613656,
            3.642447292804718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        crowding = 0\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j:\n                crowding += abs(obj[0] - other_obj[0]) + abs(obj[1] - other_obj[1])\n        crowding_distances.append(crowding)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Randomly swap two edges\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment reversal\" local search that reverses segments of the tour while considering the combined improvement in both objective spaces, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment to reverse\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        segment = new_solution[start:end+1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Reverse the segment if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9224970277453419,
            0.3009902238845825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a segment to reverse\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        segment = new_solution[start:end+1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, segment[0]] +\n                     distance_matrix_1[segment[-1], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, segment[0]] +\n                     distance_matrix_2[segment[-1], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Reverse the segment if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment inversion\" local search that intelligently reverses segments of the tour while considering both objective spaces, ensuring feasibility through careful segment boundary validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select two distinct positions to define a segment\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment inversion if it improves the solution\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9132686274773681,
            0.3396097421646118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select two distinct positions to define a segment\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment inversion if it improves the solution\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment inversion\" local search that randomly selects a segment of the tour and reverses its order, while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.974459241964174,
            0.42080992460250854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in node sequences, then applies a \"multi-segment reversal\" local search that reverses multiple non-overlapping segments of the tour to explore diverse structural changes while maintaining feasibility through careful segment selection and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (most unique node sequences)\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    if n > 3:\n        # Determine number of segments to reverse (2-3 segments)\n        num_segments = random.randint(2, min(3, n//2))\n\n        # Generate non-overlapping segments\n        segment_lengths = []\n        remaining = n\n        for _ in range(num_segments-1):\n            seg_len = random.randint(2, remaining - (num_segments - len(segment_lengths)) * 2)\n            segment_lengths.append(seg_len)\n            remaining -= seg_len\n        segment_lengths.append(remaining)\n\n        # Randomly shuffle segments\n        random.shuffle(segment_lengths)\n\n        # Apply segment reversals\n        current_pos = 0\n        for seg_len in segment_lengths:\n            if seg_len > 1:\n                start = current_pos\n                end = current_pos + seg_len\n                new_solution[start:end] = new_solution[start:end][::-1]\n            current_pos += seg_len\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9313865974754305,
            1.0756487250328064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (most unique node sequences)\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    if n > 3:\n        # Determine number of segments to reverse (2-3 segments)\n        num_segments = random.randint(2, min(3, n//2))\n\n        # Generate non-overlapping segments\n        segment_lengths = []\n        remaining = n\n        for _ in range(num_segments-1):\n            seg_len = random.randint(2, remaining - (num_segments - len(segment_lengths)) * 2)\n            segment_lengths.append(seg_len)\n            remaining -= seg_len\n        segment_lengths.append(remaining)\n\n        # Randomly shuffle segments\n        random.shuffle(segment_lengths)\n\n        # Apply segment reversals\n        current_pos = 0\n        for seg_len in segment_lengths:\n            if seg_len > 1:\n                start = current_pos\n                end = current_pos + seg_len\n                new_solution[start:end] = new_solution[start:end][::-1]\n            current_pos += seg_len\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a novel score combining objective values and solution diversity, then applies a hybrid local search combining node inversion and segment reversal to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        score = 0.7 * (obj[0] + obj[1]) + 0.3 * (1.0 / (1.0 + sum(abs(sol - archive[0][0]))))\n        scores.append(score)\n\n    # Select the solution with the lowest score (better balance)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: node inversion and segment reversal\n    if random.random() < 0.5:\n        # Node inversion\n        start = random.randint(0, n - 1)\n        end = random.randint(start, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Segment reversal with rotation\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        segment = new_solution[start:end+1]\n        rotation = random.randint(1, len(segment) - 1)\n        new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = new_segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8558048529141784,
            1.7191023230552673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        score = 0.7 * (obj[0] + obj[1]) + 0.3 * (1.0 / (1.0 + sum(abs(sol - archive[0][0]))))\n        scores.append(score)\n\n    # Select the solution with the lowest score (better balance)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: node inversion and segment reversal\n    if random.random() < 0.5:\n        # Node inversion\n        start = random.randint(0, n - 1)\n        end = random.randint(start, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Segment reversal with rotation\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n        segment = new_solution[start:end+1]\n        rotation = random.randint(1, len(segment) - 1)\n        new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end+1] = new_segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on its non-dominated status, applies a novel local search operator that combines segment reversal and node swapping to explore the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol, _ in archive]\n    if non_dominated:\n        selected_idx = random.randint(0, len(non_dominated) - 1)\n        base_solution = non_dominated[selected_idx].copy()\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8549504750017592,
            0.8606512546539307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol, _ in archive]\n    if non_dominated:\n        selected_idx = random.randint(0, len(non_dominated) - 1)\n        base_solution = non_dominated[selected_idx].copy()\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{The new algorithm identifies promising solutions from the archive by prioritizing those with balanced objective values, then applies a \"cross-space segment inversion\" local search that inverts segments between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    balanced_scores = [(abs(obj[0]/max_obj1 - obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9310184067046237,
            1.0228201150894165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    balanced_scores = [(abs(obj[0]/max_obj1 - obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a combined objective score, then applies a hybrid local search that combines node swapping with a novel segment reversal and insertion strategy to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_score = float('inf')\n    selected_idx = 0\n    for i, (solution, objective) in enumerate(archive):\n        score = sum(objective)  # Combined score\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node insertion\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Select a random node and insert it at a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7455460563968029,
            0.38573169708251953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_score = float('inf')\n    selected_idx = 0\n    for i, (solution, objective) in enumerate(archive):\n        score = sum(objective)  # Combined score\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node insertion\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Select a random node and insert it at a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a combination of objective values and diversity, applies a hybrid local search operator that combines edge swaps and node relocations to explore the solution space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Compute a score for each solution (lower is better)\n        scores = [obj[0] + obj[1] for _, obj in archive]\n        min_score = min(scores)\n        candidates = [i for i, s in enumerate(scores) if s <= min_score * 1.1]  # Allow slight deviation\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: edge swap + node relocation\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Edge swap\n    if j - i > 1:\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node relocation\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9428470031683822,
            0.23476403951644897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Compute a score for each solution (lower is better)\n        scores = [obj[0] + obj[1] for _, obj in archive]\n        min_score = min(scores)\n        candidates = [i for i, s in enumerate(scores) if s <= min_score * 1.1]  # Allow slight deviation\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: edge swap + node relocation\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Edge swap\n    if j - i > 1:\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Node relocation\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a \"multi-segment inversion\" local search that reverses randomly selected segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    std_obj1 = np.std(obj1_values)\n    std_obj2 = np.std(obj2_values)\n    diversity_scores = [std_obj1 * (obj[0] - np.mean(obj1_values)) + std_obj2 * (obj[1] - np.mean(obj2_values)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments don't overlap\n        if b <= c or d <= a:\n            # Reverse the first segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            # Reverse both segments\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6145192451053945,
            5.121521711349487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    std_obj1 = np.std(obj1_values)\n    std_obj2 = np.std(obj2_values)\n    diversity_scores = [std_obj1 * (obj[0] - np.mean(obj1_values)) + std_obj2 * (obj[1] - np.mean(obj2_values)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments don't overlap\n        if b <= c or d <= a:\n            # Reverse the first segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n        else:\n            # Reverse both segments\n            new_solution[a:b] = new_solution[a:b][::-1]\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined improvement potential across both objective spaces, then applies a \"multi-segment crossover and reversal\" local search that combines multiple segment operations while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined improvement potential\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    improvement_scores = [(obj[0]/max_obj1) + (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment crossover and reversal\n    num_segments = random.randint(2, min(4, n//2))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments-1))\n\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    # Reverse segments with probability 0.5\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    # Recombine segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9750263909686352,
            0.4290105104446411
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined improvement potential\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    improvement_scores = [(obj[0]/max_obj1) + (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment crossover and reversal\n    num_segments = random.randint(2, min(4, n//2))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments-1))\n\n    segments = []\n    start = 0\n    for end in segment_indices:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    # Reverse segments with probability 0.5\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    # Recombine segments\n    new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node relocation and edge inversion to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Relocate a randomly selected node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Invert a random segment to explore new configurations\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.943292458004611,
            0.7548456788063049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Relocate a randomly selected node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Invert a random segment to explore new configurations\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a non-dominated solution from the archive, applies a hybrid local search operator that combines segment reversal and node relocation to explore diverse regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        selected_idx = random.randint(0, len(non_dominated) - 1)\n        base_solution = non_dominated[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    new_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8251389170830162,
            0.8971406817436218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        selected_idx = random.randint(0, len(non_dominated) - 1)\n        base_solution = non_dominated[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    new_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on crowding distance in the objective space, applies a hybrid local search combining node relocation and segment inversion to generate a neighbor solution, and ensures feasibility by validating the generated solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: node relocation and segment inversion\n    pos1 = random.randint(0, n - 1)\n    pos2 = random.randint(0, n - 1)\n\n    # Node relocation\n    node = new_solution[pos1]\n    new_solution = np.concatenate([new_solution[:pos1], new_solution[pos1+1:]])\n    new_solution = np.concatenate([new_solution[:pos2], [node], new_solution[pos2:]])\n\n    # Segment inversion\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.698230831787428,
            1.0719777941703796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: node relocation and segment inversion\n    pos1 = random.randint(0, n - 1)\n    pos2 = random.randint(0, n - 1)\n\n    # Node relocation\n    node = new_solution[pos1]\n    new_solution = np.concatenate([new_solution[:pos1], new_solution[pos1+1:]])\n    new_solution = np.concatenate([new_solution[:pos2], [node], new_solution[pos2:]])\n\n    # Segment inversion\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies an \"adaptive k-opt\" local search that dynamically selects between 2-opt and 3-opt moves based on the current solution's characteristics, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    obj1_std = np.std(obj1_values)\n    obj2_std = np.std(obj2_values)\n    diversity_scores = [(obj1_values[i] / obj1_std) + (obj2_values[i] / obj2_std) for i in range(len(objectives))]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt local search\n    if n > 3:\n        # Randomly select between 2-opt and 3-opt\n        k_opt_type = random.choice([2, 3])\n\n        if k_opt_type == 2:\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                # Calculate potential improvement\n                old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_1[new_solution[i], new_solution[j]])\n\n                old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_2[new_solution[i], new_solution[j]])\n\n                improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n                if improvement < 0:\n                    # Reverse the segment between i and j-1\n                    new_solution[i:j] = new_solution[i:j][::-1]\n\n        else:\n            # 3-opt move\n            i, j, k = sorted(random.sample(range(n), 3))\n            if j - i > 1 and k - j > 1:\n                # Calculate potential improvement\n                old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_1[new_solution[i], new_solution[k-1]] +\n                             distance_matrix_1[new_solution[j], new_solution[k]])\n\n                old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_2[new_solution[i], new_solution[k-1]] +\n                             distance_matrix_2[new_solution[j], new_solution[k]])\n\n                improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n                if improvement < 0:\n                    # Apply the 3-opt move\n                    new_solution[i:j] = new_solution[i:j][::-1]\n                    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0351249330946433,
            0.5475942492485046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    obj1_std = np.std(obj1_values)\n    obj2_std = np.std(obj2_values)\n    diversity_scores = [(obj1_values[i] / obj1_std) + (obj2_values[i] / obj2_std) for i in range(len(objectives))]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt local search\n    if n > 3:\n        # Randomly select between 2-opt and 3-opt\n        k_opt_type = random.choice([2, 3])\n\n        if k_opt_type == 2:\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                # Calculate potential improvement\n                old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]])\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_1[new_solution[i], new_solution[j]])\n\n                old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]])\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_2[new_solution[i], new_solution[j]])\n\n                improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n                if improvement < 0:\n                    # Reverse the segment between i and j-1\n                    new_solution[i:j] = new_solution[i:j][::-1]\n\n        else:\n            # 3-opt move\n            i, j, k = sorted(random.sample(range(n), 3))\n            if j - i > 1 and k - j > 1:\n                # Calculate potential improvement\n                old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[k-1], new_solution[k]])\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_1[new_solution[i], new_solution[k-1]] +\n                             distance_matrix_1[new_solution[j], new_solution[k]])\n\n                old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                             distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[k-1], new_solution[k]])\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                             distance_matrix_2[new_solution[i], new_solution[k-1]] +\n                             distance_matrix_2[new_solution[j], new_solution[k]])\n\n                improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n                if improvement < 0:\n                    # Apply the 3-opt move\n                    new_solution[i:j] = new_solution[i:j][::-1]\n                    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment inversion\" local search that inverts segments of the tour while considering the impact on both objective spaces to ensure balanced improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two distinct indices\n        i, j = random.sample(range(n), 2)\n        start, end = min(i, j), max(i, j)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n        # Invert the segment between start and end\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Check if the inversion improves both objectives\n        if (new_cost1 - old_cost1) >= 0 and (new_cost2 - old_cost2) >= 0:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.905560745635818,
            0.816703200340271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two distinct indices\n        i, j = random.sample(range(n), 2)\n        start, end = min(i, j), max(i, j)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n        # Invert the segment between start and end\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Check if the inversion improves both objectives\n        if (new_cost1 - old_cost1) >= 0 and (new_cost2 - old_cost2) >= 0:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest dominance count (number of solutions they dominate), then applies a \"multi-segment inversion and reinsertion\" local search that intelligently inverts multiple non-overlapping segments of the tour and reinserts them at new positions while ensuring feasibility through careful validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest dominance count (simplified proxy)\n    dominance_counts = []\n    for i, (sol1, obj1) in enumerate(archive):\n        count = 0\n        for sol2, obj2 in archive:\n            if obj1[0] < obj2[0] and obj1[1] < obj2[1]:\n                count += 1\n        dominance_counts.append(count)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and reinsertion\n    num_segments = random.randint(1, min(3, n // 2))\n    segments = []\n    positions = []\n\n    # Select non-overlapping segments\n    for _ in range(num_segments):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segments.append((start, end))\n        positions.append(random.randint(0, n - (end - start + 1)))\n\n    # Apply inversions and reinsertions\n    for (start, end), pos in zip(segments, positions):\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        new_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8581003178569211,
            0.8234420418739319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest dominance count (simplified proxy)\n    dominance_counts = []\n    for i, (sol1, obj1) in enumerate(archive):\n        count = 0\n        for sol2, obj2 in archive:\n            if obj1[0] < obj2[0] and obj1[1] < obj2[1]:\n                count += 1\n        dominance_counts.append(count)\n    selected_idx = np.argmax(dominance_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and reinsertion\n    num_segments = random.randint(1, min(3, n // 2))\n    segments = []\n    positions = []\n\n    # Select non-overlapping segments\n    for _ in range(num_segments):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segments.append((start, end))\n        positions.append(random.randint(0, n - (end - start + 1)))\n\n    # Apply inversions and reinsertions\n    for (start, end), pos in zip(segments, positions):\n        segment = new_solution[start:end+1]\n        inverted_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        new_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a score function that balances exploration and exploitation, applies a hybrid local search operator that combines node inversion and segment relocation to explore non-dominated regions, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(solution, objective):\n        return (objective[0] + objective[1]) * (1 + np.random.uniform(0, 0.2))\n\n    scored_archive = [(solution, objective, score(solution, objective)) for solution, objective in archive]\n    scored_archive.sort(key=lambda x: x[2], reverse=True)\n    base_solution = scored_archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a segment to a new position\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n    pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9348023101497384,
            1.2033237218856812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def score(solution, objective):\n        return (objective[0] + objective[1]) * (1 + np.random.uniform(0, 0.2))\n\n    scored_archive = [(solution, objective, score(solution, objective)) for solution, objective in archive]\n    scored_archive.sort(key=lambda x: x[2], reverse=True)\n    base_solution = scored_archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Invert a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a segment to a new position\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, n - 2)\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n    pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{The new algorithm selects a promising solution from the archive, applies a hybrid local search operator that combines node swapping with segment inversion to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select two random nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Select a random segment and invert it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.917532742009409,
            0.38408201932907104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select two random nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Select a random segment and invert it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space path inversion\" local search that reverses segments of the tour while considering the combined impact on both objective spaces, ensuring feasibility through careful boundary checks and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space path inversion\n    if n > 2:\n        # Select a random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+10, n-1))  # Limit segment length for efficiency\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9475756204159853,
            0.49160462617874146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space path inversion\n    if n > 2:\n        # Select a random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, min(start+10, n-1))  # Limit segment length for efficiency\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of its objective values and structural diversity, then applies a hybrid local search combining adaptive segment reversal and intelligent node relocation to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective diversity\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    diversity_scores = [((obj[0]/max_obj1) * (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if n > 3:\n        # Calculate segment reversal potential\n        segment_length = min(5, n-1)\n        start = random.randint(0, n - segment_length - 1)\n        end = start + segment_length\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_1[new_solution[end], new_solution[(end+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[end]] +\n                     distance_matrix_1[new_solution[start], new_solution[(end+1)%n]])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_2[new_solution[end], new_solution[(end+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[end]] +\n                     distance_matrix_2[new_solution[start], new_solution[(end+1)%n]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0 or random.random() < 0.3:  # Allow some non-improving moves\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Intelligent node relocation based on objective correlation\n    if n > 2:\n        # Select node with high objective correlation\n        correlations = []\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            corr = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) / \\\n                  (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] + 1e-6)\n            correlations.append(corr)\n\n        node_idx = np.argmax(correlations)\n        node = new_solution[node_idx]\n\n        # Find best insertion position\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx-1)%n or pos == (node_idx+1)%n:\n                continue\n\n            # Remove node from current position\n            temp_sol = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            prev_node = temp_sol[pos-1] if pos > 0 else temp_sol[-1]\n            next_node = temp_sol[pos] if pos < len(temp_sol) else temp_sol[0]\n\n            # Calculate old cost\n            old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Insert node at new position\n            temp_sol = np.insert(temp_sol, pos, node)\n            prev_node = temp_sol[pos-1] if pos > 0 else temp_sol[-1]\n            next_node = temp_sol[(pos+1)%len(temp_sol)]\n\n            # Calculate new cost\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node from current position\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            # Insert at best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.888317578451263,
            1.4428070783615112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective diversity\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    diversity_scores = [((obj[0]/max_obj1) * (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if n > 3:\n        # Calculate segment reversal potential\n        segment_length = min(5, n-1)\n        start = random.randint(0, n - segment_length - 1)\n        end = start + segment_length\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_1[new_solution[end], new_solution[(end+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[end]] +\n                     distance_matrix_1[new_solution[start], new_solution[(end+1)%n]])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_2[new_solution[end], new_solution[(end+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[end]] +\n                     distance_matrix_2[new_solution[start], new_solution[(end+1)%n]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0 or random.random() < 0.3:  # Allow some non-improving moves\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Intelligent node relocation based on objective correlation\n    if n > 2:\n        # Select node with high objective correlation\n        correlations = []\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n            corr = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]) / \\\n                  (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] + 1e-6)\n            correlations.append(corr)\n\n        node_idx = np.argmax(correlations)\n        node = new_solution[node_idx]\n\n        # Find best insertion position\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx-1)%n or pos == (node_idx+1)%n:\n                continue\n\n            # Remove node from current position\n            temp_sol = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            prev_node = temp_sol[pos-1] if pos > 0 else temp_sol[-1]\n            next_node = temp_sol[pos] if pos < len(temp_sol) else temp_sol[0]\n\n            # Calculate old cost\n            old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Insert node at new position\n            temp_sol = np.insert(temp_sol, pos, node)\n            prev_node = temp_sol[pos-1] if pos > 0 else temp_sol[-1]\n            next_node = temp_sol[(pos+1)%len(temp_sol)]\n\n            # Calculate new cost\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove node from current position\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            # Insert at best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a \"multi-segment inversion and reinsertion\" local search that intelligently inverts segments of the tour and reinserts them at different positions while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and reinsertion\n    # Select two non-overlapping segments\n    seg1_start = random.randint(0, n - 4)\n    seg1_end = random.randint(seg1_start + 1, n - 3)\n    seg2_start = random.randint(seg1_end + 1, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    # Invert both segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n    new_solution[seg1_start:seg1_end+1] = seg1[::-1]\n    new_solution[seg2_start:seg2_end+1] = seg2[::-1]\n\n    # Select a random position to reinsert the first segment\n    reinsert_pos = random.randint(0, n - (seg1_end - seg1_start + 1))\n    reinserted_seg1 = new_solution[seg1_start:seg1_end+1]\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        new_solution[seg1_end+1:reinsert_pos],\n        reinserted_seg1,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6170629283446228,
            0.10027754306793213
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion and reinsertion\n    # Select two non-overlapping segments\n    seg1_start = random.randint(0, n - 4)\n    seg1_end = random.randint(seg1_start + 1, n - 3)\n    seg2_start = random.randint(seg1_end + 1, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    # Invert both segments\n    seg1 = new_solution[seg1_start:seg1_end+1]\n    seg2 = new_solution[seg2_start:seg2_end+1]\n    new_solution[seg1_start:seg1_end+1] = seg1[::-1]\n    new_solution[seg2_start:seg2_end+1] = seg2[::-1]\n\n    # Select a random position to reinsert the first segment\n    reinsert_pos = random.randint(0, n - (seg1_end - seg1_start + 1))\n    reinserted_seg1 = new_solution[seg1_start:seg1_end+1]\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        new_solution[seg1_end+1:reinsert_pos],\n        reinserted_seg1,\n        new_solution[reinsert_pos:]\n    ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This new heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies an \"objective-balanced node insertion\" local search that strategically inserts nodes at positions that balance improvements across both objective spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-balanced node insertion\n    if n > 3:\n        # Select a node to remove and reinsert\n        node_to_move = random.choice(new_solution)\n        temp_solution = [node for node in new_solution if node != node_to_move]\n\n        # Find best insertion position that balances both objectives\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n-1):\n            # Try inserting at position i\n            temp_solution.insert(i, node_to_move)\n\n            # Calculate costs\n            prev_node = temp_solution[i-1] if i > 0 else temp_solution[-1]\n            next_node = temp_solution[(i+1)%(n-1)]\n\n            cost1 = (distance_matrix_1[prev_node, node_to_move] +\n                    distance_matrix_1[node_to_move, next_node])\n            cost2 = (distance_matrix_2[prev_node, node_to_move] +\n                    distance_matrix_2[node_to_move, next_node])\n\n            # Balance score (lower is better)\n            score = (cost1 + cost2) / 2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n            # Remove the node again\n            temp_solution.pop(i)\n\n        if best_pos != -1:\n            # Perform the best insertion\n            new_solution = np.array([node for node in new_solution if node != node_to_move])\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5505757399106443,
            3.750558853149414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-balanced node insertion\n    if n > 3:\n        # Select a node to remove and reinsert\n        node_to_move = random.choice(new_solution)\n        temp_solution = [node for node in new_solution if node != node_to_move]\n\n        # Find best insertion position that balances both objectives\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n-1):\n            # Try inserting at position i\n            temp_solution.insert(i, node_to_move)\n\n            # Calculate costs\n            prev_node = temp_solution[i-1] if i > 0 else temp_solution[-1]\n            next_node = temp_solution[(i+1)%(n-1)]\n\n            cost1 = (distance_matrix_1[prev_node, node_to_move] +\n                    distance_matrix_1[node_to_move, next_node])\n            cost2 = (distance_matrix_2[prev_node, node_to_move] +\n                    distance_matrix_2[node_to_move, next_node])\n\n            # Balance score (lower is better)\n            score = (cost1 + cost2) / 2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n            # Remove the node again\n            temp_solution.pop(i)\n\n        if best_pos != -1:\n            # Perform the best insertion\n            new_solution = np.array([node for node in new_solution if node != node_to_move])\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"multi-segment inversion\" local search that randomly inverts segments of the tour while ensuring feasibility through careful boundary checks and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    # Calculate crowding distances\n    crowding = []\n    for i in range(len(archive)):\n        left = i - 1 if i > 0 else len(archive) - 1\n        right = i + 1 if i < len(archive) - 1 else 0\n        dist = abs(obj1[right] - obj1[left]) + abs(obj2[right] - obj2[left])\n        crowding.append(dist)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n-3)\n        end = random.randint(start+2, n-1)\n\n        # Invert the segment\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8942837955277889,
            0.38083696365356445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    # Calculate crowding distances\n    crowding = []\n    for i in range(len(archive)):\n        left = i - 1 if i > 0 else len(archive) - 1\n        right = i + 1 if i < len(archive) - 1 else 0\n        dist = abs(obj1[right] - obj1[left]) + abs(obj2[right] - obj2[left])\n        crowding.append(dist)\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n-3)\n        end = random.randint(start+2, n-1)\n\n        # Invert the segment\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"cross-space segment inversion\" local search that inverts a random segment of the tour while considering both objective spaces to ensure feasibility and potential improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start, end = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7156751784871731,
            3.682161331176758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a random segment to invert\n        start, end = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"multi-segment inversion\" local search that intelligently inverts segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two distinct segments to invert\n        seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n        seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n\n        # Ensure segments don't overlap\n        if seg1_end <= seg2_start or seg2_end <= seg1_start:\n            # Calculate potential improvement\n            old_cost1 = (distance_matrix_1[new_solution[seg1_start-1], new_solution[seg1_start]] +\n                         distance_matrix_1[new_solution[seg1_end], new_solution[(seg1_end+1)%n]] +\n                         distance_matrix_1[new_solution[seg2_start-1], new_solution[seg2_start]] +\n                         distance_matrix_1[new_solution[seg2_end], new_solution[(seg2_end+1)%n]])\n\n            new_cost1 = (distance_matrix_1[new_solution[seg1_start-1], new_solution[seg1_end]] +\n                         distance_matrix_1[new_solution[seg1_start], new_solution[(seg1_end+1)%n]] +\n                         distance_matrix_1[new_solution[seg2_start-1], new_solution[seg2_end]] +\n                         distance_matrix_1[new_solution[seg2_start], new_solution[(seg2_end+1)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[seg1_start-1], new_solution[seg1_start]] +\n                         distance_matrix_2[new_solution[seg1_end], new_solution[(seg1_end+1)%n]] +\n                         distance_matrix_2[new_solution[seg2_start-1], new_solution[seg2_start]] +\n                         distance_matrix_2[new_solution[seg2_end], new_solution[(seg2_end+1)%n]])\n\n            new_cost2 = (distance_matrix_2[new_solution[seg1_start-1], new_solution[seg1_end]] +\n                         distance_matrix_2[new_solution[seg1_start], new_solution[(seg1_end+1)%n]] +\n                         distance_matrix_2[new_solution[seg2_start-1], new_solution[seg2_end]] +\n                         distance_matrix_2[new_solution[seg2_start], new_solution[(seg2_end+1)%n]])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < 0:\n                # Perform inversion if it improves the solution\n                new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n                new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5464796556997482,
            2.5921146869659424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two distinct segments to invert\n        seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n        seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n\n        # Ensure segments don't overlap\n        if seg1_end <= seg2_start or seg2_end <= seg1_start:\n            # Calculate potential improvement\n            old_cost1 = (distance_matrix_1[new_solution[seg1_start-1], new_solution[seg1_start]] +\n                         distance_matrix_1[new_solution[seg1_end], new_solution[(seg1_end+1)%n]] +\n                         distance_matrix_1[new_solution[seg2_start-1], new_solution[seg2_start]] +\n                         distance_matrix_1[new_solution[seg2_end], new_solution[(seg2_end+1)%n]])\n\n            new_cost1 = (distance_matrix_1[new_solution[seg1_start-1], new_solution[seg1_end]] +\n                         distance_matrix_1[new_solution[seg1_start], new_solution[(seg1_end+1)%n]] +\n                         distance_matrix_1[new_solution[seg2_start-1], new_solution[seg2_end]] +\n                         distance_matrix_1[new_solution[seg2_start], new_solution[(seg2_end+1)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[seg1_start-1], new_solution[seg1_start]] +\n                         distance_matrix_2[new_solution[seg1_end], new_solution[(seg1_end+1)%n]] +\n                         distance_matrix_2[new_solution[seg2_start-1], new_solution[seg2_start]] +\n                         distance_matrix_2[new_solution[seg2_end], new_solution[(seg2_end+1)%n]])\n\n            new_cost2 = (distance_matrix_2[new_solution[seg1_start-1], new_solution[seg1_end]] +\n                         distance_matrix_2[new_solution[seg1_start], new_solution[(seg1_end+1)%n]] +\n                         distance_matrix_2[new_solution[seg2_start-1], new_solution[seg2_end]] +\n                         distance_matrix_2[new_solution[seg2_start], new_solution[(seg2_end+1)%n]])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < 0:\n                # Perform inversion if it improves the solution\n                new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n                new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a novel local search operator that combines segment reversal and node relocation with objective-aware selection to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a node to minimize the combined objective\n    best_pos = -1\n    best_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i <= end:\n            continue\n\n        # Create candidate solution\n        candidate = np.concatenate([new_solution[:i], [new_solution[start]], new_solution[i:]])\n\n        # Calculate combined cost\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        combined_cost = cost1 + cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], [new_solution[start]], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9253801981972727,
            0.5413619875907898
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = min(int(len(archive) * 0.3), len(archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a node to minimize the combined objective\n    best_pos = -1\n    best_cost = float('inf')\n\n    for i in range(n):\n        if i >= start and i <= end:\n            continue\n\n        # Create candidate solution\n        candidate = np.concatenate([new_solution[:i], [new_solution[start]], new_solution[i:]])\n\n        # Calculate combined cost\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        combined_cost = cost1 + cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_pos = i\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], [new_solution[start]], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines segment reversal and node swap to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9275405123767342,
            0.3144720196723938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a diversity-aware score, applies a hybrid local search combining segment reversal and node relocation, and ensures feasibility by validating the neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity score\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(tuple(sorted(pair)) for pair in zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    selected_idx = diversity_scores.index(max(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9327023955899304,
            1.1460725665092468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity score\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(tuple(sorted(pair)) for pair in zip(sol[:-1], sol[1:]))\n        diversity_scores.append(len(unique_pairs))\n    selected_idx = diversity_scores.index(max(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a high-quality solution from the archive, applies a hybrid local search operator that combines edge exchange and node reinsertion to explore the bi-objective space, and ensures feasibility by validating the neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Edge exchange between two random segments\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 2: Reinsert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8119074216281972,
            0.07537323236465454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Edge exchange between two random segments\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 2: Reinsert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This heuristic selects a solution from the archive based on the highest combined normalized objective values, then applies a \"segment inversion with cross-space validation\" local search that reverses a random segment of the tour while ensuring feasibility and potential improvement in both objective spaces through careful distance calculation and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 3:\n        # Select a random segment to invert\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8250732774523145,
            0.28925102949142456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 3:\n        # Select a random segment to invert\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"multi-segment inversion\" local search that randomly selects a segment of the tour and reverses its order while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Randomly select start and end indices for segment inversion\n        start, end = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6510226488559833,
            3.740803360939026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Randomly select start and end indices for segment inversion\n        start, end = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a novel local search operator that combines node swapping with a probabilistic segment reversal to explore diverse regions in the bi-objective space, ensuring feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 0:\n        weights = 1 / (objectives.sum(axis=1) + 1e-10)\n        weights /= weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistically reverse a segment\n    if random.random() < 0.5:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9252278280962882,
            0.3408372402191162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 0:\n        weights = 1 / (objectives.sum(axis=1) + 1e-10)\n        weights /= weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Swap two random nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Probabilistically reverse a segment\n    if random.random() < 0.5:\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with balanced improvement potential in both objectives, then applies a \"cross-space segment reversal\" local search that reverses segments between the two objective spaces while carefully validating and repairing the solution to maintain feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced improvement potential\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = sum(obj[0] for obj in objectives) / len(objectives)\n    avg_obj2 = sum(obj[1] for obj in objectives) / len(objectives)\n    scores = [abs((obj[0] - avg_obj1) / avg_obj1) + abs((obj[1] - avg_obj2) / avg_obj2) for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start - 1]\n        next_end = new_solution[(end + 1) % n]\n        segment = new_solution[start:end+1]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, segment[0]] + distance_matrix_1[segment[-1], next_end]\n        new_cost1 = distance_matrix_1[prev_start, segment[-1]] + distance_matrix_1[segment[0], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, segment[0]] + distance_matrix_2[segment[-1], next_end]\n        new_cost2 = distance_matrix_2[prev_start, segment[-1]] + distance_matrix_2[segment[0], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment reversal if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8276219356943832,
            0.37062597274780273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with balanced improvement potential\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = sum(obj[0] for obj in objectives) / len(objectives)\n    avg_obj2 = sum(obj[1] for obj in objectives) / len(objectives)\n    scores = [abs((obj[0] - avg_obj1) / avg_obj1) + abs((obj[1] - avg_obj2) / avg_obj2) for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to reverse\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 2)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start - 1]\n        next_end = new_solution[(end + 1) % n]\n        segment = new_solution[start:end+1]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, segment[0]] + distance_matrix_1[segment[-1], next_end]\n        new_cost1 = distance_matrix_1[prev_start, segment[-1]] + distance_matrix_1[segment[0], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, segment[0]] + distance_matrix_2[segment[-1], next_end]\n        new_cost2 = distance_matrix_2[prev_start, segment[-1]] + distance_matrix_2[segment[0], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform segment reversal if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"cross-space node insertion\" local search that intelligently reinserts nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 2:\n        # Select a node to reinsert\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n\n        # Find insertion position that minimizes both objectives\n        best_pos = 0\n        best_improvement = float('inf')\n\n        for pos in range(n-1):\n            # Calculate potential improvement\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = (distance_matrix_1[prev, node] +\n                         distance_matrix_1[node, next_node])\n            new_cost1 = (distance_matrix_1[prev, next_node])\n\n            # For second objective space\n            old_cost2 = (distance_matrix_2[prev, node] +\n                         distance_matrix_2[node, next_node])\n            new_cost2 = (distance_matrix_2[prev, next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8575665131404303,
            0.4269549250602722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 2:\n        # Select a node to reinsert\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, i)\n\n        # Find insertion position that minimizes both objectives\n        best_pos = 0\n        best_improvement = float('inf')\n\n        for pos in range(n-1):\n            # Calculate potential improvement\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = (distance_matrix_1[prev, node] +\n                         distance_matrix_1[node, next_node])\n            new_cost1 = (distance_matrix_1[prev, next_node])\n\n            # For second objective space\n            old_cost2 = (distance_matrix_2[prev, node] +\n                         distance_matrix_2[node, next_node])\n            new_cost2 = (distance_matrix_2[prev, next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment reversal\" local search that reverses segments of nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[j], next_j]\n        new_cost1 = distance_matrix_1[prev_i, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_j]\n\n        old_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[j], next_j]\n        new_cost2 = distance_matrix_2[prev_i, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            new_solution[i:j+1] = reversed_segment\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9819018251829906,
            0.56102454662323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[j], next_j]\n        new_cost1 = distance_matrix_1[prev_i, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_j]\n\n        old_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[j], next_j]\n        new_cost2 = distance_matrix_2[prev_i, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            new_solution[i:j+1] = reversed_segment\n\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"segment inversion with cross-space validation\" local search that inverts a random segment of the tour while ensuring feasibility through careful validation and repair mechanisms, considering both objective spaces simultaneously to maintain solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 2:\n        # Select random segment to invert\n        start = random.randint(0, n-1)\n        length = random.randint(2, min(5, n-1))\n        end = (start + length) % n\n\n        if start < end:\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n        else:\n            segment1 = new_solution[start:]\n            segment2 = new_solution[:end]\n            new_solution = np.concatenate([segment1[::-1], new_solution[end:start], segment2[::-1]])\n\n        # Validate the new solution\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9180835452857293,
            0.2984545826911926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 2:\n        # Select random segment to invert\n        start = random.randint(0, n-1)\n        length = random.randint(2, min(5, n-1))\n        end = (start + length) % n\n\n        if start < end:\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n        else:\n            segment1 = new_solution[start:]\n            segment2 = new_solution[:end]\n            new_solution = np.concatenate([segment1[::-1], new_solution[end:start], segment2[::-1]])\n\n        # Validate the new solution\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a combination of crowding distance and dominance rank, then applies a novel local search operator that combines segment reversal with a biased node swap to explore the Pareto front more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    if len(archive_objectives) > 2:\n        crowding = np.zeros(len(archive_objectives))\n        objectives = np.array(archive_objectives)\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive_objectives) - 1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Biased node swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    obj_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n    obj_after = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                 distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n    if obj_after < obj_before:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6135201072783076,
            0.5067853331565857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances\n    if len(archive_objectives) > 2:\n        crowding = np.zeros(len(archive_objectives))\n        objectives = np.array(archive_objectives)\n        for m in range(2):\n            sorted_indices = np.argsort(objectives[:, m])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive_objectives) - 1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Biased node swap based on objective improvement\n    i, j = random.sample(range(n), 2)\n    obj_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n    obj_after = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                 distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n    if obj_after < obj_before:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment relocation with cross-space validation\" local search that intelligently relocates multiple segments between nodes in different objective spaces while ensuring feasibility through careful segment validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment relocation with cross-space validation\n    num_segments = random.randint(1, min(3, n//2))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments*2))\n\n    for i in range(0, len(segment_indices), 2):\n        start = segment_indices[i]\n        end = segment_indices[i+1]\n\n        if start >= end:\n            continue\n\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement for both objectives\n        old_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_1[new_solution[end], new_solution[(end+1)%n]])\n        old_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_2[new_solution[end], new_solution[(end+1)%n]])\n\n        # Try inserting segment at a new random position\n        new_pos = random.randint(0, n-1)\n        if new_pos > start and new_pos < end:\n            continue\n\n        if new_pos < start:\n            new_cost1 = (distance_matrix_1[new_solution[new_pos-1], new_solution[start]] +\n                         distance_matrix_1[new_solution[end], new_solution[(end+1)%n]] +\n                         distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]])\n            new_cost2 = (distance_matrix_2[new_solution[new_pos-1], new_solution[start]] +\n                         distance_matrix_2[new_solution[end], new_solution[(end+1)%n]] +\n                         distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]])\n        else:\n            new_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                         distance_matrix_1[new_solution[end], new_solution[new_pos]] +\n                         distance_matrix_1[new_solution[new_pos], new_solution[(new_pos+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                         distance_matrix_2[new_solution[end], new_solution[new_pos]] +\n                         distance_matrix_2[new_solution[new_pos], new_solution[(new_pos+1)%n]])\n\n        if (new_cost1 - old_cost1) + (new_cost2 - old_cost2) < 0:\n            # Perform relocation if it improves both objectives\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[end+1:new_pos+1],\n                segment,\n                new_solution[new_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.949329908772416,
            0.3808645009994507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment relocation with cross-space validation\n    num_segments = random.randint(1, min(3, n//2))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments*2))\n\n    for i in range(0, len(segment_indices), 2):\n        start = segment_indices[i]\n        end = segment_indices[i+1]\n\n        if start >= end:\n            continue\n\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement for both objectives\n        old_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_1[new_solution[end], new_solution[(end+1)%n]])\n        old_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                     distance_matrix_2[new_solution[end], new_solution[(end+1)%n]])\n\n        # Try inserting segment at a new random position\n        new_pos = random.randint(0, n-1)\n        if new_pos > start and new_pos < end:\n            continue\n\n        if new_pos < start:\n            new_cost1 = (distance_matrix_1[new_solution[new_pos-1], new_solution[start]] +\n                         distance_matrix_1[new_solution[end], new_solution[(end+1)%n]] +\n                         distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]])\n            new_cost2 = (distance_matrix_2[new_solution[new_pos-1], new_solution[start]] +\n                         distance_matrix_2[new_solution[end], new_solution[(end+1)%n]] +\n                         distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]])\n        else:\n            new_cost1 = (distance_matrix_1[new_solution[start-1], new_solution[start]] +\n                         distance_matrix_1[new_solution[end], new_solution[new_pos]] +\n                         distance_matrix_1[new_solution[new_pos], new_solution[(new_pos+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[start-1], new_solution[start]] +\n                         distance_matrix_2[new_solution[end], new_solution[new_pos]] +\n                         distance_matrix_2[new_solution[new_pos], new_solution[(new_pos+1)%n]])\n\n        if (new_cost1 - old_cost1) + (new_cost2 - old_cost2) < 0:\n            # Perform relocation if it improves both objectives\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[end+1:new_pos+1],\n                segment,\n                new_solution[new_pos+1:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This heuristic selects a solution from the archive based on a novel combination of objective diversity and solution structure, then applies a multi-segment inversion and cross-space node relocation strategy to generate high-quality neighbors while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective diversity\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment inversion\n        num_segments = random.randint(2, min(4, n//2))\n        segment_indices = sorted(random.sample(range(1, n-1), num_segments-1))\n        segments = np.split(new_solution, segment_indices)\n        for seg in segments:\n            if len(seg) > 1:\n                seg[:] = seg[::-1]\n\n        # Cross-space node relocation\n        if n > 4:\n            i = random.randint(1, n-2)\n            j = random.randint(1, n-2)\n            while j == i:\n                j = random.randint(1, n-2)\n\n            # Calculate potential improvement\n            prev_i = new_solution[i-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[(j+1)%n]\n\n            # For first objective space\n            old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                         distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] +\n                         distance_matrix_1[new_solution[j], next_j])\n\n            new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                         distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] +\n                         distance_matrix_1[new_solution[i], next_j])\n\n            # For second objective space\n            old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                         distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] +\n                         distance_matrix_2[new_solution[j], next_j])\n\n            new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                         distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] +\n                         distance_matrix_2[new_solution[i], next_j])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < 0 or random.random() < 0.3:  # Accept with some probability\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8582648780800015,
            0.40694451332092285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective diversity\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment inversion\n        num_segments = random.randint(2, min(4, n//2))\n        segment_indices = sorted(random.sample(range(1, n-1), num_segments-1))\n        segments = np.split(new_solution, segment_indices)\n        for seg in segments:\n            if len(seg) > 1:\n                seg[:] = seg[::-1]\n\n        # Cross-space node relocation\n        if n > 4:\n            i = random.randint(1, n-2)\n            j = random.randint(1, n-2)\n            while j == i:\n                j = random.randint(1, n-2)\n\n            # Calculate potential improvement\n            prev_i = new_solution[i-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[(j+1)%n]\n\n            # For first objective space\n            old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                         distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] +\n                         distance_matrix_1[new_solution[j], next_j])\n\n            new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                         distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] +\n                         distance_matrix_1[new_solution[i], next_j])\n\n            # For second objective space\n            old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                         distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] +\n                         distance_matrix_2[new_solution[j], next_j])\n\n            new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                         distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] +\n                         distance_matrix_2[new_solution[i], next_j])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < 0 or random.random() < 0.3:  # Accept with some probability\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a segment inversion and node reinsertion hybrid operator that intelligently flips a segment of the tour and reinserts nodes to explore new regions of the bi-objective space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution based on both objective diversity and quality\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) * (1 + abs(obj[0] - obj[1])/max(max_obj1, max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Segment inversion with node reinsertion\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]  # Invert the segment\n\n    # Reinsert nodes to maintain feasibility\n    nodes_to_reinsert = []\n    for i in range(n):\n        if np.sum(new_solution == new_solution[i]) > 1:\n            nodes_to_reinsert.append(new_solution[i])\n            new_solution[i] = -1  # Mark as to be replaced\n\n    for node in nodes_to_reinsert:\n        valid_positions = [i for i in range(n) if new_solution[i] == -1]\n        if valid_positions:\n            pos = random.choice(valid_positions)\n            new_solution[pos] = node\n\n    # Ensure all nodes are present\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5258599383672669,
            0.5377627015113831
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution based on both objective diversity and quality\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) * (1 + abs(obj[0] - obj[1])/max(max_obj1, max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Segment inversion with node reinsertion\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]  # Invert the segment\n\n    # Reinsert nodes to maintain feasibility\n    nodes_to_reinsert = []\n    for i in range(n):\n        if np.sum(new_solution == new_solution[i]) > 1:\n            nodes_to_reinsert.append(new_solution[i])\n            new_solution[i] = -1  # Mark as to be replaced\n\n    for node in nodes_to_reinsert:\n        valid_positions = [i for i in range(n) if new_solution[i] == -1]\n        if valid_positions:\n            pos = random.choice(valid_positions)\n            new_solution[pos] = node\n\n    # Ensure all nodes are present\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node reversal and segment swapping to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = (0.5, 0.5)  # Equal weights for both objectives\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Randomly reverse a segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Randomly swap two non-adjacent segments\n    split1 = random.randint(1, n - 2)\n    split2 = random.randint(split1 + 1, n - 1)\n    segment1 = new_solution[:split1]\n    segment2 = new_solution[split1:split2]\n    segment3 = new_solution[split2:]\n    new_solution = np.concatenate([segment1, segment3, segment2])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8886648963634102,
            0.43631625175476074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = (0.5, 0.5)  # Equal weights for both objectives\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0]\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Randomly reverse a segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Randomly swap two non-adjacent segments\n    split1 = random.randint(1, n - 2)\n    split2 = random.randint(split1 + 1, n - 1)\n    segment1 = new_solution[:split1]\n    segment2 = new_solution[split1:split2]\n    segment3 = new_solution[split2:]\n    new_solution = np.concatenate([segment1, segment3, segment2])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"segment inversion with cross-space validation\" local search that inverts a random segment of the tour while ensuring feasibility through careful cross-space distance checks and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n    sorted_obj1 = sorted(obj1)\n    sorted_obj2 = sorted(obj2)\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        obj1_val = objectives[i][0]\n        obj2_val = objectives[i][1]\n\n        # Calculate crowding distance\n        idx1 = sorted_obj1.index(obj1_val)\n        idx2 = sorted_obj2.index(obj2_val)\n\n        dist1 = (sorted_obj1[min(idx1+1, len(sorted_obj1)-1)] - sorted_obj1[max(idx1-1, 0)]) if len(sorted_obj1) > 1 else 0\n        dist2 = (sorted_obj2[min(idx2+1, len(sorted_obj2)-1)] - sorted_obj2[max(idx2-1, 0)]) if len(sorted_obj2) > 1 else 0\n\n        crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 2:\n        # Select random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7390676392446924,
            1.236833095550537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n    sorted_obj1 = sorted(obj1)\n    sorted_obj2 = sorted(obj2)\n\n    crowding_distances = []\n    for i in range(len(objectives)):\n        obj1_val = objectives[i][0]\n        obj2_val = objectives[i][1]\n\n        # Calculate crowding distance\n        idx1 = sorted_obj1.index(obj1_val)\n        idx2 = sorted_obj2.index(obj2_val)\n\n        dist1 = (sorted_obj1[min(idx1+1, len(sorted_obj1)-1)] - sorted_obj1[max(idx1-1, 0)]) if len(sorted_obj1) > 1 else 0\n        dist2 = (sorted_obj2[min(idx2+1, len(sorted_obj2)-1)] - sorted_obj2[max(idx2-1, 0)]) if len(sorted_obj2) > 1 else 0\n\n        crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with cross-space validation\n    if n > 2:\n        # Select random segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest sum of normalized objective values and applies a \"multi-segment inversion\" local search that randomly inverts segments of the tour while ensuring feasibility through validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest sum of normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [(obj[0]/max_obj1) + (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two random points to define segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Determine segment boundaries\n        start1, end1 = min(a, b), max(a, b)\n        start2, end2 = min(c, d), max(c, d)\n\n        # Ensure segments are distinct\n        if start1 != start2 or end1 != end2:\n            # Calculate old and new costs for each objective\n            old_cost1 = (distance_matrix_1[new_solution[start1-1], new_solution[start1]] +\n                         distance_matrix_1[new_solution[end1], new_solution[(end1+1)%n]] +\n                         distance_matrix_1[new_solution[start2-1], new_solution[start2]] +\n                         distance_matrix_1[new_solution[end2], new_solution[(end2+1)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[start1-1], new_solution[start1]] +\n                         distance_matrix_2[new_solution[end1], new_solution[(end1+1)%n]] +\n                         distance_matrix_2[new_solution[start2-1], new_solution[start2]] +\n                         distance_matrix_2[new_solution[end2], new_solution[(end2+1)%n]])\n\n            # Invert segments\n            new_solution[start1:end1+1] = new_solution[start1:end1+1][::-1]\n            new_solution[start2:end2+1] = new_solution[start2:end2+1][::-1]\n\n            new_cost1 = (distance_matrix_1[new_solution[start1-1], new_solution[start1]] +\n                         distance_matrix_1[new_solution[end1], new_solution[(end1+1)%n]] +\n                         distance_matrix_1[new_solution[start2-1], new_solution[start2]] +\n                         distance_matrix_1[new_solution[end2], new_solution[(end2+1)%n]])\n\n            new_cost2 = (distance_matrix_2[new_solution[start1-1], new_solution[start1]] +\n                         distance_matrix_2[new_solution[end1], new_solution[(end1+1)%n]] +\n                         distance_matrix_2[new_solution[start2-1], new_solution[start2]] +\n                         distance_matrix_2[new_solution[end2], new_solution[(end2+1)%n]])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement >= 0:\n                # Revert if no improvement\n                new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9740046602714273,
            0.4007417559623718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest sum of normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [(obj[0]/max_obj1) + (obj[1]/max_obj2) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select two random points to define segments\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Determine segment boundaries\n        start1, end1 = min(a, b), max(a, b)\n        start2, end2 = min(c, d), max(c, d)\n\n        # Ensure segments are distinct\n        if start1 != start2 or end1 != end2:\n            # Calculate old and new costs for each objective\n            old_cost1 = (distance_matrix_1[new_solution[start1-1], new_solution[start1]] +\n                         distance_matrix_1[new_solution[end1], new_solution[(end1+1)%n]] +\n                         distance_matrix_1[new_solution[start2-1], new_solution[start2]] +\n                         distance_matrix_1[new_solution[end2], new_solution[(end2+1)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[start1-1], new_solution[start1]] +\n                         distance_matrix_2[new_solution[end1], new_solution[(end1+1)%n]] +\n                         distance_matrix_2[new_solution[start2-1], new_solution[start2]] +\n                         distance_matrix_2[new_solution[end2], new_solution[(end2+1)%n]])\n\n            # Invert segments\n            new_solution[start1:end1+1] = new_solution[start1:end1+1][::-1]\n            new_solution[start2:end2+1] = new_solution[start2:end2+1][::-1]\n\n            new_cost1 = (distance_matrix_1[new_solution[start1-1], new_solution[start1]] +\n                         distance_matrix_1[new_solution[end1], new_solution[(end1+1)%n]] +\n                         distance_matrix_1[new_solution[start2-1], new_solution[start2]] +\n                         distance_matrix_1[new_solution[end2], new_solution[(end2+1)%n]])\n\n            new_cost2 = (distance_matrix_2[new_solution[start1-1], new_solution[start1]] +\n                         distance_matrix_2[new_solution[end1], new_solution[(end1+1)%n]] +\n                         distance_matrix_2[new_solution[start2-1], new_solution[start2]] +\n                         distance_matrix_2[new_solution[end2], new_solution[(end2+1)%n]])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement >= 0:\n                # Revert if no improvement\n                new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm selects a solution from the archive based on the worst objective values to explore underperforming regions, then applies a \"cross-space segment inversion\" local search that reverses a segment of nodes while considering both objective spaces to potentially uncover improved solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with worst normalized objective values to explore underperforming regions\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a segment to reverse\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7742566503354497,
            4.690423250198364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with worst normalized objective values to explore underperforming regions\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a segment to reverse\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment reordering\" local search that randomly selects a segment of the tour, reverses its order, and evaluates the improvement across both objective spaces before committing to the change if it shows promise.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Randomly select segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate old cost\n        old_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        # Reverse the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Calculate new cost\n        new_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        # Check improvement\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9764844856797623,
            0.49359989166259766
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Randomly select segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate old cost\n        old_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        # Reverse the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Calculate new cost\n        new_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        # Check improvement\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"cross-space node insertion\" local search that strategically reinserts nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 2:\n        # Select a node to insert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at a new position\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n        # Calculate potential improvement\n        prev_node = new_solution[new_pos-1]\n        next_node = new_solution[(new_pos+1)%(n-1)]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        new_cost1 = distance_matrix_1[prev_node, next_node]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        new_cost2 = distance_matrix_2[prev_node, next_node]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement > 0:\n            # Revert insertion if it worsens the solution\n            new_solution = np.delete(new_solution, new_pos)\n            new_solution = np.insert(new_solution, node_idx, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8237938329026738,
            0.462507426738739
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node insertion\n    if n > 2:\n        # Select a node to insert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at a new position\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n        # Calculate potential improvement\n        prev_node = new_solution[new_pos-1]\n        next_node = new_solution[(new_pos+1)%(n-1)]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        new_cost1 = distance_matrix_1[prev_node, next_node]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        new_cost2 = distance_matrix_2[prev_node, next_node]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement > 0:\n            # Revert insertion if it worsens the solution\n            new_solution = np.delete(new_solution, new_pos)\n            new_solution = np.insert(new_solution, node_idx, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of crowding distance and objective diversity, then applies a \"multi-segment reversal\" local search that reverses multiple non-adjacent segments in the tour to explore diverse regions of the bi-objective space while ensuring feasibility through careful validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance and objective diversity\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    # Calculate crowding distances\n    crowding = []\n    for i in range(len(objectives)):\n        left = right = None\n        for j in range(len(objectives)):\n            if objectives[j][0] < objectives[i][0] and objectives[j][1] < objectives[i][1]:\n                left = j\n            if objectives[j][0] > objectives[i][0] and objectives[j][1] > objectives[i][1]:\n                right = j\n        if left is None or right is None:\n            crowding.append(float('inf'))\n        else:\n            crowding.append(abs(objectives[right][0] - objectives[left][0]) + abs(objectives[right][1] - objectives[left][1]))\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal\n    if n > 3:\n        # Select multiple non-adjacent segments to reverse\n        num_segments = random.randint(1, min(3, n//4))\n        selected_segments = []\n\n        for _ in range(num_segments):\n            start = random.randint(0, n - 2)\n            end = random.randint(start + 1, min(start + n//4, n - 1))\n            selected_segments.append((start, end))\n\n        # Sort segments by start position\n        selected_segments.sort()\n\n        # Reverse each selected segment\n        for start, end in selected_segments:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.812285831641131,
            0.5768356323242188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance and objective diversity\n    objectives = [obj for _, obj in archive]\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    # Calculate crowding distances\n    crowding = []\n    for i in range(len(objectives)):\n        left = right = None\n        for j in range(len(objectives)):\n            if objectives[j][0] < objectives[i][0] and objectives[j][1] < objectives[i][1]:\n                left = j\n            if objectives[j][0] > objectives[i][0] and objectives[j][1] > objectives[i][1]:\n                right = j\n        if left is None or right is None:\n            crowding.append(float('inf'))\n        else:\n            crowding.append(abs(objectives[right][0] - objectives[left][0]) + abs(objectives[right][1] - objectives[left][1]))\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-segment reversal\n    if n > 3:\n        # Select multiple non-adjacent segments to reverse\n        num_segments = random.randint(1, min(3, n//4))\n        selected_segments = []\n\n        for _ in range(num_segments):\n            start = random.randint(0, n - 2)\n            end = random.randint(start + 1, min(start + n//4, n - 1))\n            selected_segments.append((start, end))\n\n        # Sort segments by start position\n        selected_segments.sort()\n\n        # Reverse each selected segment\n        for start, end in selected_segments:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node swapping and segment reversal to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select two random positions and swap the nodes\n    pos1, pos2 = random.sample(range(n), 2)\n    new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9490560595537095,
            0.5010789632797241
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select two random positions and swap the nodes\n    pos1, pos2 = random.sample(range(n), 2)\n    new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a non-dominated solution from the archive, applies a hybrid local search operator that combines edge swapping and segment reversal to explore the Pareto front, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Swap two edges to diversify the solution\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6845536519661961,
            0.45569223165512085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 2: Swap two edges to diversify the solution\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their objective values, then applies a \"multi-segment reversal and insertion\" local search that intelligently combines segment reversals with node insertions to explore the solution space while ensuring feasibility through careful validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select multiple random segments and reverse them\n    num_segments = random.randint(1, min(3, n//2))\n    for _ in range(num_segments):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert nodes at new positions based on their spatial proximity\n    for i in range(n):\n        node = new_solution[i]\n        coords = instance[node]\n        # Find the most distant node in the solution\n        distances = [np.sqrt((coords[0]-instance[n][0])**2 + (coords[1]-instance[n][1])**2 +\n                            (coords[2]-instance[n][2])**2 + (coords[3]-instance[n][3])**2)\n                     for n in new_solution]\n        farthest_node = new_solution[np.argmax(distances)]\n        farthest_idx = np.where(new_solution == farthest_node)[0][0]\n        # Insert node after the farthest node\n        new_solution = np.concatenate([new_solution[:farthest_idx+1], [node], new_solution[farthest_idx+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9868566749132723,
            3.850038170814514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select multiple random segments and reverse them\n    num_segments = random.randint(1, min(3, n//2))\n    for _ in range(num_segments):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert nodes at new positions based on their spatial proximity\n    for i in range(n):\n        node = new_solution[i]\n        coords = instance[node]\n        # Find the most distant node in the solution\n        distances = [np.sqrt((coords[0]-instance[n][0])**2 + (coords[1]-instance[n][1])**2 +\n                            (coords[2]-instance[n][2])**2 + (coords[3]-instance[n][3])**2)\n                     for n in new_solution]\n        farthest_node = new_solution[np.argmax(distances)]\n        farthest_idx = np.where(new_solution == farthest_node)[0][0]\n        # Insert node after the farthest node\n        new_solution = np.concatenate([new_solution[:farthest_idx+1], [node], new_solution[farthest_idx+1:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in objective space, then applies a \"segment inversion with adaptive range\" local search that inverts a randomly sized segment of the tour while ensuring feasibility and potentially improving both objectives through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distance for each solution\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(obj[0] for obj in objectives)\n    sorted_obj2 = sorted(obj[1] for obj in objectives)\n\n    crowding_distances = []\n    for obj in objectives:\n        idx1 = sorted_obj1.index(obj[0])\n        idx2 = sorted_obj2.index(obj[1])\n\n        if idx1 == 0 or idx1 == len(sorted_obj1)-1:\n            dist1 = float('inf')\n        else:\n            dist1 = sorted_obj1[idx1+1] - sorted_obj1[idx1-1]\n\n        if idx2 == 0 or idx2 == len(sorted_obj2)-1:\n            dist2 = float('inf')\n        else:\n            dist2 = sorted_obj2[idx2+1] - sorted_obj2[idx2-1]\n\n        crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive range\n    if n > 2:\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n\n        # Calculate potential improvement\n        prev = new_solution[start-1]\n        next_ = new_solution[(start+segment_length)%n]\n\n        old_cost1 = distance_matrix_1[prev, new_solution[start]] + distance_matrix_1[new_solution[start+segment_length-1], next_]\n        old_cost2 = distance_matrix_2[prev, new_solution[start]] + distance_matrix_2[new_solution[start+segment_length-1], next_]\n\n        # Invert the segment\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        new_cost1 = distance_matrix_1[prev, new_solution[start]] + distance_matrix_1[new_solution[start+segment_length-1], next_]\n        new_cost2 = distance_matrix_2[prev, new_solution[start]] + distance_matrix_2[new_solution[start+segment_length-1], next_]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:start+segment_length] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7260648308923574,
            0.7339799404144287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distance for each solution\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(obj[0] for obj in objectives)\n    sorted_obj2 = sorted(obj[1] for obj in objectives)\n\n    crowding_distances = []\n    for obj in objectives:\n        idx1 = sorted_obj1.index(obj[0])\n        idx2 = sorted_obj2.index(obj[1])\n\n        if idx1 == 0 or idx1 == len(sorted_obj1)-1:\n            dist1 = float('inf')\n        else:\n            dist1 = sorted_obj1[idx1+1] - sorted_obj1[idx1-1]\n\n        if idx2 == 0 or idx2 == len(sorted_obj2)-1:\n            dist2 = float('inf')\n        else:\n            dist2 = sorted_obj2[idx2+1] - sorted_obj2[idx2-1]\n\n        crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive range\n    if n > 2:\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n-segment_length)\n\n        # Calculate potential improvement\n        prev = new_solution[start-1]\n        next_ = new_solution[(start+segment_length)%n]\n\n        old_cost1 = distance_matrix_1[prev, new_solution[start]] + distance_matrix_1[new_solution[start+segment_length-1], next_]\n        old_cost2 = distance_matrix_2[prev, new_solution[start]] + distance_matrix_2[new_solution[start+segment_length-1], next_]\n\n        # Invert the segment\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        new_cost1 = distance_matrix_1[prev, new_solution[start]] + distance_matrix_1[new_solution[start+segment_length-1], next_]\n        new_cost2 = distance_matrix_2[prev, new_solution[start]] + distance_matrix_2[new_solution[start+segment_length-1], next_]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution[start:start+segment_length] = segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a hybrid score combining dominance rank and objective diversity, applies a novel local search operator that combines segment reversal and node swap with position bias, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    ranks = [sum(1 for o in objectives if (o[0] <= obj[0] and o[1] < obj[1]) or (o[0] < obj[0] and o[1] <= obj[1])) for obj in objectives]\n    diversity_scores = [np.std([obj[0] - o[0] for o in objectives] + [obj[1] - o[1] for o in objectives]) for obj in objectives]\n    combined_scores = [ranks[i] * diversity_scores[i] for i in range(len(archive))]\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search operator\n    # Step 1: Segment reversal with position bias\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    bias = random.random()\n    if bias > 0.5:\n        new_solution[start:end+1] = segment[::-1]\n    else:\n        # Step 2: Node swap with position bias\n        i, j = random.randint(0, n - 1), random.randint(0, n - 1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.865605047777157,
            12.901305556297302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    ranks = [sum(1 for o in objectives if (o[0] <= obj[0] and o[1] < obj[1]) or (o[0] < obj[0] and o[1] <= obj[1])) for obj in objectives]\n    diversity_scores = [np.std([obj[0] - o[0] for o in objectives] + [obj[1] - o[1] for o in objectives]) for obj in objectives]\n    combined_scores = [ranks[i] * diversity_scores[i] for i in range(len(archive))]\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search operator\n    # Step 1: Segment reversal with position bias\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    bias = random.random()\n    if bias > 0.5:\n        new_solution[start:end+1] = segment[::-1]\n    else:\n        # Step 2: Node swap with position bias\n        i, j = random.randint(0, n - 1), random.randint(0, n - 1)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This new heuristic selects solutions from the archive by prioritizing those with the highest diversity in their objective values, then applies a \"multi-objective path relinking\" local search that intelligently combines segments from different solutions while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path relinking\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Extract segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Replace segment1 with segment2\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b+1:]\n        ])\n\n        # Repair to ensure feasibility\n        missing = set(range(n)) - set(new_solution)\n        extra = set(new_solution) - set(range(n))\n        if missing or extra:\n            # Find positions to insert missing nodes\n            for node in missing:\n                pos = random.choice(range(len(new_solution)))\n                new_solution = np.insert(new_solution, pos, node)\n            # Remove extra nodes\n            for node in extra:\n                new_solution = new_solution[new_solution != node]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8374670530441841,
            2.326797068119049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n    diversity_scores = [abs(obj[0] - mean_obj1) + abs(obj[1] - mean_obj2) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path relinking\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Extract segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n\n        # Replace segment1 with segment2\n        new_solution = np.concatenate([\n            new_solution[:a],\n            segment2,\n            new_solution[b+1:]\n        ])\n\n        # Repair to ensure feasibility\n        missing = set(range(n)) - set(new_solution)\n        extra = set(new_solution) - set(range(n))\n        if missing or extra:\n            # Find positions to insert missing nodes\n            for node in missing:\n                pos = random.choice(range(len(new_solution)))\n                new_solution = np.insert(new_solution, pos, node)\n            # Remove extra nodes\n            for node in extra:\n                new_solution = new_solution[new_solution != node]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a non-dominated solution from the archive, applies a hybrid local search operator that combines node relocation and segment reversal to explore diverse regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                if not np.array_equal(sol, other_sol):\n                    dominated = True\n                    break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        selected_idx = random.randint(0, len(non_dominated) - 1)\n        base_solution = non_dominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8831523796748401,
            0.4246024489402771
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                if not np.array_equal(sol, other_sol):\n                    dominated = True\n                    break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        base_solution = archive[0][0].copy()\n    else:\n        selected_idx = random.randint(0, len(non_dominated) - 1)\n        base_solution = non_dominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Relocate a random node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in the objective space, then applies a \"multi-segment reversal and insertion\" local search that systematically reverses multiple segments and reinserts them at new positions while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    min_obj1 = min(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n\n    diversity_scores = [(abs(obj[0] - max_obj1) + abs(obj[0] - min_obj1) + abs(obj[1] - max_obj2) + abs(obj[1] - min_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple segments to reverse and reinsert\n        num_segments = random.randint(1, min(3, n // 3))\n        segment_indices = sorted(random.sample(range(1, n-1), num_segments))\n\n        for i in range(num_segments):\n            start = segment_indices[i]\n            end = start + random.randint(1, min(5, n - start - 1))\n            segment = new_solution[start:end+1]\n            reversed_segment = segment[::-1]\n            new_solution[start:end+1] = reversed_segment\n\n            # Reinsert the segment at a new position\n            new_pos = random.randint(0, n - len(segment))\n            if new_pos >= start:\n                new_pos += len(segment)\n            new_solution = np.concatenate([\n                new_solution[:new_pos],\n                segment,\n                np.delete(new_solution, np.arange(start, end+1))\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9520705233651351,
            0.20634669065475464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective space\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    min_obj1 = min(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n\n    diversity_scores = [(abs(obj[0] - max_obj1) + abs(obj[0] - min_obj1) + abs(obj[1] - max_obj2) + abs(obj[1] - min_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple segments to reverse and reinsert\n        num_segments = random.randint(1, min(3, n // 3))\n        segment_indices = sorted(random.sample(range(1, n-1), num_segments))\n\n        for i in range(num_segments):\n            start = segment_indices[i]\n            end = start + random.randint(1, min(5, n - start - 1))\n            segment = new_solution[start:end+1]\n            reversed_segment = segment[::-1]\n            new_solution[start:end+1] = reversed_segment\n\n            # Reinsert the segment at a new position\n            new_pos = random.randint(0, n - len(segment))\n            if new_pos >= start:\n                new_pos += len(segment)\n            new_solution = np.concatenate([\n                new_solution[:new_pos],\n                segment,\n                np.delete(new_solution, np.arange(start, end+1))\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on its Pareto dominance and applies a hybrid local search operator that combines edge swaps and segment reversals to generate a neighbor solution, ensuring feasibility by validating the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Perform edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8425241876304325,
            0.711737334728241
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Perform edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment inversion\" local search that reverses segments of nodes while considering both objective spaces to potentially improve the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        old_segment = new_solution[start:end+1]\n        inverted_segment = old_segment[::-1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, old_segment[0]] +\n                     distance_matrix_1[old_segment[-1], next_end] +\n                     distance_matrix_1[old_segment[0], old_segment[1]] +\n                     distance_matrix_1[old_segment[-2], old_segment[-1]])\n\n        new_cost1 = (distance_matrix_1[prev_start, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_end] +\n                     distance_matrix_1[inverted_segment[0], inverted_segment[1]] +\n                     distance_matrix_1[inverted_segment[-2], inverted_segment[-1]])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, old_segment[0]] +\n                     distance_matrix_2[old_segment[-1], next_end] +\n                     distance_matrix_2[old_segment[0], old_segment[1]] +\n                     distance_matrix_2[old_segment[-2], old_segment[-1]])\n\n        new_cost2 = (distance_matrix_2[prev_start, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_end] +\n                     distance_matrix_2[inverted_segment[0], inverted_segment[1]] +\n                     distance_matrix_2[inverted_segment[-2], inverted_segment[-1]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9191175126426914,
            0.5832509398460388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n        old_segment = new_solution[start:end+1]\n        inverted_segment = old_segment[::-1]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, old_segment[0]] +\n                     distance_matrix_1[old_segment[-1], next_end] +\n                     distance_matrix_1[old_segment[0], old_segment[1]] +\n                     distance_matrix_1[old_segment[-2], old_segment[-1]])\n\n        new_cost1 = (distance_matrix_1[prev_start, inverted_segment[0]] +\n                     distance_matrix_1[inverted_segment[-1], next_end] +\n                     distance_matrix_1[inverted_segment[0], inverted_segment[1]] +\n                     distance_matrix_1[inverted_segment[-2], inverted_segment[-1]])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, old_segment[0]] +\n                     distance_matrix_2[old_segment[-1], next_end] +\n                     distance_matrix_2[old_segment[0], old_segment[1]] +\n                     distance_matrix_2[old_segment[-2], old_segment[-1]])\n\n        new_cost2 = (distance_matrix_2[prev_start, inverted_segment[0]] +\n                     distance_matrix_2[inverted_segment[-1], next_end] +\n                     distance_matrix_2[inverted_segment[0], inverted_segment[1]] +\n                     distance_matrix_2[inverted_segment[-2], inverted_segment[-1]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = inverted_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on a crowding distance metric to prioritize less explored regions, then applies a hybrid local search combining edge exchange and node reinsertion with a dynamic segment length to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    front = np.arange(len(archive))\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment length based on solution quality\n    segment_length = max(2, min(5, int(np.log(n))))\n\n    # Hybrid local search: edge exchange + node reinsertion\n    for _ in range(2):\n        # Edge exchange\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node reinsertion\n        node = random.choice(new_solution)\n        new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7128863835198385,
            3.666903078556061
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    front = np.arange(len(archive))\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (np.max(objectives[:, m]) - np.min(objectives[:, m]))\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment length based on solution quality\n    segment_length = max(2, min(5, int(np.log(n))))\n\n    # Hybrid local search: edge exchange + node reinsertion\n    for _ in range(2):\n        # Edge exchange\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Node reinsertion\n        node = random.choice(new_solution)\n        new_solution = np.concatenate([new_solution[new_solution != node], [node]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive with high diversity in the objective space, applies a novel hybrid local search operator that combines path reversal and segment swapping to explore diverse non-dominated regions, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high diversity in objective space\n    objectives = [obj for (_, obj) in archive]\n    if len(objectives) > 1:\n        # Calculate diversity as the sum of squared differences\n        diversity = [sum((obj[0] - other[0])**2 + (obj[1] - other[1])**2 for other in objectives) for obj in objectives]\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select two random segments and swap them\n    seg1_start = random.randint(0, n - 2)\n    seg1_end = random.randint(seg1_start + 1, n - 1)\n    seg2_start = random.randint(0, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    segment1 = new_solution[seg1_start:seg1_end]\n    segment2 = new_solution[seg2_start:seg2_end]\n\n    # Create new solution by swapping segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        segment2,\n        new_solution[seg1_end:seg2_start],\n        segment1,\n        new_solution[seg2_end:]\n    ])\n\n    # Step 2: Reverse a random segment\n    rev_start = random.randint(0, n - 2)\n    rev_end = random.randint(rev_start + 1, n - 1)\n    new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6886570951701617,
            4.919799208641052
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high diversity in objective space\n    objectives = [obj for (_, obj) in archive]\n    if len(objectives) > 1:\n        # Calculate diversity as the sum of squared differences\n        diversity = [sum((obj[0] - other[0])**2 + (obj[1] - other[1])**2 for other in objectives) for obj in objectives]\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 2:\n        return new_solution\n\n    # Step 1: Select two random segments and swap them\n    seg1_start = random.randint(0, n - 2)\n    seg1_end = random.randint(seg1_start + 1, n - 1)\n    seg2_start = random.randint(0, n - 2)\n    seg2_end = random.randint(seg2_start + 1, n - 1)\n\n    segment1 = new_solution[seg1_start:seg1_end]\n    segment2 = new_solution[seg2_start:seg2_end]\n\n    # Create new solution by swapping segments\n    new_solution = np.concatenate([\n        new_solution[:seg1_start],\n        segment2,\n        new_solution[seg1_end:seg2_start],\n        segment1,\n        new_solution[seg2_end:]\n    ])\n\n    # Step 2: Reverse a random segment\n    rev_start = random.randint(0, n - 2)\n    rev_end = random.randint(rev_start + 1, n - 1)\n    new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This algorithm selects a solution from the archive based on the most balanced objective values, then applies a novel \"cross-space segment inversion\" operator that inverts segments of the tour while considering both objective spaces, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most balanced objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    balanced_scores = [abs((obj[0]/max_obj1) - (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7808071292244794,
            1.9516419768333435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most balanced objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    balanced_scores = [abs((obj[0]/max_obj1) - (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmin(balanced_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random segment to invert\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        segment = new_solution[start:end+1]\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end], next_end])\n        new_cost1 = (distance_matrix_1[prev_start, new_solution[end]] +\n                     distance_matrix_1[new_solution[start], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end], next_end])\n        new_cost2 = (distance_matrix_2[prev_start, new_solution[end]] +\n                     distance_matrix_2[new_solution[start], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = segment[::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"node reinsertion with cross-space awareness\" local search that intelligently reinserts a node at a new position while considering both objective spaces, ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Select a node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Evaluate potential insertion positions\n        best_position = 0\n        best_improvement = float('inf')\n\n        for pos in range(n-1):\n            # Calculate old and new costs for first objective space\n            if pos == 0:\n                old_prev = new_solution[-1]\n                old_next = new_solution[0]\n            else:\n                old_prev = new_solution[pos-1]\n                old_next = new_solution[pos]\n\n            old_cost1 = distance_matrix_1[old_prev, node] + distance_matrix_1[node, old_next]\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[0]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n\n            # Calculate old and new costs for second objective space\n            old_cost2 = distance_matrix_2[old_prev, node] + distance_matrix_2[node, old_next]\n            if pos == 0:\n                new_cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[0]]\n            else:\n                new_cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_position = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_position, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9266672522364711,
            0.745770275592804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Select a node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Evaluate potential insertion positions\n        best_position = 0\n        best_improvement = float('inf')\n\n        for pos in range(n-1):\n            # Calculate old and new costs for first objective space\n            if pos == 0:\n                old_prev = new_solution[-1]\n                old_next = new_solution[0]\n            else:\n                old_prev = new_solution[pos-1]\n                old_next = new_solution[pos]\n\n            old_cost1 = distance_matrix_1[old_prev, node] + distance_matrix_1[node, old_next]\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[0]]\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n\n            # Calculate old and new costs for second objective space\n            old_cost2 = distance_matrix_2[old_prev, node] + distance_matrix_2[node, old_next]\n            if pos == 0:\n                new_cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[0]]\n            else:\n                new_cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_position = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_position, node)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-space segment inversion\" local search that intelligently reverses segments of nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-space segment inversion\n    if n > 2:\n        # Select a segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0022156093182204,
            0.33985209465026855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-space segment inversion\n    if n > 2:\n        # Select a segment to invert\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[(end+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_start, new_solution[start]] + distance_matrix_1[new_solution[end], next_end]\n        new_cost1 = distance_matrix_1[prev_start, new_solution[end]] + distance_matrix_1[new_solution[start], next_end]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_start, new_solution[start]] + distance_matrix_2[new_solution[end], next_end]\n        new_cost2 = distance_matrix_2[prev_start, new_solution[end]] + distance_matrix_2[new_solution[start], next_end]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node swapping and segment reversal to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.845483321200913,
            0.2694769501686096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on both objective values, applies a hybrid local search operator that combines 3-opt and segment reversal to explore diverse regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Perform 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:] if c+1 < n else np.array([])\n    new_segments = [segment1, segment2, segment3]\n    random.shuffle(new_segments)\n    new_solution = np.concatenate([new_solution[:a], new_segments[0], new_segments[1], new_segments[2]])\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6829857137179648,
            0.34179162979125977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Perform 3-opt move\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    segment3 = new_solution[c+1:] if c+1 < n else np.array([])\n    new_segments = [segment1, segment2, segment3]\n    random.shuffle(new_segments)\n    new_solution = np.concatenate([new_solution[:a], new_segments[0], new_segments[1], new_segments[2]])\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{The heuristic function 'select_neighbor' first identifies the non-dominated solutions in the archive, then intelligently selects one based on crowding distance to promote diversity, and applies a hybrid local search combining edge swaps and path reversals to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select solution based on crowding distance\n    if len(non_dominated) > 1:\n        # Calculate crowding distance for non-dominated solutions\n        objectives = np.array([obj for _, obj in non_dominated])\n        crowding = np.zeros(len(non_dominated))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(non_dominated)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        # Select solution with lowest crowding distance (most crowded)\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 3: Apply hybrid local search\n    # Edge swap with path reversal\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional edge swap\n    k, l = random.sample(range(n), 2)\n    if k > l:\n        k, l = l, k\n\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8081201589060582,
            0.3804969787597656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select solution based on crowding distance\n    if len(non_dominated) > 1:\n        # Calculate crowding distance for non-dominated solutions\n        objectives = np.array([obj for _, obj in non_dominated])\n        crowding = np.zeros(len(non_dominated))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(non_dominated)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n        # Select solution with lowest crowding distance (most crowded)\n        selected_idx = np.argmin(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 3: Apply hybrid local search\n    # Edge swap with path reversal\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Reverse segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional edge swap\n    k, l = random.sample(range(n), 2)\n    if k > l:\n        k, l = l, k\n\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"multi-segment relocation\" local search that intelligently relocates multiple contiguous segments of nodes while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distances for selection\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    # Normalize objectives\n    min_obj1, max_obj1 = min(obj1), max(obj1)\n    min_obj2, max_obj2 = min(obj2), max(obj2)\n    normalized_obj1 = [(o - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5 for o in obj1]\n    normalized_obj2 = [(o - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5 for o in obj2]\n\n    # Calculate crowding distances\n    crowding_distances = []\n    for i in range(len(archive)):\n        left = i - 1 if i > 0 else None\n        right = i + 1 if i < len(archive) - 1 else None\n\n        if left is None or right is None:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = abs(normalized_obj1[right] - normalized_obj1[left])\n            dist2 = abs(normalized_obj2[right] - normalized_obj2[left])\n            crowding_distances.append(dist1 + dist2)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    if n > 4:\n        # Select two random segments\n        seg1_start = random.randint(0, n - 4)\n        seg1_end = random.randint(seg1_start + 1, n - 3)\n        seg2_start = random.randint(seg1_end + 1, n - 2)\n        seg2_end = random.randint(seg2_start + 1, n - 1)\n\n        # Extract segments\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2 = new_solution[seg2_start:seg2_end+1]\n\n        # Relocate segments\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            seg2,\n            new_solution[seg1_end+1:seg2_start],\n            seg1,\n            new_solution[seg2_end+1:]\n        ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8868786268542959,
            0.5101996660232544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Calculate crowding distances for selection\n    objectives = [obj for _, obj in archive]\n    obj1 = [obj[0] for obj in objectives]\n    obj2 = [obj[1] for obj in objectives]\n\n    # Normalize objectives\n    min_obj1, max_obj1 = min(obj1), max(obj1)\n    min_obj2, max_obj2 = min(obj2), max(obj2)\n    normalized_obj1 = [(o - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5 for o in obj1]\n    normalized_obj2 = [(o - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5 for o in obj2]\n\n    # Calculate crowding distances\n    crowding_distances = []\n    for i in range(len(archive)):\n        left = i - 1 if i > 0 else None\n        right = i + 1 if i < len(archive) - 1 else None\n\n        if left is None or right is None:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = abs(normalized_obj1[right] - normalized_obj1[left])\n            dist2 = abs(normalized_obj2[right] - normalized_obj2[left])\n            crowding_distances.append(dist1 + dist2)\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    if n > 4:\n        # Select two random segments\n        seg1_start = random.randint(0, n - 4)\n        seg1_end = random.randint(seg1_start + 1, n - 3)\n        seg2_start = random.randint(seg1_end + 1, n - 2)\n        seg2_end = random.randint(seg2_start + 1, n - 1)\n\n        # Extract segments\n        seg1 = new_solution[seg1_start:seg1_end+1]\n        seg2 = new_solution[seg2_start:seg2_end+1]\n\n        # Relocate segments\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            seg2,\n            new_solution[seg1_end+1:seg2_start],\n            seg1,\n            new_solution[seg2_end+1:]\n        ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on crowding distance and applies a hybrid local search operator that combines edge exchange and segment reversal to explore the Pareto front, ensuring feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest crowding distance\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        if i == 0:\n            crowding_distances.append(0)\n            continue\n        prev_obj = archive[i-1][1]\n        next_obj = archive[(i+1)%len(archive)][1]\n        dist1 = abs(obj[0] - prev_obj[0]) + abs(obj[0] - next_obj[0])\n        dist2 = abs(obj[1] - prev_obj[1]) + abs(obj[1] - next_obj[1])\n        crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Apply hybrid local search: edge exchange and segment reversal\n    # Step 1: Edge exchange between two random edges\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random segment\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7109294120660915,
            0.583443284034729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest crowding distance\n    crowding_distances = []\n    for i, (sol, obj) in enumerate(archive):\n        if i == 0:\n            crowding_distances.append(0)\n            continue\n        prev_obj = archive[i-1][1]\n        next_obj = archive[(i+1)%len(archive)][1]\n        dist1 = abs(obj[0] - prev_obj[0]) + abs(obj[0] - next_obj[0])\n        dist2 = abs(obj[1] - prev_obj[1]) + abs(obj[1] - next_obj[1])\n        crowding_distances.append(dist1 + dist2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Apply hybrid local search: edge exchange and segment reversal\n    # Step 1: Edge exchange between two random edges\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Reverse a random segment\n    start, end = sorted(random.sample(range(n), 2))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies a \"multi-segment inversion\" local search that randomly inverts segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    min_obj1 = min(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    diversity_scores = [(abs(obj[0] - max_obj1) + abs(obj[0] - min_obj1) + abs(obj[1] - max_obj2) + abs(obj[1] - min_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Select two random positions\n        a, b = sorted(random.sample(range(n), 2))\n\n        # Invert the segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Calculate potential improvement\n        prev_a = new_solution[a-1]\n        next_b = new_solution[(b+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_a, base_solution[a]] + distance_matrix_1[base_solution[b], next_b]\n        new_cost1 = distance_matrix_1[prev_a, new_solution[a]] + distance_matrix_1[new_solution[b], next_b]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_a, base_solution[a]] + distance_matrix_2[base_solution[b], next_b]\n        new_cost2 = distance_matrix_2[prev_a, new_solution[a]] + distance_matrix_2[new_solution[b], next_b]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7657035561531611,
            2.7552583813667297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    min_obj1 = min(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    diversity_scores = [(abs(obj[0] - max_obj1) + abs(obj[0] - min_obj1) + abs(obj[1] - max_obj2) + abs(obj[1] - min_obj2)) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Select two random positions\n        a, b = sorted(random.sample(range(n), 2))\n\n        # Invert the segment between a and b\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Calculate potential improvement\n        prev_a = new_solution[a-1]\n        next_b = new_solution[(b+1)%n]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev_a, base_solution[a]] + distance_matrix_1[base_solution[b], next_b]\n        new_cost1 = distance_matrix_1[prev_a, new_solution[a]] + distance_matrix_1[new_solution[b], next_b]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev_a, base_solution[a]] + distance_matrix_2[base_solution[b], next_b]\n        new_cost2 = distance_matrix_2[prev_a, new_solution[a]] + distance_matrix_2[new_solution[b], next_b]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node swapping and segment reversal to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7480590968870819,
            0.2540366053581238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and reverse it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in objective values, then applies an \"adaptive segment inversion\" local search that intelligently reverses segments of the tour while considering both objective spaces' improvements to create a more balanced neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    std_obj1 = np.std(obj1_values)\n    std_obj2 = np.std(obj2_values)\n    diversity_scores = [(obj1_values[i]/std_obj1 if std_obj1 > 0 else 0) + (obj2_values[i]/std_obj2 if std_obj2 > 0 else 0) for i in range(len(objectives))]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if n > 2:\n        # Randomly select segment length and position\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - segment_length)\n\n        # Calculate potential improvement\n        prev = new_solution[start-1]\n        next_ = new_solution[start + segment_length] if (start + segment_length) < n else new_solution[0]\n        segment = new_solution[start:start+segment_length]\n        reversed_segment = segment[::-1]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev, segment[0]] + distance_matrix_1[segment[-1], next_]\n        new_cost1 = distance_matrix_1[prev, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev, segment[0]] + distance_matrix_2[segment[-1], next_]\n        new_cost2 = distance_matrix_2[prev, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0 or random.random() < 0.3:  # Allow some non-improving moves\n            # Perform inversion if it improves or with probability\n            new_solution[start:start+segment_length] = reversed_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9180042867892282,
            1.1712654829025269
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity in objective values\n    objectives = [obj for _, obj in archive]\n    obj1_values = [obj[0] for obj in objectives]\n    obj2_values = [obj[1] for obj in objectives]\n    std_obj1 = np.std(obj1_values)\n    std_obj2 = np.std(obj2_values)\n    diversity_scores = [(obj1_values[i]/std_obj1 if std_obj1 > 0 else 0) + (obj2_values[i]/std_obj2 if std_obj2 > 0 else 0) for i in range(len(objectives))]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if n > 2:\n        # Randomly select segment length and position\n        segment_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - segment_length)\n\n        # Calculate potential improvement\n        prev = new_solution[start-1]\n        next_ = new_solution[start + segment_length] if (start + segment_length) < n else new_solution[0]\n        segment = new_solution[start:start+segment_length]\n        reversed_segment = segment[::-1]\n\n        # For first objective space\n        old_cost1 = distance_matrix_1[prev, segment[0]] + distance_matrix_1[segment[-1], next_]\n        new_cost1 = distance_matrix_1[prev, reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], next_]\n\n        # For second objective space\n        old_cost2 = distance_matrix_2[prev, segment[0]] + distance_matrix_2[segment[-1], next_]\n        new_cost2 = distance_matrix_2[prev, reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], next_]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0 or random.random() < 0.3:  # Allow some non-improving moves\n            # Perform inversion if it improves or with probability\n            new_solution[start:start+segment_length] = reversed_segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a weighted sum of its objectives, applies a hybrid local search operator combining edge reversal and node reinsertion to explore the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search operator: edge reversal + node reinsertion\n    # Edge reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node reinsertion\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9533130676166557,
            0.23430418968200684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search operator: edge reversal + node reinsertion\n    # Edge reversal\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Node reinsertion\n    node_pos = random.randint(0, n-1)\n    node = new_solution[node_pos]\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n-2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their tour structure, then applies a \"segment inversion and reinsertion\" local search that inverts a random segment of the tour and reinserts it at a new position while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (most unique edges)\n    diversity_scores = []\n    for sol, _ in archive:\n        edges = set()\n        n = len(sol)\n        for i in range(n):\n            edges.add((sol[i], sol[(i+1)%n]))\n        diversity_scores.append(len(edges))\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Segment inversion and reinsertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, n-2)\n    segment = new_solution[start:end+1]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Remove the original segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Reinsert the inverted segment at a new position\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], inverted_segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6266495179802087,
            0.9397354125976562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest diversity (most unique edges)\n    diversity_scores = []\n    for sol, _ in archive:\n        edges = set()\n        n = len(sol)\n        for i in range(n):\n            edges.add((sol[i], sol[(i+1)%n]))\n        diversity_scores.append(len(edges))\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Segment inversion and reinsertion\n    start = random.randint(0, n-3)\n    end = random.randint(start+1, n-2)\n    segment = new_solution[start:end+1]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Remove the original segment\n    new_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n\n    # Reinsert the inverted segment at a new position\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], inverted_segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a novel \"cross-space segment inversion\" local search that inverts segments of nodes between the two objective spaces while ensuring feasibility through careful boundary validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.98588608877922,
            0.29138582944869995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 3:\n        # Select two distinct positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in their tour structure, then applies a \"multi-segment permutation\" local search that intelligently reorders multiple non-adjacent segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest structural diversity (measured by number of unique adjacent pairs)\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol, np.roll(sol, -1)))\n        diversity_scores.append(len(unique_pairs))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple non-adjacent segments to permute\n        num_segments = random.randint(2, min(4, n//3))\n        segment_starts = sorted(random.sample(range(n-1), num_segments))\n        segments = []\n        for i in range(num_segments):\n            start = segment_starts[i]\n            end = segment_starts[i+1] if i < num_segments-1 else n\n            segments.append(new_solution[start:end])\n\n        # Permute the selected segments\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8432621734698963,
            1.4434360265731812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest structural diversity (measured by number of unique adjacent pairs)\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_pairs = set(zip(sol, np.roll(sol, -1)))\n        diversity_scores.append(len(unique_pairs))\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple non-adjacent segments to permute\n        num_segments = random.randint(2, min(4, n//3))\n        segment_starts = sorted(random.sample(range(n-1), num_segments))\n        segments = []\n        for i in range(num_segments):\n            start = segment_starts[i]\n            end = segment_starts[i+1] if i < num_segments-1 else n\n            segments.append(new_solution[start:end])\n\n        # Permute the selected segments\n        random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with high crowding distance in the objective space, then applies a \"multi-segment inversion and reinsertion\" local search that intelligently inverts segments and reinserts them at new positions while balancing improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with high crowding distance\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(obj[0] for obj in objectives)\n    sorted_obj2 = sorted(obj[1] for obj in objectives)\n\n    crowding_distances = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            cd1 = sorted_obj1[i+1] - sorted_obj1[i-1]\n            cd2 = sorted_obj2[i+1] - sorted_obj2[i-1]\n            crowding_distances.append(cd1 + cd2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random segments and invert them\n        start1, end1 = sorted(random.sample(range(n), 2))\n        start2, end2 = sorted(random.sample(range(n), 2))\n\n        segment1 = new_solution[start1:end1+1][::-1]\n        segment2 = new_solution[start2:end2+1][::-1]\n\n        new_solution[start1:end1+1] = segment1\n        new_solution[start2:end2+1] = segment2\n\n        # Calculate potential improvement\n        def calculate_cost(solution, distance_matrix):\n            cost = 0\n            for i in range(n):\n                cost += distance_matrix[solution[i], solution[(i+1)%n]]\n            return cost\n\n        old_cost1 = calculate_cost(base_solution, distance_matrix_1)\n        old_cost2 = calculate_cost(base_solution, distance_matrix_2)\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # If no improvement, reinsert segments at random positions\n            new_solution = base_solution.copy()\n            pos1 = random.randint(0, n-1)\n            pos2 = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:pos1], segment1, new_solution[pos1:]])\n            new_solution = np.concatenate([new_solution[:pos2], segment2, new_solution[pos2:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8319514643065095,
            0.2758312225341797
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with high crowding distance\n    objectives = [obj for _, obj in archive]\n    sorted_obj1 = sorted(obj[0] for obj in objectives)\n    sorted_obj2 = sorted(obj[1] for obj in objectives)\n\n    crowding_distances = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances.append(float('inf'))\n        else:\n            cd1 = sorted_obj1[i+1] - sorted_obj1[i-1]\n            cd2 = sorted_obj2[i+1] - sorted_obj2[i-1]\n            crowding_distances.append(cd1 + cd2)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random segments and invert them\n        start1, end1 = sorted(random.sample(range(n), 2))\n        start2, end2 = sorted(random.sample(range(n), 2))\n\n        segment1 = new_solution[start1:end1+1][::-1]\n        segment2 = new_solution[start2:end2+1][::-1]\n\n        new_solution[start1:end1+1] = segment1\n        new_solution[start2:end2+1] = segment2\n\n        # Calculate potential improvement\n        def calculate_cost(solution, distance_matrix):\n            cost = 0\n            for i in range(n):\n                cost += distance_matrix[solution[i], solution[(i+1)%n]]\n            return cost\n\n        old_cost1 = calculate_cost(base_solution, distance_matrix_1)\n        old_cost2 = calculate_cost(base_solution, distance_matrix_2)\n        new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n        new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # If no improvement, reinsert segments at random positions\n            new_solution = base_solution.copy()\n            pos1 = random.randint(0, n-1)\n            pos2 = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:pos1], segment1, new_solution[pos1:]])\n            new_solution = np.concatenate([new_solution[:pos2], segment2, new_solution[pos2:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive with high potential for improvement, applies a hybrid local search combining edge swaps and segment reversals to explore non-dominated regions, and ensures feasibility by validating the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))  # Select from top 3 candidates\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Perform 3 random edge swaps\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7892837248914483,
            0.2015555500984192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))  # Select from top 3 candidates\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Perform 3 random edge swaps\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This heuristic selects a solution from the archive based on a combination of dominance rank and crowding distance to prioritize diverse and potentially non-dominated solutions, then applies a \"multi-segment inversion\" local search that reverses a randomly selected segment of the tour while ensuring feasibility through careful boundary checks and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution based on dominance rank and crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Simple dominance rank (higher is better)\n    ranks = np.argsort([-sum(obj) for obj in objectives])\n    selected_idx = ranks[0]  # Select the best solution\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select a random segment to reverse\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n\n        # Reverse the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8739821691015407,
            0.22184967994689941
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution based on dominance rank and crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Simple dominance rank (higher is better)\n    ranks = np.argsort([-sum(obj) for obj in objectives])\n    selected_idx = ranks[0]  # Select the best solution\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Select a random segment to reverse\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n\n        # Reverse the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance in the objective space, then applies a \"multi-segment reversal\" local search that reverses segments of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    if len(objectives) < 2:\n        selected_idx = 0\n    else:\n        sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n        sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n        crowding = []\n        for i in range(len(objectives)):\n            if i == 0 or i == len(objectives)-1:\n                crowding.append(float('inf'))\n            else:\n                crowding.append(\n                    (sorted_obj1[i+1][0] - sorted_obj1[i-1][0]) / (sorted_obj1[-1][0] - sorted_obj1[0][0]) +\n                    (sorted_obj2[i+1][1] - sorted_obj2[i-1][1]) / (sorted_obj2[-1][1] - sorted_obj2[0][1])\n                )\n        selected_idx = np.argmax(crowding)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(a+1, b), 2)) if (b - a) > 2 else (a, b)\n\n        # Reverse segments\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7028538977718903,
            0.36130887269973755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    if len(objectives) < 2:\n        selected_idx = 0\n    else:\n        sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n        sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n        crowding = []\n        for i in range(len(objectives)):\n            if i == 0 or i == len(objectives)-1:\n                crowding.append(float('inf'))\n            else:\n                crowding.append(\n                    (sorted_obj1[i+1][0] - sorted_obj1[i-1][0]) / (sorted_obj1[-1][0] - sorted_obj1[0][0]) +\n                    (sorted_obj2[i+1][1] - sorted_obj2[i-1][1]) / (sorted_obj2[-1][1] - sorted_obj2[0][1])\n                )\n        selected_idx = np.argmax(crowding)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment reversal\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(a+1, b), 2)) if (b - a) > 2 else (a, b)\n\n        # Reverse segments\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[c:d] = new_solution[c:d][::-1]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment inversion\" local search that randomly inverts a segment of the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Randomly select segment start and end\n        start = random.randint(0, n-1)\n        end = random.randint(start, n-1)\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9132734536283724,
            0.259163498878479
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Randomly select segment start and end\n        start = random.randint(0, n-1)\n        end = random.randint(start, n-1)\n\n        # Invert the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values (sum of normalized objectives) and applies a \"dual-space node insertion\" local search that strategically reinserts nodes between adjacent pairs while evaluating improvements across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    combined_scores = [(obj[0] + obj[1]) / (max_obj1 + max_obj2) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-2)\n        if j >= i:\n            j += 1\n\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i]\n        old_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i]\n\n        new_cost1 = distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n        new_cost2 = distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            new_solution = np.concatenate((new_solution[:j], [new_solution[i]], new_solution[j:i], new_solution[i+1:]))\n\n    return new_solution\n\n",
        "score": [
            -0.9379080557768675,
            0.24231648445129395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    combined_scores = [(obj[0] + obj[1]) / (max_obj1 + max_obj2) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-2)\n        if j >= i:\n            j += 1\n\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i]\n        old_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i]\n\n        new_cost1 = distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n        new_cost2 = distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            new_solution = np.concatenate((new_solution[:j], [new_solution[i]], new_solution[j:i], new_solution[i+1:]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node swapping with a dynamic segment reversal to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select two random nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Select a random segment and reverse it\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8191744882381737,
            0.2886902689933777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select two random nodes and swap them\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Select a random segment and reverse it\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{The new algorithm selects a solution from the archive based on a score combining crowding distance and objective values, then applies a hybrid local search combining segment reversal and node relocation to generate a feasible neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Score solutions based on crowding distance and objective values\n    def score_solution(sol, obj):\n        crowding = (obj[0] + obj[1]) * 0.5\n        return crowding + (1 / (1 + obj[0] + obj[1]))\n\n    scores = [score_solution(sol, obj) for sol, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9685849295212364,
            0.2582007050514221
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Score solutions based on crowding distance and objective values\n    def score_solution(sol, obj):\n        crowding = (obj[0] + obj[1]) * 0.5\n        return crowding + (1 / (1 + obj[0] + obj[1]))\n\n    scores = [score_solution(sol, obj) for sol, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Hybrid local search: segment reversal and node relocation\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a random node\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space segment inversion\" local search that intelligently reverses segments of nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a segment to invert\n        start = random.randint(0, n-1)\n        length = random.randint(2, min(5, n-1))\n        end = (start + length) % n\n\n        # Determine the segment to invert\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[end%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end%n-1], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end%n-1], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            if start < end:\n                new_solution[start:end] = segment[::-1]\n            else:\n                inverted_segment = segment[::-1]\n                new_solution[start:] = inverted_segment[:n-start]\n                new_solution[:end] = inverted_segment[n-start:]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8527361998847971,
            0.2739717364311218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space segment inversion\n    if n > 2:\n        # Select a segment to invert\n        start = random.randint(0, n-1)\n        length = random.randint(2, min(5, n-1))\n        end = (start + length) % n\n\n        # Determine the segment to invert\n        if start < end:\n            segment = new_solution[start:end]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n\n        # Calculate potential improvement\n        prev_start = new_solution[start-1]\n        next_end = new_solution[end%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_start, new_solution[start]] +\n                     distance_matrix_1[new_solution[end%n-1], next_end])\n\n        new_cost1 = (distance_matrix_1[prev_start, segment[-1]] +\n                     distance_matrix_1[segment[0], next_end])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_start, new_solution[start]] +\n                     distance_matrix_2[new_solution[end%n-1], next_end])\n\n        new_cost2 = (distance_matrix_2[prev_start, segment[-1]] +\n                     distance_matrix_2[segment[0], next_end])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform inversion if it improves the solution\n            if start < end:\n                new_solution[start:end] = segment[::-1]\n            else:\n                inverted_segment = segment[::-1]\n                new_solution[start:] = inverted_segment[:n-start]\n                new_solution[:end] = inverted_segment[n-start:]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines segment reversal and node relocation to explore non-dominated regions, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a randomly selected node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9064655072894615,
            0.24018609523773193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Relocate a randomly selected node to a new position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive based on its Pareto dominance and applies a novel hybrid local search operator that combines segment reversal and node swapping to explore the objective space, ensuring feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment to disrupt the tour\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes to further explore the search space\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7728057482933058,
            0.21869564056396484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment to disrupt the tour\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Swap two randomly selected nodes to further explore the search space\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node reversal and segment insertion to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    for sol, _ in archive:\n        crowding_dist = 0.0\n        for i in range(1, len(sol)-1):\n            crowding_dist += distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]]\n        crowding_distances.append(crowding_dist)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a segment from another position\n    seg_start = random.randint(0, n - 2)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    segment = new_solution[seg_start:seg_end+1]\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8507537929175941,
            1.7148984670639038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    crowding_distances = []\n    for sol, _ in archive:\n        crowding_dist = 0.0\n        for i in range(1, len(sol)-1):\n            crowding_dist += distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]]\n        crowding_distances.append(crowding_dist)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Reverse a random segment\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Insert a segment from another position\n    seg_start = random.randint(0, n - 2)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    segment = new_solution[seg_start:seg_end+1]\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest diversity in node sequences, then applies a \"multi-segment inversion and merging\" local search that intelligently inverts and merges multiple segments of the tour to explore new regions of the bi-objective space while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest sequence diversity\n    solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n    for sol in solutions:\n        diversity = 0\n        for i in range(len(sol)):\n            if i > 0 and sol[i] != sol[i-1]:\n                diversity += 1\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple segments and invert them\n        num_segments = random.randint(1, min(3, n//2))\n        segment_indices = sorted(random.sample(range(0, n-1), num_segments*2))\n        for i in range(0, len(segment_indices), 2):\n            start, end = segment_indices[i], segment_indices[i+1]\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Merge segments to create a new structure\n        merge_points = sorted(random.sample(range(1, n-1), min(2, n//3)))\n        for point in merge_points:\n            new_solution = np.concatenate([new_solution[:point], new_solution[point:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6699919916485367,
            0.622870683670044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest sequence diversity\n    solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n    for sol in solutions:\n        diversity = 0\n        for i in range(len(sol)):\n            if i > 0 and sol[i] != sol[i-1]:\n                diversity += 1\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple segments and invert them\n        num_segments = random.randint(1, min(3, n//2))\n        segment_indices = sorted(random.sample(range(0, n-1), num_segments*2))\n        for i in range(0, len(segment_indices), 2):\n            start, end = segment_indices[i], segment_indices[i+1]\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Merge segments to create a new structure\n        merge_points = sorted(random.sample(range(1, n-1), min(2, n//3)))\n        for point in merge_points:\n            new_solution = np.concatenate([new_solution[:point], new_solution[point:]])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive based on the diversity of its objective values, then applies a novel \"cross-space segment inversion\" operator that inverts segments of the tour in both objective spaces while ensuring feasibility through careful boundary validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most diverse objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [(obj[0] - obj[1])**2 for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random segments and invert them\n        seg1_start = random.randint(0, n-3)\n        seg1_end = random.randint(seg1_start+1, n-2)\n        seg2_start = random.randint(0, n-3)\n        seg2_end = random.randint(seg2_start+1, n-2)\n\n        # Invert segments in both objective spaces\n        new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n        new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5079844060908273,
            0.19663280248641968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with most diverse objectives\n    objectives = [obj for _, obj in archive]\n    diversity_scores = [(obj[0] - obj[1])**2 for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select two random segments and invert them\n        seg1_start = random.randint(0, n-3)\n        seg1_end = random.randint(seg1_start+1, n-2)\n        seg2_start = random.randint(0, n-3)\n        seg2_end = random.randint(seg2_start+1, n-2)\n\n        # Invert segments in both objective spaces\n        new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n        new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n        # Ensure feasibility\n        if len(set(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"multi-segment relocation\" local search that intelligently moves segments of nodes between different positions in the tour while ensuring feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    if n > 4:\n        # Select a segment and a new position\n        segment_length = random.randint(2, min(4, n-2))\n        segment_start = random.randint(0, n-segment_length-1)\n        segment_end = segment_start + segment_length\n        new_pos = random.randint(0, n-segment_length)\n\n        # Extract the segment\n        segment = new_solution[segment_start:segment_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n\n        # Insert the segment at new position\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n        # Calculate potential improvement\n        # For first objective space\n        old_cost1 = (distance_matrix_1[new_solution[segment_start-1], new_solution[segment_start]] +\n                     distance_matrix_1[new_solution[segment_end-1], new_solution[segment_end%len(new_solution)]])\n\n        new_cost1 = (distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]] +\n                     distance_matrix_1[new_solution[new_pos+segment_length-1], new_solution[(new_pos+segment_length)%len(new_solution)]])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[new_solution[segment_start-1], new_solution[segment_start]] +\n                     distance_matrix_2[new_solution[segment_end-1], new_solution[segment_end%len(new_solution)]])\n\n        new_cost2 = (distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]] +\n                     distance_matrix_2[new_solution[new_pos+segment_length-1], new_solution[(new_pos+segment_length)%len(new_solution)]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9921477320438754,
            0.2591387629508972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    if n > 4:\n        # Select a segment and a new position\n        segment_length = random.randint(2, min(4, n-2))\n        segment_start = random.randint(0, n-segment_length-1)\n        segment_end = segment_start + segment_length\n        new_pos = random.randint(0, n-segment_length)\n\n        # Extract the segment\n        segment = new_solution[segment_start:segment_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n\n        # Insert the segment at new position\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n        # Calculate potential improvement\n        # For first objective space\n        old_cost1 = (distance_matrix_1[new_solution[segment_start-1], new_solution[segment_start]] +\n                     distance_matrix_1[new_solution[segment_end-1], new_solution[segment_end%len(new_solution)]])\n\n        new_cost1 = (distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]] +\n                     distance_matrix_1[new_solution[new_pos+segment_length-1], new_solution[(new_pos+segment_length)%len(new_solution)]])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[new_solution[segment_start-1], new_solution[segment_start]] +\n                     distance_matrix_2[new_solution[segment_end-1], new_solution[segment_end%len(new_solution)]])\n\n        new_cost2 = (distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]] +\n                     distance_matrix_2[new_solution[new_pos+segment_length-1], new_solution[(new_pos+segment_length)%len(new_solution)]])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement >= 0:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest crowding distance to ensure diversity, then applies a \"multi-segment inversion and reinsertion\" local search that intelligently inverts multiple random segments and reinserts them at new positions while preserving feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n\n    # Calculate crowding distance for diversity\n    crowding_distances = []\n    for i in range(len(archive)):\n        left = right = 0\n        if i > 0:\n            left = (objectives[i][0] - objectives[i-1][0])**2 + (objectives[i][1] - objectives[i-1][1])**2\n        if i < len(archive)-1:\n            right = (objectives[i+1][0] - objectives[i][0])**2 + (objectives[i+1][1] - objectives[i][1])**2\n        crowding_distances.append(left + right)\n    selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple random segments and invert them\n        num_segments = random.randint(1, min(3, n//3))\n        segments = []\n        for _ in range(num_segments):\n            start = random.randint(0, n-2)\n            end = random.randint(start+1, min(start+5, n-1))\n            segments.append((start, end))\n\n        for start, end in segments:\n            segment = new_solution[start:end+1]\n            new_solution[start:end+1] = segment[::-1]\n\n        # Reinsert segments at new positions\n        for start, end in segments:\n            segment = new_solution[start:end+1]\n            new_solution = np.delete(new_solution, np.s_[start:end+1])\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8334806612166337,
            0.28169023990631104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest crowding distance\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n\n    # Calculate crowding distance for diversity\n    crowding_distances = []\n    for i in range(len(archive)):\n        left = right = 0\n        if i > 0:\n            left = (objectives[i][0] - objectives[i-1][0])**2 + (objectives[i][1] - objectives[i-1][1])**2\n        if i < len(archive)-1:\n            right = (objectives[i+1][0] - objectives[i][0])**2 + (objectives[i+1][1] - objectives[i][1])**2\n        crowding_distances.append(left + right)\n    selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select multiple random segments and invert them\n        num_segments = random.randint(1, min(3, n//3))\n        segments = []\n        for _ in range(num_segments):\n            start = random.randint(0, n-2)\n            end = random.randint(start+1, min(start+5, n-1))\n            segments.append((start, end))\n\n        for start, end in segments:\n            segment = new_solution[start:end+1]\n            new_solution[start:end+1] = segment[::-1]\n\n        # Reinsert segments at new positions\n        for start, end in segments:\n            segment = new_solution[start:end+1]\n            new_solution = np.delete(new_solution, np.s_[start:end+1])\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This heuristic selects a solution from the archive by prioritizing those with the highest normalized objective values, then applies a \"cross-space node swapping\" local search that intelligently exchanges nodes between the two objective spaces while ensuring feasibility through careful validation and repair mechanisms.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest normalized objective values\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/max_obj1) + (obj[1]/max_obj2)) for obj in objectives]\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space node swapping\n    if n > 2:\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate potential improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        # For first objective space\n        old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_i] +\n                     distance_matrix_1[prev_j, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_j])\n\n        new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                     distance_matrix_1[new_solution[j], next_i] +\n                     distance_matrix_1[prev_j, new_solution[i]] +\n                     distance_matrix_1[new_solution[i], next_j])\n\n        # For second objective space\n        old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_i] +\n                     distance_matrix_2[prev_j, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_j])\n\n        new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                     distance_matrix_2[new_solution[j], next_i] +\n                     distance_matrix_2[prev_j, new_solution[i]] +\n                     distance_matrix_2[new_solution[i], next_j])\n\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < 0:\n            # Perform swap if it improves the solution\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the lowest normalized objective values, then applies a \"multi-segment inversion\" local search that reverses segments of the tour while considering both objective spaces to find improved solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Select two random segments to invert\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments don't overlap\n        if b <= c:\n            # Invert first segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n            # Invert second segment\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n            # Calculate potential improvement\n            def calculate_cost(sol, dist_matrix):\n                cost = 0\n                for i in range(n):\n                    cost += dist_matrix[sol[i-1], sol[i]]\n                return cost\n\n            old_cost1 = calculate_cost(base_solution, distance_matrix_1)\n            new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n            old_cost2 = calculate_cost(base_solution, distance_matrix_2)\n            new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement >= 0:\n                new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7337128566478723,
            1.5209420323371887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with lowest normalized objective values\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    normalized_scores = [((obj[0]/min_obj1) + (obj[1]/min_obj2)) for obj in objectives]\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 2:\n        # Select two random segments to invert\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        # Ensure segments don't overlap\n        if b <= c:\n            # Invert first segment\n            new_solution[a:b] = new_solution[a:b][::-1]\n            # Invert second segment\n            new_solution[c:d] = new_solution[c:d][::-1]\n\n            # Calculate potential improvement\n            def calculate_cost(sol, dist_matrix):\n                cost = 0\n                for i in range(n):\n                    cost += dist_matrix[sol[i-1], sol[i]]\n                return cost\n\n            old_cost1 = calculate_cost(base_solution, distance_matrix_1)\n            new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n            old_cost2 = calculate_cost(base_solution, distance_matrix_2)\n            new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement >= 0:\n                new_solution = base_solution.copy()\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    }
]