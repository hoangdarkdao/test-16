[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment-based perturbation\n    n = len(new_solution)\n    if n < 4:\n        # If too small, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select three random segments to modify\n        segments = np.sort(np.random.choice(n, 3, replace=False))\n        a, b, c = segments\n\n        # Extract segments\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Recombine segments with novel perturbation\n        new_order = np.concatenate([\n            segment1,\n            segment3[::-1],  # Reverse middle segment\n            segment2,\n            segment4\n        ])\n\n        # Ensure all nodes are visited exactly once\n        if len(np.unique(new_order)) == n:\n            new_solution = new_order\n\n    return new_solution\n\n",
          "score": [
               -0.79853724529653,
               0.20083975791931152
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a promising solution from the archive by prioritizing those with the highest combined normalized objective values, indicating potential for improvement. It then applies a hybrid local search operator that combines a novel 3-opt move with a dynamic edge selection strategy, where edges are chosen based on their contribution to both objectives, ensuring feasibility by maintaining a Hamiltonian cycle. The algorithm dynamically adjusts the balance between objectives during the search, using a weighted sum of normalized objective values to guide the selection of edges for perturbation. The 3-opt move is applied in a way that minimizes the increase in the total tour length for both objectives, leveraging the distance matrices to compute edge costs efficiently. The process repeats for a fixed number of iterations or until no further improvement is found, with the final solution being the best encountered during the search.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid 3-opt with dynamic edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Extract the edges\n    a, b, c = new_solution[i], new_solution[(i+1)%n], new_solution[j]\n    d, e, f = new_solution[(j+1)%n], new_solution[k], new_solution[(k+1)%n]\n\n    # Compute the cost of the current and new configurations\n    # Current cost: a-b, b-c, c-d, d-e, e-f\n    current_cost = (distance_matrix_1[a, b] + distance_matrix_1[b, c] + distance_matrix_1[c, d] + distance_matrix_1[d, e] + distance_matrix_1[e, f] +\n                    distance_matrix_2[a, b] + distance_matrix_2[b, c] + distance_matrix_2[c, d] + distance_matrix_2[d, e] + distance_matrix_2[e, f])\n\n    # New cost: a-c, c-b, b-e, e-d, d-f\n    new_cost = (distance_matrix_1[a, c] + distance_matrix_1[c, b] + distance_matrix_1[b, e] + distance_matrix_1[e, d] + distance_matrix_1[d, f] +\n                distance_matrix_2[a, c] + distance_matrix_2[c, b] + distance_matrix_2[b, e] + distance_matrix_2[e, d] + distance_matrix_2[d, f])\n\n    # Apply the move if it improves the combined cost\n    if new_cost < current_cost:\n        # Reconstruct the tour\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        new_solution[j+1:k+1] = np.flip(new_solution[j+1:k+1])\n        new_solution[k+1:] = np.roll(new_solution[k+1:], shift=1)\n\n    return new_solution\n\n",
          "score": [
               -0.8420272791118616,
               0.2737277150154114
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising base solution\n    def selection_criterion(sol_obj):\n        # Combine dominance and diversity metrics\n        sol, obj = sol_obj\n        # Simple criterion: prioritize lower objective values\n        return obj[0] + obj[1]\n\n    # Sort by selection criterion\n    archive_sorted = sorted(archive, key=selection_criterion)\n    base_solution, _ = archive_sorted[0]\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid operator: combination of restricted 3-opt and biased edge exchange\n    if n >= 4:\n        # Select three distinct positions with some randomness\n        i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n        # Apply restricted 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Apply biased edge exchange\n        # Prefer edges that improve both objectives when possible\n        for _ in range(2):  # Limit the number of exchanges\n            a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n            # Check if exchange improves both objectives\n            old_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n            new_edges = [(new_solution[a-1], new_solution[b]), (new_solution[b-1], new_solution[a])]\n\n            old_cost1 = sum(distance_matrix_1[u][v] for u, v in old_edges)\n            new_cost1 = sum(distance_matrix_1[u][v] for u, v in new_edges)\n            old_cost2 = sum(distance_matrix_2[u][v] for u, v in old_edges)\n            new_cost2 = sum(distance_matrix_2[u][v] for u, v in new_edges)\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if not (len(new_solution) == len(np.unique(new_solution))):\n        raise ValueError(\"Generated solution is not a valid tour\")\n\n    return new_solution\n\n",
          "score": [
               -0.8446671578572267,
               0.2885757088661194
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first intelligently selects a solution from the archive by prioritizing those with lower combined objective values and higher variance in their objectives to identify Pareto-efficient solutions with potential for improvement. It then applies a hybrid local search operator that combines a modified 3-opt heuristic with a biased random walk to explore the solution space, ensuring feasibility by validating all candidate moves before execution. The operator selectively disrupts and repairs segments of the tour, using the distance matrices to guide moves that improve both objectives, while the biased random walk introduces controlled exploration to escape local optima. The function returns the new neighbor solution after validating its feasibility and ensuring it represents a valid TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value and high variance\n    archive_sorted = sorted(archive, key=lambda x: (sum(x[1]), -abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with biased random walk\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 distinct edges to modify\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Generate candidate moves (3-opt variants)\n    candidates = [\n        # Standard 3-opt\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[k:]]),\n        # Biased random walk\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n    ]\n\n    # Evaluate candidates based on both objectives\n    best_candidate = None\n    min_cost = float('inf')\n\n    for candidate in candidates:\n        if len(set(candidate)) != n:  # Ensure validity\n            continue\n\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_candidate = candidate.copy()\n\n    # If no improvement found, perform a small perturbation\n    if best_candidate is None:\n        i, j = np.random.choice(n, size=2, replace=False)\n        best_candidate = new_solution.copy()\n        best_candidate[i], best_candidate[j] = best_candidate[j], best_candidate[i]\n\n    return best_candidate\n\n",
          "score": [
               -0.838563790971558,
               0.2600090503692627
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for local improvement using a combination of crowding distance and objective-space dominance analysis. It then intelligently selects one such solution based on a weighted random selection that favors solutions with high crowding distance or non-dominated status. For the local search, it employs a hybrid approach that combines a novel 'segmented inversion' operator with a 'multi-objective edge insertion' strategy. The segmented inversion randomly selects a segment of the tour and reverses it, while the edge insertion strategy evaluates all possible insertions of non-adjacent edges to improve both objectives. The function ensures feasibility by always validating the generated neighbor solution before returning it, guaranteeing it remains a valid TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate crowding distance (simplified)\n        crowding_dist = obj[0] + obj[1]  # Sum of objectives as a proxy\n        candidates.append((sol, obj, crowding_dist))\n\n    # Step 2: Select a solution with high crowding distance or non-dominated status\n    candidates.sort(key=lambda x: -x[2])  # Sort by crowding distance (descending)\n    selected = candidates[0][0].copy()  # Start with the most promising\n\n    # Step 3: Apply hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Segmented inversion\n    if n > 2:\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Edge insertion (multi-objective)\n    best_improvement = 0\n    best_new_solution = new_solution.copy()\n\n    for i in range(n):\n        for j in range(i+2, n):\n            # Try inserting edge (i+1) after j\n            temp_sol = new_solution.copy()\n            temp_sol = np.concatenate([temp_sol[:i+1], temp_sol[i+2:j+1], temp_sol[i+1:i+2], temp_sol[j+1:]])\n\n            # Calculate improvement\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[i+2]] + distance_matrix_1[new_solution[j], new_solution[i+1]]\n            improvement1 = old_cost1 - new_cost1\n\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[i+2]] + distance_matrix_2[new_solution[j], new_solution[i+1]]\n            improvement2 = old_cost2 - new_cost2\n\n            total_improvement = improvement1 + improvement2\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_new_solution = temp_sol.copy()\n\n    # Ensure feasibility\n    if len(np.unique(best_new_solution)) != n:\n        best_new_solution = new_solution.copy()  # Fallback to original if invalid\n\n    return best_new_solution\n\n",
          "score": [
               -0.9465775495376276,
               1.375964343547821
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Multi-Objective Segmented Recombination with Stochastic Perturbation,\" selects a base solution from the archive by prioritizing those with the highest crowding distance in the objective space to ensure diversity, then applies a hybrid operator that combines segmented recombination with stochastic perturbation. This operator first divides the tour into three segments, performs a controlled crossover between these segments from different solutions in the archive, and then applies a stochastic perturbation that selectively reverses segments based on a probability inversely proportional to their improvement potential in both objectives. The algorithm ensures feasibility by validating the solution structure and repairing any invalid segments through a greedy local search, while maintaining a balance between exploitation and exploration through adaptive parameter tuning.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution with highest crowding distance for diversity\n    def crowding_distance(obj1, obj2):\n        if len(archive) < 3:\n            return 0\n        sorted_obj1 = sorted(archive, key=lambda x: x[1][0])\n        sorted_obj2 = sorted(archive, key=lambda x: x[1][1])\n        dist1 = abs(sorted_obj1[1][1][0] - sorted_obj1[0][1][0]) if len(archive) > 1 else 0\n        dist2 = abs(sorted_obj2[1][1][1] - sorted_obj2[0][1][1]) if len(archive) > 1 else 0\n        return dist1 + dist2\n\n    archive_sorted = sorted(archive, key=lambda x: -crowding_distance(x[1][0], x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Segmented recombination with stochastic perturbation\n    n = len(base_solution)\n    new_solution = np.zeros_like(base_solution)\n\n    # Divide into three segments\n    seg1 = base_solution[:n//3]\n    seg2 = base_solution[n//3:2*n//3]\n    seg3 = base_solution[2*n//3:]\n\n    # Select another solution for crossover\n    if len(archive) > 1:\n        other_sol = archive[1][0]\n        other_seg1 = other_sol[:n//3]\n        other_seg2 = other_sol[n//3:2*n//3]\n        other_seg3 = other_sol[2*n//3:]\n\n        # Perform crossover between segments\n        if np.random.rand() < 0.5:\n            seg1, seg2 = seg2, seg1\n        if np.random.rand() < 0.5:\n            seg2, seg3 = seg3, seg2\n\n        # Merge segments\n        new_solution = np.concatenate([seg1, seg2, seg3])\n    else:\n        new_solution = base_solution.copy()\n\n    # Stochastic perturbation\n    for i in range(n):\n        if np.random.rand() < 0.1:  # 10% chance to perturb\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate improvement potential\n                old_edges = [\n                    (new_solution[i-1], new_solution[i]),\n                    (new_solution[i], new_solution[(i+1)%n]),\n                    (new_solution[j-1], new_solution[j]),\n                    (new_solution[j], new_solution[(j+1)%n])\n                ]\n                new_edges = [\n                    (new_solution[i-1], new_solution[j]),\n                    (new_solution[j], new_solution[(i+1)%n]),\n                    (new_solution[j-1], new_solution[i]),\n                    (new_solution[i], new_solution[(j+1)%n])\n                ]\n\n                old_cost1 = sum(distance_matrix_1[u][v] for u, v in old_edges)\n                new_cost1 = sum(distance_matrix_1[u][v] for u, v in new_edges)\n                old_cost2 = sum(distance_matrix_2[u][v] for u, v in old_edges)\n                new_cost2 = sum(distance_matrix_2[u][v] for u, v in new_edges)\n\n                improvement_prob = 0.5\n                if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                    improvement_prob = 0.8\n\n                if np.random.rand() < improvement_prob:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate and repair if necessary\n    if len(set(new_solution)) != n:\n        # Simple repair: greedy insertion of missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            best_pos = 0\n            best_cost = float('inf')\n            for i in range(n):\n                test_sol = new_solution.copy()\n                test_sol = np.insert(test_sol, i, node)\n                cost1 = sum(distance_matrix_1[test_sol[j]][test_sol[(j+1)%(n+1)]] for j in range(n+1))\n                cost2 = sum(distance_matrix_2[test_sol[j]][test_sol[(j+1)%(n+1)]] for j in range(n+1))\n                if cost1 + cost2 < best_cost:\n                    best_cost = cost1 + cost2\n                    best_pos = i\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.8675493005899209,
               1.3199889063835144
          ]
     },
     {
          "algorithm": "{The common backbone idea in the provided algorithms is the selection of promising solutions from an archive based on their objective values and application of hybrid local search operators to generate improved neighbors while ensuring feasibility. The new algorithm will first identify solutions with high potential for improvement by analyzing their objective values and diversity, then apply a novel 'multi-segment inversion and edge reassignment' strategy that randomly selects multiple non-overlapping segments of the tour, reverses each segment, and then optimally reassigns edges between segments to improve both objectives, all while maintaining feasibility by ensuring no nodes are skipped or revisited.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate potential improvement score (combination of objective values and diversity)\n        improvement_score = (obj[0] + obj[1]) / (1 + np.var(obj))\n        candidates.append((sol, improvement_score))\n\n    candidates.sort(key=lambda x: -x[1])\n    selected = candidates[0][0].copy()\n\n    # Step 2: Apply multi-segment inversion and edge reassignment\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Generate multiple non-overlapping segments\n    segments = []\n    remaining = list(range(n))\n    while len(remaining) > 1:\n        # Randomly select segment length\n        seg_length = random.randint(2, min(5, len(remaining)))\n        # Randomly select starting point\n        start_idx = random.choice(remaining)\n        start_pos = remaining.index(start_idx)\n        # Get segment indices\n        seg_indices = remaining[start_pos:start_pos+seg_length]\n        segments.append(seg_indices)\n        # Remove segment from remaining\n        remaining = [x for x in remaining if x not in seg_indices]\n\n    # Reverse each segment\n    for seg in segments:\n        if len(seg) > 1:\n            new_solution[seg] = new_solution[seg][::-1]\n\n    # Optimally reassign edges between segments\n    for i in range(len(segments)-1):\n        seg1 = segments[i]\n        seg2 = segments[i+1]\n\n        # Find best edge to connect segments\n        best_improvement = 0\n        best_edge = None\n\n        # Try all possible connections between segments\n        for a in seg1:\n            for b in seg2:\n                # Current edges\n                prev_a = new_solution[a-1] if a > 0 else new_solution[-1]\n                next_a = new_solution[(a+1)%n]\n                prev_b = new_solution[b-1] if b > 0 else new_solution[-1]\n                next_b = new_solution[(b+1)%n]\n\n                # Current costs\n                current_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                                distance_matrix_1[new_solution[a], next_a] +\n                                distance_matrix_1[prev_b, new_solution[b]] +\n                                distance_matrix_1[new_solution[b], next_b])\n                current_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                                distance_matrix_2[new_solution[a], next_a] +\n                                distance_matrix_2[prev_b, new_solution[b]] +\n                                distance_matrix_2[new_solution[b], next_b])\n\n                # New costs if we connect a to b\n                new_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                            distance_matrix_1[new_solution[a], new_solution[b]] +\n                            distance_matrix_1[new_solution[b], next_a] +\n                            distance_matrix_1[prev_b, new_solution[b]] +\n                            distance_matrix_1[new_solution[b], next_b])\n                new_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                            distance_matrix_2[new_solution[a], new_solution[b]] +\n                            distance_matrix_2[new_solution[b], next_a] +\n                            distance_matrix_2[prev_b, new_solution[b]] +\n                            distance_matrix_2[new_solution[b], next_b])\n\n                improvement = (current_cost1 + current_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_edge = (a, b)\n\n        # Apply the best edge connection\n        if best_edge:\n            a, b = best_edge\n            # Reorder the solution to connect a to b\n            a_pos = np.where(new_solution == a)[0][0]\n            b_pos = np.where(new_solution == b)[0][0]\n\n            if a_pos > b_pos:\n                a_pos, b_pos = b_pos, a_pos\n\n            # Reorder the segment between a and b\n            new_solution[a_pos+1:b_pos] = new_solution[a_pos+1:b_pos][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
          "score": [
               -0.955673343787872,
               1.648804247379303
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the current best)\n    selected = None\n    max_gap = -1\n    for sol, obj in archive:\n        gap = abs(obj[0] - obj[1])  # Measure the diversity of objectives\n        if gap > max_gap:\n            max_gap = gap\n            selected = sol\n\n    if selected is None:\n        selected = archive[0][0]\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine 3-opt with a biased random swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three segments to perform a 3-opt move\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Create all possible 3-opt variants and select the best one\n    variants = [\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:][::-1]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:][::-1]])\n    ]\n\n    # Evaluate variants based on both objectives\n    best_variant = None\n    best_score = float('inf')\n    for variant in variants:\n        cost1 = sum(distance_matrix_1[variant[i], variant[i+1]] for i in range(-1, n-1))\n        cost2 = sum(distance_matrix_2[variant[i], variant[i+1]] for i in range(-1, n-1))\n        score = cost1 + cost2  # Simple weighted sum for selection\n        if score < best_score:\n            best_score = score\n            best_variant = variant\n\n    if best_variant is not None:\n        new_solution = best_variant.copy()\n\n    # Apply a biased random swap based on distance matrix\n    a, b = random.sample(range(n), 2)\n    if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a]] < \\\n       distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               -0.6417830066181451,
               0.25273948907852173
          ]
     },
     {
          "algorithm": "{This new algorithm employs a novel adaptive segment relocation strategy that dynamically evaluates and reorders multiple segments of the tour based on their contribution to both objectives, combining them into a single cohesive segment before relocating to a position that optimizes the trade-off between the two objectives. It uses a weighted sum of normalized costs to guide segment selection and relocation, with probabilistic acceptance criteria that balance exploration and exploitation. The algorithm also incorporates a novel segment merging mechanism that combines adjacent segments when their combined cost improvement outweighs their individual contributions, followed by a segment splitting operation to reintroduce diversity while maintaining feasibility. The process is repeated iteratively with decreasing segment sizes to refine the solution, ensuring both objectives are improved incrementally without excessive computational overhead.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_archive = [(sol, (obj[0]/distance_matrix_1.max(), obj[1]/distance_matrix_2.max())) for sol, obj in archive]\n    selected_idx = np.argmin([sum(obj) for _, obj in normalized_archive])\n    base_solution = normalized_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with weighted cost evaluation\n    segment_sizes = [2, 3, 4]  # Try different segment sizes\n    for size in segment_sizes:\n        for _ in range(3):  # Try multiple times per segment size\n            # Select a random segment\n            start = np.random.randint(0, n - size)\n            segment = new_solution[start:start+size]\n\n            # Calculate segment's contribution to both objectives\n            seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(size-1)) + \\\n                        distance_matrix_1[new_solution[start-1], segment[0]] + \\\n                        distance_matrix_1[segment[-1], new_solution[start+size]]\n            seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(size-1)) + \\\n                        distance_matrix_2[new_solution[start-1], segment[0]] + \\\n                        distance_matrix_2[segment[-1], new_solution[start+size]]\n\n            # Calculate weighted cost (prioritize the objective that needs more improvement)\n            total_cost = normalized_archive[selected_idx][1]\n            weight1 = total_cost[1] / sum(total_cost)\n            weight2 = total_cost[0] / sum(total_cost)\n            weighted_cost = weight1 * seg_cost1 + weight2 * seg_cost2\n\n            # Try inserting the segment at different positions\n            best_pos = -1\n            best_improvement = 0\n            for pos in range(n - size + 1):\n                if pos >= start and pos <= start + size:\n                    continue  # Skip positions within the original segment\n\n                # Create candidate solution\n                candidate = np.delete(new_solution, range(start, start+size))\n                candidate = np.insert(candidate, pos, segment)\n\n                # Calculate new costs\n                new_cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                new_cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n                # Calculate improvement\n                improvement = (seg_cost1 - new_cost1) * weight1 + (seg_cost2 - new_cost2) * weight2\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            # Apply the best move if it improves the solution\n            if best_pos != -1 and best_improvement > 0:\n                new_solution = np.delete(new_solution, range(start, start+size))\n                new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n",
          "score": [
               -0.9042006468204246,
               12.653028070926666
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the backbone idea of combining local search with structural diversification, but instead of relying on edge exchanges or segment swaps, it employs a novel \"node reordering\" mechanism that dynamically reassigns nodes to positions based on their relative contributions to both objectives. The algorithm first selects a solution from the archive using a hybrid fitness metric that balances objective values with structural diversity, then applies a probabilistic node reordering strategy where nodes are moved to positions that minimize the combined cost improvement while maintaining feasibility. This approach ensures both exploration of the solution space and exploitation of objective-specific improvements, creating a more diverse set of high-quality neighbors compared to traditional methods.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a hybrid fitness metric\n    def compute_fitness(solution, objective):\n        # Normalize objectives\n        max_obj1 = max(obj[0] for _, obj in archive)\n        max_obj2 = max(obj[1] for _, obj in archive)\n        norm_obj1 = objective[0] / max_obj1 if max_obj1 != 0 else 0\n        norm_obj2 = objective[1] / max_obj2 if max_obj2 != 0 else 0\n\n        # Compute edge diversity\n        edges = set()\n        for i in range(len(solution)):\n            u = solution[i]\n            v = solution[(i + 1) % len(solution)]\n            edges.add((min(u, v), max(u, v)))\n        edge_diversity = len(edges)\n\n        # Fitness score: balance between objectives and edge diversity\n        fitness = 0.6 * (norm_obj1 + norm_obj2) + 0.4 * (1 / edge_diversity if edge_diversity > 0 else 0)\n        return fitness\n\n    # Evaluate all solutions in the archive and select the best\n    best_solution = None\n    best_fitness = float('-inf')\n    for solution, objective in archive:\n        fitness = compute_fitness(solution, objective)\n        if fitness > best_fitness:\n            best_fitness = fitness\n            best_solution = solution.copy()\n\n    if best_solution is None:\n        best_solution = archive[0][0].copy()\n\n    new_solution = best_solution.copy()\n\n    # Apply node reordering mechanism\n    n = len(new_solution)\n    if n < 2:\n        return new_solution\n\n    # Compute current costs\n    def compute_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(len(solution)):\n            u = solution[i]\n            v = solution[(i + 1) % len(solution)]\n            cost += distance_matrix[u, v]\n        return cost\n\n    original_cost1 = compute_cost(best_solution, distance_matrix_1)\n    original_cost2 = compute_cost(best_solution, distance_matrix_2)\n\n    # Select a random node to reorder\n    node_to_move = np.random.randint(0, n)\n    moved_node = new_solution[node_to_move]\n\n    # Find the best position to insert the moved node\n    best_pos = -1\n    best_cost_diff = float('inf')\n\n    for pos in range(n):\n        if pos == node_to_move or pos == (node_to_move - 1) % n or pos == (node_to_move + 1) % n:\n            continue  # Skip adjacent positions to maintain some structure\n\n        # Create a temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution = np.delete(temp_solution, node_to_move)\n        temp_solution = np.insert(temp_solution, pos, moved_node)\n\n        # Compute new costs\n        new_cost1 = compute_cost(temp_solution, distance_matrix_1)\n        new_cost2 = compute_cost(temp_solution, distance_matrix_2)\n\n        # Compute cost difference\n        cost_diff = (new_cost1 - original_cost1) + (new_cost2 - original_cost2)\n\n        if cost_diff < best_cost_diff:\n            best_cost_diff = cost_diff\n            best_pos = pos\n\n    # Apply the best move if it improves both objectives or with a probability\n    if best_pos != -1:\n        if best_cost_diff <= 0 or np.random.random() < 0.3:  # Accept improvement or with 30% probability\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, best_pos, moved_node)\n\n    return new_solution\n\n",
          "score": [
               -0.8956407717669245,
               4.361228108406067
          ]
     }
]