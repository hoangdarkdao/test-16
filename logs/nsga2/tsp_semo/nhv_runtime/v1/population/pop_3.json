[
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that combines dynamic path fragmentation with probabilistic node swapping and objective-guided segment inversion to explore high-quality diverse neighborhoods while maintaining feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    candidates = [sol for sol, obj in archive if (obj[0] + obj[1]) <= avg_cost * 1.2]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    selected = random.choice(candidates)\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic path fragmentation\n    frag_size = max(2, min(5, n // 5))\n    breaks = sorted(random.sample(range(1, n), frag_size - 1))\n    fragments = []\n    prev = 0\n    for b in breaks:\n        fragments.append(new_solution[prev:b])\n        prev = b\n    fragments.append(new_solution[prev:])\n\n    # Phase 2: Probabilistic node swapping\n    if random.random() < 0.5:\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Phase 3: Objective-guided segment inversion\n    if random.random() < 0.3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 6, n - 1))\n        segment = new_solution[start:end+1]\n        obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        if obj1 + obj2 > (obj1 + obj2) * 1.1:\n            new_solution[start:end+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9592359181059527,
            0.4170905351638794
        ]
    },
    {
        "algorithm": "{A novel adaptive multi-phase local search algorithm that combines dynamic segment reconfiguration, probabilistic node insertion, and objective-weighted edge reversal with enhanced selection criteria and parameter tuning to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Enhanced selection: prioritize solutions with balanced improvement potential\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    candidates = [sol for sol, obj in archive if (obj[0] + obj[1]) <= avg_cost * 1.1]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    selected = random.choice(candidates)\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic segment reconfiguration with adaptive size\n    segment_size = max(2, min(10, n // 3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    new_segment = np.concatenate([segment[:1], segment[1:][::-1]])\n    new_solution[start:end] = new_segment\n\n    # Phase 2: Probabilistic node insertion with higher probability\n    if random.random() < 0.7:\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Phase 3: Objective-weighted edge reversal with tighter threshold\n    if random.random() < 0.5:\n        a, b = sorted(random.sample(range(n), 2))\n        current_cost = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n        reversed_cost = distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        if reversed_cost < current_cost * 0.85:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7057421433053148,
            0.13546496629714966
        ]
    }
]