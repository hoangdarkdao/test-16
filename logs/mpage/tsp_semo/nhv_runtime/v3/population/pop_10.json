[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid Local Search: Combine 2-opt with a novel segment relocation\n    n = len(base_solution)\n\n    # Step 1: Randomly select two non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Step 2: Relocate the segment between a and b to after c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Step 3: Apply 2-opt on the relocated segment\n    i, j = sorted(np.random.choice(range(len(segment)), 2, replace=False))\n    segment[i], segment[j] = segment[j], segment[i]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
          "score": [
               -0.6753597224650268,
               0.0938725471496582
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in non_dominated])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1.0 / (normalized_obj + 1e-10)\n    probs = weights.sum(axis=1) / weights.sum()\n    selected_idx = np.random.choice(len(non_dominated), p=probs)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Hybrid local search - edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to remove and reinsert\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(n - 1, 5))  # Segment length between 2 and 4\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        remaining = new_solution[end:start]\n\n    # Find a new position to insert the segment\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    if insert_pos == 0:\n        new_solution = np.concatenate([segment, remaining])\n    elif insert_pos == len(remaining):\n        new_solution = np.concatenate([remaining, segment])\n    else:\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Randomly relocate a node\n    if n > 2:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 4: Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9880560877894095,
               0.30501770973205566
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol_i, obj_i))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Step 2: Select a solution based on objective values and diversity\n    objectives = np.array([obj for _, obj in pareto_front])\n    normalized_obj = objectives / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = []\n    for sol, _ in pareto_front:\n        unique_edges = set()\n        for i in range(len(sol)):\n            unique_edges.add((min(sol[i], sol[(i+1)%len(sol)]), max(sol[i], sol[(i+1)%len(sol)])))\n        diversity_scores.append(len(unique_edges))\n    diversity_scores = np.array(diversity_scores) / (np.max(diversity_scores) + 1e-10)\n\n    selection_scores = 0.7 * (1 - normalized_obj[:, 0]) + 0.3 * diversity_scores\n    selected_idx = np.argmax(selection_scores)\n    base_solution = pareto_front[selected_idx][0].copy()\n\n    # Step 3: Multi-segment crossover operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select two random segments from the base solution\n    seg1_start = np.random.randint(0, n)\n    seg1_length = np.random.randint(2, min(4, n//2))\n    seg1_end = (seg1_start + seg1_length) % n\n\n    seg2_start = np.random.randint(0, n)\n    while abs(seg2_start - seg1_start) < 2 or abs(seg2_start - seg1_end) < 2:\n        seg2_start = np.random.randint(0, n)\n    seg2_length = np.random.randint(2, min(4, n//2))\n    seg2_end = (seg2_start + seg2_length) % n\n\n    # Extract segments\n    if seg1_start < seg1_end:\n        seg1 = new_solution[seg1_start:seg1_end]\n    else:\n        seg1 = np.concatenate([new_solution[seg1_start:], new_solution[:seg1_end]])\n\n    if seg2_start < seg2_end:\n        seg2 = new_solution[seg2_start:seg2_end]\n    else:\n        seg2 = np.concatenate([new_solution[seg2_start:], new_solution[:seg2_end]])\n\n    # Select a third segment from another solution in the archive\n    other_sol = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n    seg3_start = np.random.randint(0, n)\n    seg3_length = np.random.randint(2, min(4, n//2))\n    seg3_end = (seg3_start + seg3_length) % n\n\n    if seg3_start < seg3_end:\n        seg3 = other_sol[seg3_start:seg3_end]\n    else:\n        seg3 = np.concatenate([other_sol[seg3_start:], other_sol[:seg3_end]])\n\n    # Combine segments to form new solution\n    remaining_nodes = set(range(n)) - set(seg1) - set(seg2) - set(seg3)\n    new_solution = np.concatenate([seg1, seg2, seg3, np.array(list(remaining_nodes))])\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0059111292081795,
               0.346810519695282
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of hybrid local search operations by combining edge assembly with a novel segment insertion strategy. It first selects a promising solution from the archive based on a weighted objective function that balances both objectives, then applies a hybrid local search that involves reversing a randomly selected segment and inserting it into a different position in the tour, while also performing a novel edge reconnection operation that swaps edges between non-adjacent segments to further improve the solution. The algorithm ensures feasibility by verifying no duplicates or missing nodes, and includes a fallback mechanism to a simple segment reversal if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.6, 0.4])  # Weight for each objective\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment reversal and insertion with edge reconnection\n    # Step 1: Select a random segment to reverse\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = base_solution[i:j+1][::-1]\n\n    # Step 2: Insert the reversed segment at a different position\n    k = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([base_solution[:k], segment, base_solution[k:]])\n\n    # Step 3: Perform edge reconnection between non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    if b - a > 1 and len(new_solution) - b > 1:\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:] = new_solution[b:][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment reversal\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8660185612302642,
               0.10953599214553833
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the hybrid approach seen in both provided solutions by combining a novel segment inversion strategy with a bi-objective-aware edge reconnection mechanism. It first selects a solution from the archive based on a weighted combination of its objectives, then applies a segment inversion that reverses a randomly selected segment while considering both distance matrices to maintain balance between objectives. Following this, it performs a targeted edge reconnection by swapping edges that show potential for improvement in both objective spaces, ensuring feasibility through careful validation. The method also incorporates a probabilistic element to occasionally perform a complete segment relocation when the current solution shows limited improvement, promoting exploration while preserving the tour's validity.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1/(obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Bi-objective segment inversion with adaptive length\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(3, min(8, n-2))  # Longer segments for more disruption\n    segment_end = (segment_start + segment_length) % n\n\n    if segment_start < segment_end:\n        new_solution[segment_start:segment_end] = base_solution[segment_start:segment_end][::-1]\n    else:\n        new_solution[:segment_end] = base_solution[:segment_end][::-1]\n        new_solution[segment_start:] = base_solution[segment_start:][::-1]\n\n    # Bi-objective edge reconnection with multi-swap\n    for _ in range(3):  # More aggressive edge swaps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 + delta2 < 0:  # If improvement in both objectives\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment relocation based on objective balance\n    obj1, obj2 = archive[selected_idx][1]\n    if abs(obj1 - obj2) > 0.1 * (obj1 + obj2):  # If objectives are unbalanced\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9544661969002222,
               0.29038530588150024
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of hybrid local search operations by combining segment-based manipulation with a novel edge rotation strategy. It first selects a solution from the archive using a weighted objective function that prioritizes solutions with balanced improvements in both objectives, then applies a hybrid local search that involves rotating a randomly selected segment by a fixed number of positions and inserting it into a different position in the tour, while also performing a novel edge rotation operation that cyclically permutes edges between non-adjacent segments to explore diverse solutions. The algorithm ensures feasibility by verifying no duplicates or missing nodes, and includes a fallback mechanism to a simple segment rotation if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    weighted_scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Hybrid local search: segment rotation and insertion with edge rotation\n    # Step 1: Select a random segment to rotate\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    segment = base_solution[i:j+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n\n    # Step 2: Insert the rotated segment at a different position\n    k = np.random.choice(range(1, n-1))\n    new_solution = np.concatenate([base_solution[:k], rotated_segment, base_solution[k:]])\n\n    # Step 3: Perform edge rotation between non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    if b - a > 1 and len(new_solution) - b > 1:\n        segment_a = new_solution[a:b]\n        segment_b = new_solution[b:]\n        rotation_a = np.random.randint(1, len(segment_a))\n        rotation_b = np.random.randint(1, len(segment_b))\n        new_solution[a:b] = np.roll(segment_a, rotation_a)\n        new_solution[b:] = np.roll(segment_b, rotation_b)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment rotation\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        rotation = np.random.randint(1, j - i + 1)\n        new_solution[i:j+1] = np.roll(base_solution[i:j+1], rotation)\n\n    return new_solution\n\n",
          "score": [
               -0.9354692806128575,
               0.13754773139953613
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a hierarchical local search approach that combines a multi-objective-aware node clustering strategy with a novel edge contraction-expansion mechanism. It first identifies clusters of nodes based on their proximity in both objective spaces, then selectively contracts edges between distant clusters while expanding edges within clusters, followed by a probabilistic node reordering that prioritizes edges with balanced distance improvements across objectives. The method incorporates a dynamic cluster size adjustment based on the current solution's objective balance, ensuring exploration of diverse neighborhoods while maintaining feasibility through careful validation and fallback mechanisms.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    obj_balance = np.abs(objectives[:, 0] - objectives[:, 1]) / (objectives.sum(axis=1) + 1e-6)\n    weights = 1.0 / (obj_balance + 1e-6)\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Cluster nodes based on both distance matrices\n    cluster_size = max(3, min(8, n // 3))\n    clusters = []\n    remaining = set(range(n))\n    while remaining:\n        center = np.random.choice(list(remaining))\n        cluster = [center]\n        remaining.remove(center)\n        for _ in range(cluster_size - 1):\n            if not remaining:\n                break\n            closest = min(remaining, key=lambda x: distance_matrix_1[center, x] + distance_matrix_2[center, x])\n            cluster.append(closest)\n            remaining.remove(closest)\n        clusters.append(cluster)\n\n    # Step 3: Edge contraction-expansion within clusters\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n        # Contract edges between cluster nodes\n        for i in range(len(cluster)):\n            for j in range(i+1, len(cluster)):\n                a, b = cluster[i], cluster[j]\n                if a > b:\n                    a, b = b, a\n                # Check if swapping a and b improves both objectives\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta1 + delta2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        # Expand edges within cluster\n        for i in range(len(cluster)-1):\n            a, b = cluster[i], cluster[i+1]\n            if a > b:\n                a, b = b, a\n            # Check if moving b after a improves both objectives\n            if b != (a+1)%n:\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta1 + delta2 < 0:\n                    # Move b after a\n                    node = new_solution[b]\n                    new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n                    insert_pos = np.where(new_solution == new_solution[a])[0][0] + 1\n                    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 4: Probabilistic node reordering based on objective balance\n    obj1, obj2 = archive[selected_idx][1]\n    if abs(obj1 - obj2) > 0.2 * (obj1 + obj2):\n        # More aggressive reordering when objectives are unbalanced\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            # Check if swapping segments improves both objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            if delta1 + delta2 < 0:\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 5: Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -1.0807467550296899,
               0.6731994152069092
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a high-quality neighbor solution in the bi-objective TSP involves first selecting a base solution from the archive by evaluating the potential improvement areas in both objective spaces, then applying a novel segment inversion and dynamic edge reconnection strategy that adaptively selects and inverts segments of varying lengths based on their relative performance in each objective space, while simultaneously reconnecting edges in a way that maintains tour validity and potentially reduces costs in either or both objectives. The algorithm uses a probabilistic segment selection mechanism that favors longer segments when they show promise in one objective but not the other, and incorporates a dynamic edge reconnection phase that prioritizes edges with high cost savings in either space, ensuring the solution remains feasible while exploring diverse regions of the search space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution based on potential improvement areas\n    base_solution, _ = archive[np.random.choice(len(archive))]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Dynamic segment selection and inversion\n    segment_length = np.random.randint(3, min(6, n//3))\n    start = np.random.randint(0, n - segment_length)\n\n    # Calculate segment costs and potential improvements\n    segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, start+segment_length-1))\n    segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, start+segment_length-1))\n\n    # Invert segment with probability based on cost improvement potential\n    cost_improvement_prob = min(1.0, (segment_cost1 + segment_cost2) / (np.median(distance_matrix_1) + np.median(distance_matrix_2)))\n    if np.random.rand() < cost_improvement_prob:\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 3: Adaptive edge reconnection\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Reconnect edges with potential savings in either objective\n        if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) or \\\n           (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4: Node relocation based on objective space performance\n    for _ in range(2):\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        # Calculate relocation potential in both objectives\n        current_cost1 = distance_matrix_1[new_solution[node_pos-1], node] + distance_matrix_1[node, new_solution[(node_pos+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[node_pos-1], node] + distance_matrix_2[node, new_solution[(node_pos+1)%n]]\n\n        best_pos = node_pos\n        best_cost1 = current_cost1\n        best_cost2 = current_cost2\n\n        # Search for better positions in both objectives\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n            new_cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            new_cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n            if (new_cost1 < best_cost1 and new_cost2 <= best_cost2) or (new_cost1 <= best_cost1 and new_cost2 < best_cost2):\n                best_pos = pos\n                best_cost1 = new_cost1\n                best_cost2 = new_cost2\n\n        if best_pos != node_pos:\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure solution remains valid\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
          "score": [
               -0.9893037508178055,
               0.3928150534629822
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a high-quality neighbor solution in the bi-objective TSP involves first identifying the most promising segments of the tour in each objective space by analyzing the distance matrices, then applying a novel adaptive segment fusion strategy that dynamically combines these segments based on their relative performance in both objectives, while simultaneously performing a probabilistic edge swapping mechanism that prioritizes connections with high potential for reducing costs in either or both spaces, and finally validating the solution to ensure it remains feasible while exploring diverse regions of the search space by incorporating a dynamic segment reordering phase that adapts to the specific characteristics of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution based on combined objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    combined_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify promising segments in each objective space\n    n = len(base_solution)\n    segment_length = max(2, n // 5)\n    segments = []\n    for i in range(0, n, segment_length):\n        segment = base_solution[i:i+segment_length]\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        segments.append((segment, cost1, cost2))\n\n    # Adaptive segment fusion strategy\n    new_solution = []\n    remaining_nodes = set(range(n))\n    current_node = base_solution[0]\n    new_solution.append(current_node)\n    remaining_nodes.remove(current_node)\n\n    while remaining_nodes:\n        # Find best segment to connect to current node\n        best_segment = None\n        best_score = float('inf')\n\n        for seg, cost1, cost2 in segments:\n            if not remaining_nodes.intersection(seg):\n                continue\n\n            # Calculate connection cost\n            last_in_new = new_solution[-1]\n            first_in_seg = seg[0]\n\n            # Combine objective scores with segment quality\n            connection_cost = (distance_matrix_1[last_in_new, first_in_seg] + distance_matrix_2[last_in_new, first_in_seg])\n            segment_quality = (cost1 + cost2) / len(seg)\n            total_score = connection_cost + 0.3 * segment_quality\n\n            if total_score < best_score:\n                best_score = total_score\n                best_segment = seg\n\n        if best_segment is None:\n            # Fallback to nearest neighbor\n            candidates = list(remaining_nodes)\n            nearest = min(candidates, key=lambda x: distance_matrix_1[current_node, x] + distance_matrix_2[current_node, x])\n            new_solution.append(nearest)\n            remaining_nodes.remove(nearest)\n            current_node = nearest\n        else:\n            # Add the best segment\n            for node in best_segment:\n                if node in remaining_nodes:\n                    new_solution.append(node)\n                    remaining_nodes.remove(node)\n            current_node = best_segment[-1]\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(new_solution) == n + 1 and len(np.unique(new_solution[:-1])) == n\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.931391441151007,
               0.14418554306030273
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Objective-aware path reconstruction strategy\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Phase 1: Identify critical nodes in each objective space\n    critical_nodes1 = np.argsort(np.sum(distance_matrix_1, axis=1))[:len(solutions)//2]\n    critical_nodes2 = np.argsort(np.sum(distance_matrix_2, axis=1))[:len(solutions)//2]\n    critical_nodes = np.unique(np.concatenate([critical_nodes1, critical_nodes2]))\n\n    # Phase 2: Select a solution with high diversity in objectives\n    obj_ranges = objectives.max(axis=0) - objectives.min(axis=0)\n    diversity_scores = np.prod(objectives / (obj_ranges + 1e-10), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Phase 3: Construct new solution by inserting critical nodes\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    current_node = base_solution[0]\n\n    while remaining_nodes:\n        new_solution.append(current_node)\n        remaining_nodes.remove(current_node)\n\n        # Find next node with best combined objective improvement\n        candidates = list(remaining_nodes)\n        if not candidates:\n            break\n\n        # Evaluate potential next nodes\n        candidate_scores = []\n        for candidate in candidates:\n            # Calculate potential improvement in both objectives\n            cost1 = distance_matrix_1[current_node, candidate]\n            cost2 = distance_matrix_2[current_node, candidate]\n\n            # Combine with critical node preference\n            is_critical = candidate in critical_nodes\n            score = (cost1 + cost2) * (1.5 if is_critical else 1.0)\n            candidate_scores.append(score)\n\n        # Select node with best combined score\n        next_idx = np.argmin(candidate_scores)\n        current_node = candidates[next_idx]\n\n    # Ensure Hamiltonian cycle\n    new_solution.append(new_solution[0])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9911737239425997,
               0.8463422656059265
          ]
     }
]