[
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt with a probabilistic edge exchange that prioritizes nodes with high edge diversity and objective trade-off potential, while adaptively adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 3-opt with probabilistic edge exchange\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Dynamic 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply dynamic 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2[::-1]]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1[::-1]])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Probabilistic edge exchange\n            if random.random() < 0.6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -1.0277778368353312,
            0.2724300026893616
        ]
    },
    {
        "algorithm": "{This new algorithm combines a dynamic segment relocation with an adaptive objective-biased edge insertion that selectively modifies segments based on their contribution to both objectives, while maintaining solution feasibility through a constrained perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions of each segment\n    segment_sizes = [random.randint(2, min(5, n//2)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(n), 3))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Decide whether to modify this segment based on objective balance\n        if obj1_contrib > obj2_contrib * 1.2:  # More in obj1, prioritize obj2\n            # Relocate segment to position that might improve obj2\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.2:  # More in obj2, prioritize obj1\n            # Insert segment in reverse order to potentially improve obj1\n            new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform both operations\n            if random.random() < 0.5:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9377224748701751,
            0.0983656644821167
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt with a probabilistic edge exchange that prioritizes nodes with high edge diversity and objective trade-off potential, while adaptively adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 3-opt with probabilistic edge exchange\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Dynamic 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply dynamic 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2[::-1]]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1[::-1]])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Probabilistic edge exchange\n            if random.random() < 0.6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -1.0277778368353312,
            0.2724300026893616
        ]
    },
    {
        "algorithm": "{This new algorithm combines a dynamic segment relocation with an adaptive objective-biased edge insertion that selectively modifies segments based on their contribution to both objectives, while maintaining solution feasibility through a constrained perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions of each segment\n    segment_sizes = [random.randint(2, min(5, n//2)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(n), 3))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Decide whether to modify this segment based on objective balance\n        if obj1_contrib > obj2_contrib * 1.2:  # More in obj1, prioritize obj2\n            # Relocate segment to position that might improve obj2\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.2:  # More in obj2, prioritize obj1\n            # Insert segment in reverse order to potentially improve obj1\n            new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform both operations\n            if random.random() < 0.5:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9377224748701751,
            0.0983656644821167
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt with a probabilistic edge exchange that prioritizes nodes with high edge diversity and objective trade-off potential, while adaptively adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 3-opt with probabilistic edge exchange\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Dynamic 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply dynamic 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2[::-1]]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1[::-1]])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Probabilistic edge exchange\n            if random.random() < 0.6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -1.0277778368353312,
            0.2724300026893616
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid approach combining adaptive k-segment inversion with a dynamic node reinsertion strategy, where segments are selected based on their objective trade-off potential and node positions, while reinsertion points are chosen probabilistically to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Adaptive k-segment inversion\n    k = random.randint(2, min(5, n//2))  # Number of segments to invert\n    segment_indices = sorted(random.sample(range(1, n), k-1))  # Split points\n    segments = np.split(new_solution, segment_indices)\n\n    # Invert segments with probability based on their objective trade-off\n    for i in range(len(segments)):\n        if random.random() < 0.6:  # 60% chance to invert\n            segments[i] = segments[i][::-1]\n\n    new_solution = np.concatenate(segments)\n\n    # Dynamic node reinsertion\n    for _ in range(3):  # Repeat for better exploration\n        if random.random() < 0.4:\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.9481425584841403,
            0.14084076881408691
        ]
    },
    {
        "algorithm": "{This new algorithm combines a dynamic segment relocation with an adaptive objective-biased edge insertion that selectively modifies segments based on their contribution to both objectives, while maintaining solution feasibility through a constrained perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions of each segment\n    segment_sizes = [random.randint(2, min(5, n//2)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(n), 3))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Decide whether to modify this segment based on objective balance\n        if obj1_contrib > obj2_contrib * 1.2:  # More in obj1, prioritize obj2\n            # Relocate segment to position that might improve obj2\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.2:  # More in obj2, prioritize obj1\n            # Insert segment in reverse order to potentially improve obj1\n            new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform both operations\n            if random.random() < 0.5:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9377224748701751,
            0.0983656644821167
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt with a probabilistic edge exchange that prioritizes nodes with high edge diversity and objective trade-off potential, while adaptively adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 3-opt with probabilistic edge exchange\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Dynamic 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply dynamic 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2[::-1]]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1[::-1]])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Probabilistic edge exchange\n            if random.random() < 0.6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -1.0277778368353312,
            0.2724300026893616
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt with a probabilistic edge exchange that prioritizes nodes with high edge diversity and objective trade-off potential, while adaptively adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 3-opt with probabilistic edge exchange\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Dynamic 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply dynamic 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2[::-1]]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1[::-1]])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Probabilistic edge exchange\n            if random.random() < 0.6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -1.0277778368353312,
            0.2724300026893616
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines an adaptive 3-opt with a stochastic edge inversion to explore the solution space, focusing on nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Adaptive 3-opt with stochastic edge inversion\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Adaptive 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply adaptive 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1]),\n                np.concatenate([segment1, segment2[::-1]])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Stochastic edge inversion\n            if random.random() < 0.4:\n                new_solution[i:j] = segment1[::-1]\n            else:\n                new_solution[j:k] = segment2[::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.9787162909951734,
            0.23318934440612793
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt with a probabilistic edge exchange that prioritizes nodes with high edge diversity and objective trade-off potential, while adaptively adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 3-opt with probabilistic edge exchange\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Dynamic 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply dynamic 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2[::-1]]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1[::-1]])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Probabilistic edge exchange\n            if random.random() < 0.6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -1.0277778368353312,
            0.2724300026893616
        ]
    },
    {
        "algorithm": "{This algorithm uses a novel \"edge-aware segment relocation with multi-objective adaptive perturbation\" that dynamically selects and relocates segments of the tour based on edge criticality in both objective spaces, while applying probabilistic perturbations to escape local optima and maintain solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate edge criticality scores (sum of distances in both objective spaces)\n    edge_scores = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        score = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n        edge_scores.append(score)\n\n    # Find the least critical edge (potential for improvement)\n    min_idx = np.argmin(edge_scores)\n    a, b = new_solution[min_idx], new_solution[(min_idx+1)%n]\n\n    # Find the most critical node to insert between a and b\n    candidates = [i for i in range(n) if i not in {min_idx, (min_idx+1)%n}]\n    if not candidates:\n        return new_solution\n\n    # Calculate insertion gain for each candidate\n    gains = []\n    for i in candidates:\n        u = new_solution[(i-1)%n]\n        v = new_solution[i]\n        w = new_solution[(i+1)%n]\n\n        # Calculate gain as reduction in combined distance\n        gain = (distance_matrix_1[u, v] + distance_matrix_1[v, w] +\n                distance_matrix_2[u, v] + distance_matrix_2[v, w]) - \\\n               (distance_matrix_1[u, a] + distance_matrix_1[a, b] + distance_matrix_1[b, w] +\n                distance_matrix_2[u, a] + distance_matrix_2[a, b] + distance_matrix_2[b, w])\n        gains.append(gain)\n\n    if not gains or max(gains) <= 0:\n        # Apply probabilistic perturbation if no improvement possible\n        if random.random() < 0.3:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n    # Perform the best insertion\n    best_candidate = candidates[np.argmax(gains)]\n    best_pos = (min_idx+1)%n if best_candidate > min_idx else min_idx\n\n    # Create new solution with insertion\n    temp = new_solution.copy()\n    temp = np.concatenate([temp[:best_pos], [temp[best_candidate]], temp[best_pos:]])\n    if best_candidate < best_pos:\n        temp = np.delete(temp, best_candidate)\n\n    # Verify feasibility\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    # Apply additional probabilistic perturbation\n    if random.random() < 0.2:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.973243170275442,
            0.2092185616493225
        ]
    }
]