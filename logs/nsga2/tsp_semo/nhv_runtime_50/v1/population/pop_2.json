[
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7639962521331065,
            0.04677629470825195
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9178105329874824,
            0.679682195186615
        ]
    }
]