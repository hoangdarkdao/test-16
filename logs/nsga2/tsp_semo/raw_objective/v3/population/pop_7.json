[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.496002494185099,
            8.748965748650448
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining segment reversal with a probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    selected_idx = np.argmin(np.sum(normalized_scores, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: segment reversal with probabilistic edge insertion\n        a, b = sorted(np.random.choice(N, 2, replace=False))\n\n        # Segment reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Probabilistic edge insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.252339302702418,
            5.669518134292408
        ]
    }
]