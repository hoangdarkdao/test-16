[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    scores = []\n    for sol, _ in archive:\n        # Calculate diversity score (number of unique edges not in other solutions)\n        diversity = 0\n        edges = set(zip(sol, np.roll(sol, -1)))\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges - other_edges)\n        scores.append(diversity)\n\n    if all(s == 0 for s in scores):\n        # If all solutions are identical, select randomly\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Normalize scores and select with probability\n        total = sum(scores)\n        probs = [s / total for s in scores]\n        idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for segment relocation\n        # Select segment length based on instance size\n        max_segment = min(5, n // 4)\n        segment_length = random.randint(2, max_segment)\n\n        # Select random segment\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find best insertion position that improves both objectives\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue  # Skip current position\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:start],\n                new_solution[start+segment_length:]\n            ])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[candidate[-1], candidate[0]]  # Complete the tour\n\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[candidate[-1], candidate[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and best_cost < float('inf'):\n            # Apply the best move\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[start+segment_length:]\n            ])\n    else:  # Edge insertion\n        # Select random edge to remove\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Select random node to insert between\n        k = random.randint(0, n-1)\n        while k == i or k == j or k == (i-1)%n:\n            k = random.randint(0, n-1)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]  # Reverse the edge\n        candidate = np.roll(candidate, -i)  # Make i the first element\n        candidate = np.concatenate([candidate[:1], candidate[2:k+1], candidate[1:2], candidate[k+1:]])\n        candidate = np.roll(candidate, i)  # Restore original order\n\n        # Check if the move is valid (visits all nodes exactly once)\n        if len(set(candidate)) == n:\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.602584769458544,
               5.827298074802924
          ]
     },
     {
          "algorithm": "{The new algorithm begins by selecting a base solution from the archive using a multi-criteria approach that combines objective values, diversity, and structural features, then employs a novel hybrid local search strategy that integrates adaptive segment swapping with probabilistic edge reversal, followed by a constrained node reinsertion phase to ensure feasibility while exploring the solution space more effectively than standard methods, ultimately generating a high-quality neighbor solution that balances exploration and exploitation through dynamic parameter adaptation and objective-aware move selection.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective and structural diversity\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Calculate combined objective score (normalized)\n        obj_score = (obj1 + obj2) / (sum(x[1][0] + x[1][1] for x in archive) / len(archive))\n\n        # Calculate structural diversity\n        edges = set(zip(sol, np.roll(sol, -1)))\n        diversity = 0\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges.symmetric_difference(other_edges))\n\n        # Combine scores with adaptive weights\n        alpha = 0.7 if len(archive) > 10 else 0.5\n        scores.append(alpha * obj_score + (1 - alpha) * diversity)\n\n    # Select solution with highest combined score\n    base_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Phase 1: Adaptive segment swapping\n    segment_length = max(3, min(7, n // 5))\n    for _ in range(2):\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        # Swap segments with probability based on objective improvement\n        seg1 = new_solution[start1:start1+segment_length]\n        seg2 = new_solution[start2:start2+segment_length]\n\n        # Calculate potential improvement\n        old_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                    distance_matrix_1[new_solution[-1], new_solution[0]] +\n                    sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                    distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        candidate = new_solution.copy()\n        candidate[start1:start1+segment_length] = seg2\n        candidate[start2:start2+segment_length] = seg1\n\n        new_cost = (sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) +\n                    distance_matrix_1[candidate[-1], candidate[0]] +\n                    sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) +\n                    distance_matrix_2[candidate[-1], candidate[0]])\n\n        if new_cost < old_cost or np.random.random() < 0.3:\n            new_solution = candidate\n\n    # Phase 2: Probabilistic edge reversal with objective awareness\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n\n        old_cost = (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]] +\n                    distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        new_cost = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] +\n                    distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]])\n\n        if new_cost < old_cost or np.random.random() < 0.2:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Phase 3: Constrained node reinsertion\n    for _ in range(2):\n        # Select a random node to remove\n        idx = np.random.randint(1, n-1)\n        node = new_solution[idx]\n\n        # Remove the node\n        candidate = np.concatenate([new_solution[:idx], new_solution[idx+1:]])\n\n        # Find best insertion position that minimizes both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            if pos == idx or pos == idx-1:\n                continue\n\n            # Insert node at position pos\n            temp = np.insert(candidate, pos, node)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[temp[-1], temp[0]]\n\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[temp[-1], temp[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               5.982530730904809,
               6.4238842089255845
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a novel adaptive path decomposition and recombination strategy that dynamically partitions the tour into segments based on both objective spaces' characteristics, then reconstructs the tour by interleaving these segments in a way that maximizes the trade-off between the two objectives. The selection process prioritizes solutions that exhibit non-dominated segments in the Pareto front, while the local search operator uses a probabilistic segment recombination mechanism guided by a multi-objective utility function that considers the segment's contribution to both objectives. The function ensures feasibility by maintaining the permutation property through a series of carefully designed segment swaps and rotations, with the segment length and recombination pattern determined by an adaptive probability model that learns from the current solution's structure and the distance matrices.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using adaptive segment analysis\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive path decomposition based on both objectives\n    segment_length = np.random.randint(3, min(7, n // 2))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Extract segment and analyze its contribution to both objectives\n    segment = new_solution[start_pos:start_pos + segment_length]\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length))\n\n    # Determine segment's Pareto dominance relative to the rest of the tour\n    total_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # Probabilistic recombination based on segment's characteristics\n    if segment_cost1 / total_cost1 < 0.3 or segment_cost2 / total_cost2 < 0.3:\n        # If segment is significantly worse in one objective, consider removing it\n        new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n        # Insert the segment in a different position\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n    else:\n        # If segment is balanced, consider rotating it\n        rotation = np.random.randint(1, segment_length)\n        segment = np.roll(segment, rotation)\n        new_solution[start_pos:start_pos + segment_length] = segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap to restore feasibility\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               6.4586950415254565,
               5.903120343468656
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-phase approach that combines probabilistic node selection, geometric transformation-based local search, and adaptive objective-weighted edge swapping to generate high-quality neighbors. It first identifies critical nodes based on their geometric properties and objective contributions, then applies a series of geometric transformations (scaling, rotation, and translation) to the solution's node coordinates in both objective spaces, followed by a targeted edge swapping phase that prioritizes edges with high potential for improving both objectives, with the swap probability dynamically adjusted based on the current solution's structure and the relative weights of the two objectives. The algorithm ensures feasibility by maintaining the permutation property and using a validation step to confirm the generated solution remains a valid TSP tour before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution with probability based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None] - objectives), axis=2)\n    probs = np.sum(diversity, axis=1)\n    probs = probs / np.sum(probs) if np.sum(probs) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Geometric transformation phase\n    coords1 = instance[base_solution, :2]  # First objective coordinates\n    coords2 = instance[base_solution, 2:]  # Second objective coordinates\n\n    # Calculate centroids\n    centroid1 = np.mean(coords1, axis=0)\n    centroid2 = np.mean(coords2, axis=0)\n\n    # Apply random geometric transformations\n    if np.random.random() < 0.5:\n        # Scale transformation\n        scale_factor = np.random.uniform(0.9, 1.1)\n        coords1 = centroid1 + (coords1 - centroid1) * scale_factor\n        coords2 = centroid2 + (coords2 - centroid2) * scale_factor\n    else:\n        # Rotation transformation\n        angle = np.random.uniform(-np.pi/6, np.pi/6)\n        rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)],\n                                   [np.sin(angle), np.cos(angle)]])\n        coords1 = centroid1 + (coords1 - centroid1) @ rotation_matrix\n        coords2 = centroid2 + (coords2 - centroid2) @ rotation_matrix\n\n    # Find nearest nodes in transformed spaces\n    transformed_instance1 = np.hstack([coords1, instance[:, 2:]])\n    transformed_instance2 = np.hstack([instance[:, :2], coords2])\n\n    # Create distance matrices for transformed spaces\n    def create_distance_matrix(coords):\n        n = len(coords)\n        dist_matrix = np.zeros((n, n))\n        for i in range(n):\n            for j in range(n):\n                dist_matrix[i, j] = np.linalg.norm(coords[i] - coords[j])\n        return dist_matrix\n\n    transformed_dist1 = create_distance_matrix(transformed_instance1[base_solution, :2])\n    transformed_dist2 = create_distance_matrix(transformed_instance2[base_solution, 2:])\n\n    # Adaptive edge swapping phase\n    for _ in range(min(5, n // 2)):\n        # Calculate edge weights in both original and transformed spaces\n        edge_weights = []\n        for i in range(n):\n            j = (i + 1) % n\n            original_cost = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[j]]\n            transformed_cost = transformed_dist1[i, j] + transformed_dist2[i, j]\n            edge_weights.append(original_cost + transformed_cost)\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n\n        # Select edges to swap with probability based on weights\n        if np.random.random() < 0.7:  # 70% chance for weighted selection\n            i = np.random.choice(n, p=edge_weights)\n        else:\n            i = np.random.randint(0, n)\n        j = (i + 1) % n\n\n        # Find best swap candidate\n        best_cost = float('inf')\n        best_k = -1\n\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n            candidate = np.roll(candidate, -i)\n            candidate = np.concatenate([candidate[:1], candidate[2:k+1], candidate[1:2], candidate[k+1:]])\n            candidate = np.roll(candidate, i)\n\n            # Check validity\n            if len(set(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_k = k\n\n        if best_k != -1:\n            # Apply the best swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_solution = np.roll(new_solution, -i)\n            new_solution = np.concatenate([new_solution[:1], new_solution[2:best_k+1], new_solution[1:2], new_solution[best_k+1:]])\n            new_solution = np.roll(new_solution, i)\n\n    return new_solution\n\n",
          "score": [
               6.96520938589318,
               5.376564571653562
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining hierarchical clustering with multi-objective aware edge contraction and expansion. It first partitions the solution into hierarchical clusters based on spatial proximity in both objective spaces, then selectively contracts and expands edges between clusters to balance the trade-off between the two objectives, followed by a guided node reinsertion process that prioritizes nodes with complementary improvement potential in both objectives, while dynamically adjusting the reinsertion depth based on the current solution's structure and the relative improvement potential in both objectives. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hierarchical clustering based on spatial proximity in both objectives\n    from scipy.cluster.hierarchy import linkage, fcluster\n\n    # Calculate pairwise distances in both objective spaces\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = np.sqrt(np.sum((coords1[:, np.newaxis, :] - coords1[np.newaxis, :, :])**2, axis=2))\n    dist2 = np.sqrt(np.sum((coords2[:, np.newaxis, :] - coords2[np.newaxis, :, :])**2, axis=2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    # Perform hierarchical clustering\n    Z = linkage(combined_dist[np.triu_indices(n, k=1)], method='average')\n    clusters = fcluster(Z, t=0.5 * np.max(Z[:, 2]), criterion='distance')\n\n    # Identify cluster boundaries\n    cluster_boundaries = []\n    current_cluster = clusters[0]\n    for i in range(1, n):\n        if clusters[i] != current_cluster:\n            cluster_boundaries.append(i)\n            current_cluster = clusters[i]\n\n    # Edge contraction and expansion\n    for _ in range(min(3, len(cluster_boundaries))):\n        if not cluster_boundaries:\n            break\n\n        # Select a random boundary\n        boundary_idx = np.random.choice(cluster_boundaries)\n        i = boundary_idx - 1\n        j = boundary_idx\n\n        # Calculate current costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Try contracting the edge (remove it)\n        candidate = np.delete(new_solution, j)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Try expanding the edge (add a new node)\n        if len(candidate) < n:\n            # Find the node that would best improve the solution\n            best_node = None\n            best_cost = float('inf')\n\n            for node in range(n):\n                if node not in candidate:\n                    # Try inserting the node between i and j\n                    temp = np.insert(candidate, i+1, node)\n                    temp_cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(len(temp)-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    temp_cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(len(temp)-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n                    if temp_cost1 + temp_cost2 < best_cost:\n                        best_cost = temp_cost1 + temp_cost2\n                        best_node = node\n\n            if best_node is not None:\n                candidate = np.insert(candidate, i+1, best_node)\n\n        # Choose the better option\n        if cost1 + cost2 < best_cost:\n            new_solution = candidate\n        else:\n            new_solution = np.insert(candidate, i+1, best_node)\n\n    # Guided node reinsertion\n    for _ in range(min(5, n//2)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Remove the node\n        candidate = np.delete(new_solution, i)\n\n        # Find the best position to reinsert the node\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            # Dynamic reinsertion depth based on improvement potential\n            improvement_ratio = (current_cost1 - temp_cost1) / current_cost1 + (current_cost2 - temp_cost2) / current_cost2\n            depth = max(1, min(3, int(2 * improvement_ratio)))\n\n            # Consider positions within the depth range\n            for k in range(max(0, j-depth), min(len(temp), j+depth+1)):\n                if k != j:\n                    temp2 = np.insert(candidate, k, node)\n                    temp2_cost1 = (distance_matrix_1[temp2[k-1], temp2[k]] +\n                                  distance_matrix_1[temp2[k], temp2[(k+1)%len(temp2)]])\n                    temp2_cost2 = (distance_matrix_2[temp2[k-1], temp2[k]] +\n                                  distance_matrix_2[temp2[k], temp2[(k+1)%len(temp2)]])\n\n                    if temp2_cost1 + temp2_cost2 < best_cost:\n                        best_cost = temp2_cost1 + temp2_cost2\n                        best_pos = k\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.064051003022471,
               6.274244567844251
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone idea of selecting a promising solution from the archive and applying a hybrid local search strategy, but it introduces a novel approach by combining adaptive path decomposition with multi-objective aware edge flipping. The algorithm first decomposes the solution into adaptive path segments based on their contribution to both objectives, then selectively flips edges between segments to balance the trade-off between the two objectives, followed by a guided node swapping process that prioritizes nodes with complementary improvement potential in both objectives, while dynamically adjusting the swapping range based on the current solution's structure and the relative improvement potential in both objectives. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive path decomposition\n    path_segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        # Calculate edge weights in both objectives\n        prev_node = base_solution[i-1]\n        curr_node = base_solution[i]\n        next_node = base_solution[(i+1)%n]\n\n        w1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        w2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n\n        # Determine if current node continues the segment or starts a new one\n        if len(current_segment) < 3 or (w1 + w2) / (distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]) > 1.2:\n            current_segment.append(curr_node)\n        else:\n            path_segments.append(current_segment)\n            current_segment = [curr_node]\n\n    if current_segment:\n        path_segments.append(current_segment)\n\n    # Edge flipping between segments\n    for _ in range(min(3, len(path_segments))):\n        if len(path_segments) < 2:\n            break\n\n        # Select two random segments\n        i, j = np.random.choice(len(path_segments), size=2, replace=False)\n        seg1, seg2 = path_segments[i], path_segments[j]\n\n        # Calculate current costs\n        cost1 = (distance_matrix_1[seg1[-1], seg2[0]] +\n                distance_matrix_1[seg2[-1], seg1[0]] if i < j else distance_matrix_1[seg2[-1], seg1[0]])\n        cost2 = (distance_matrix_2[seg1[-1], seg2[0]] +\n                distance_matrix_2[seg2[-1], seg1[0]] if i < j else distance_matrix_2[seg2[-1], seg1[0]])\n\n        # Try flipping the connection\n        new_order = []\n        if i < j:\n            new_order = np.concatenate([base_solution[:seg1[0]], seg2, seg1, base_solution[seg2[-1]+1:]])\n        else:\n            new_order = np.concatenate([base_solution[:seg2[0]], seg1, seg2, base_solution[seg1[-1]+1:]])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[new_order[i], new_order[i+1]] for i in range(len(new_order)-1)) + distance_matrix_1[new_order[-1], new_order[0]]\n        new_cost2 = sum(distance_matrix_2[new_order[i], new_order[i+1]] for i in range(len(new_order)-1)) + distance_matrix_2[new_order[-1], new_order[0]]\n\n        # Accept if improvement in at least one objective\n        if new_cost1 + new_cost2 < cost1 + cost2:\n            new_solution = new_order.copy()\n            # Update path segments\n            path_segments[i], path_segments[j] = path_segments[j], path_segments[i]\n\n    # Guided node swapping\n    for _ in range(min(5, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n        if i == j:\n            continue\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Swap nodes\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        # Dynamic swapping range based on improvement potential\n        improvement_ratio = (current_cost1 - new_cost1) / current_cost1 + (current_cost2 - new_cost2) / current_cost2\n        swap_range = max(1, min(5, int(3 * improvement_ratio)))\n\n        # Consider swapping within the range\n        for k in range(max(0, i-swap_range), min(n, i+swap_range+1)):\n            if k == i:\n                continue\n            for l in range(max(0, j-swap_range), min(n, j+swap_range+1)):\n                if l == j or k == l:\n                    continue\n\n                temp = candidate.copy()\n                temp[k], temp[l] = temp[l], temp[k]\n\n                temp_cost1 = (distance_matrix_1[temp[k-1], temp[k]] +\n                            distance_matrix_1[temp[k], temp[(k+1)%n]] +\n                            distance_matrix_1[temp[l-1], temp[l]] +\n                            distance_matrix_1[temp[l], temp[(l+1)%n]])\n                temp_cost2 = (distance_matrix_2[temp[k-1], temp[k]] +\n                            distance_matrix_2[temp[k], temp[(k+1)%n]] +\n                            distance_matrix_2[temp[l-1], temp[l]] +\n                            distance_matrix_2[temp[l], temp[(l+1)%n]])\n\n                if temp_cost1 + temp_cost2 < new_cost1 + new_cost2:\n                    candidate = temp.copy()\n                    new_cost1, new_cost2 = temp_cost1, temp_cost2\n\n        if new_cost1 + new_cost2 < current_cost1 + current_cost2:\n            new_solution = candidate.copy()\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.084809078203636,
               5.929778474737819
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining adaptive route segmentation with multi-objective aware node migration, which first partitions the solution into hierarchical segments based on both spatial proximity and edge strength in the two objective spaces, then selectively migrates nodes between segments to optimize the trade-off between the objectives, followed by a probability-weighted edge flipping phase that prioritizes moves with complementary improvement potential in both objectives, while dynamically adjusting the migration depth based on the current solution's structure and the relative improvement potential in both objectives. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive route segmentation\n    from scipy.spatial.distance import pdist, squareform\n\n    # Calculate route segments based on both objective spaces\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = squareform(pdist(coords1))\n    dist2 = squareform(pdist(coords2))\n\n    # Find segments with high edge strength in both objectives\n    segment_length = max(3, min(7, n // 5))\n    segments = []\n    for i in range(0, n, segment_length):\n        segment = base_solution[i:i+segment_length]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment strength in both objectives\n        strength1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        strength2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        segments.append((i, i+segment_length, strength1 + strength2))\n\n    # Sort segments by strength (descending)\n    segments.sort(key=lambda x: -x[2])\n\n    # Node migration between segments\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n\n        # Select two segments with high strength\n        seg1_idx, seg1_end, _ = segments[0]\n        seg2_idx, seg2_end, _ = segments[1]\n\n        # Select a node from the stronger segment to migrate\n        seg1_nodes = base_solution[seg1_idx:seg1_end]\n        seg2_nodes = base_solution[seg2_idx:seg2_end]\n\n        if len(seg1_nodes) < 2 or len(seg2_nodes) < 2:\n            continue\n\n        # Calculate potential improvement\n        old_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                    distance_matrix_1[new_solution[-1], new_solution[0]] +\n                    sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                    distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        # Try moving a node from seg1 to seg2\n        node_idx = np.random.randint(seg1_idx, seg1_end)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        candidate = np.delete(new_solution, node_idx)\n\n        # Find best insertion position in seg2\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(seg2_idx, seg2_end):\n            if pos == node_idx or pos == node_idx-1:\n                continue\n\n            temp = np.insert(candidate, pos, node)\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    # Probability-weighted edge flipping\n    for _ in range(min(5, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n\n        old_cost = (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]] +\n                    distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        new_cost = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] +\n                    distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]])\n\n        # Accept move with probability based on improvement\n        if new_cost < old_cost or np.random.random() < min(0.5, 0.1 + (old_cost - new_cost) / old_cost):\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.30961588797779,
               6.22478992918969
          ]
     },
     {
          "algorithm": "{The new algorithm combines a multi-objective aware path decomposition strategy with a probabilistic segment reassembly technique. It first decomposes the current solution into variable-length paths by identifying segments with balanced contributions to both objectives, then probabilistically reassembles these segments by considering their spatial proximity in both objective spaces, followed by a guided edge swapping operation that prioritizes edges with complementary improvements in both objectives while maintaining tour feasibility, and finally refines the solution with a novel node relocation heuristic that dynamically adjusts the relocation probability based on the current solution's structure and the relative improvement potential in both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Multi-objective path decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate cost difference for both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        prev_cost1 = distance_matrix_1[new_solution[i-2], new_solution[i-1]] if i > 1 else 0\n        prev_cost2 = distance_matrix_2[new_solution[i-2], new_solution[i-1]] if i > 1 else 0\n\n        # Check if segment should be split\n        if (current_cost1 > 1.2 * prev_cost1 and current_cost2 > 1.2 * prev_cost2) or np.random.random() < 0.1:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Probabilistic segment reassembly\n    if len(segments) > 1:\n        # Calculate segment scores based on spatial proximity in both objectives\n        segment_scores = []\n        for seg in segments:\n            # Calculate centroids in both objective spaces\n            centroid1 = np.mean(instance[seg, :2], axis=0)\n            centroid2 = np.mean(instance[seg, 2:], axis=0)\n\n            # Calculate average distance to other segments\n            avg_dist1 = np.mean([np.linalg.norm(centroid1 - np.mean(instance[other_seg, :2], axis=0))\n                                for other_seg in segments if other_seg != seg])\n            avg_dist2 = np.mean([np.linalg.norm(centroid2 - np.mean(instance[other_seg, 2:], axis=0))\n                               for other_seg in segments if other_seg != seg])\n\n            # Combined score (weighted average)\n            score = 0.5 * avg_dist1 + 0.5 * avg_dist2\n            segment_scores.append(score)\n\n        # Reassemble segments in order of decreasing score\n        sorted_indices = np.argsort(segment_scores)[::-1]\n        new_solution = np.concatenate([segments[i] for i in sorted_indices])\n\n    # Guided edge swapping\n    for _ in range(min(5, n//2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) <= 1 or abs(i - j) >= n - 1:\n            continue\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Try swapping edges\n        candidate = new_solution.copy()\n        if i < j:\n            candidate[i:j+1] = np.concatenate([candidate[j:j+1], candidate[i+1:j], candidate[i:i+1]])\n        else:\n            candidate[j:i+1] = np.concatenate([candidate[i:i+1], candidate[j+1:i], candidate[j:j+1]])\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        # Accept if both objectives improve or one improves significantly while the other doesn't worsen too much\n        if ((new_cost1 < current_cost1 and new_cost2 < current_cost2) or\n            (new_cost1 < current_cost1 * 0.9 and new_cost2 <= current_cost2 * 1.1) or\n            (new_cost1 <= current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9)):\n            new_solution = candidate\n\n    # Node relocation heuristic\n    for _ in range(min(3, n//3)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or (i+1)%n == j or (j+1)%n == i:\n            continue\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Try relocating node i after node j\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:j+1], [candidate[i]], candidate[j+1:i], candidate[i+1:]])\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        # Dynamic relocation probability based on improvement potential\n        improvement_ratio = (current_cost1 - new_cost1) / current_cost1 + (current_cost2 - new_cost2) / current_cost2\n        prob = min(1.0, 0.5 + 0.5 * improvement_ratio)\n        if np.random.random() < prob:\n            new_solution = candidate\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.2572821231179985,
               6.7334989692074805
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions\n    objectives = [obj for _, obj in archive]\n    non_dominated = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    # Step 2: Select base solution (geometric median of non-dominated solutions)\n    if non_dominated:\n        non_dom_objectives = [objectives[i] for i in non_dominated]\n        # Calculate geometric median (approximation)\n        median_obj = (\n            np.median([obj[0] for obj in non_dom_objectives]),\n            np.median([obj[1] for obj in non_dom_objectives])\n        )\n        # Find solution closest to median\n        distances = [np.sqrt((obj[0]-median_obj[0])**2 + (obj[1]-median_obj[1])**2) for obj in non_dom_objectives]\n        selected_idx = non_dominated[np.argmin(distances)]\n    else:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Variable-length segment relocation\n    max_segment = min(10, n // 3)\n    segment_length = np.random.randint(2, max_segment + 1)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Find best insertion position considering both objectives\n    best_cost = (float('inf'), float('inf'))\n    best_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= start and pos < start + segment_length:\n            continue\n\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:start],\n            new_solution[start+segment_length:]\n        ])\n\n        # Calculate costs\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[candidate[-1], candidate[0]]\n\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Multi-objective comparison\n        if (cost1 + cost2) < (best_cost[0] + best_cost[1]) or \\\n           (cost1 <= best_cost[0] and cost2 < best_cost[1]) or \\\n           (cost1 < best_cost[0] and cost2 <= best_cost[1]):\n            best_cost = (cost1, cost2)\n            best_pos = pos\n\n    if best_pos != -1 and best_cost != (float('inf'), float('inf')):\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:start],\n            new_solution[start+segment_length:]\n        ])\n\n    # Multi-objective edge swapping\n    if np.random.random() < 0.5:\n        # Select edges based on both objectives\n        edge_scores = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            edge_scores.append(cost1 + cost2)\n\n        # Select worst edges to swap\n        worst_edges = np.argsort(edge_scores)[-min(3, n//2):]\n        for i in worst_edges:\n            j = (i + 1) % n\n            # Find best swap partner considering both objectives\n            best_swap = -1\n            best_swap_cost = (float('inf'), float('inf'))\n            for k in range(n):\n                if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                    continue\n\n                # Create candidate solution\n                candidate = new_solution.copy()\n                candidate[i], candidate[j] = candidate[j], candidate[i]\n                candidate = np.roll(candidate, -i)\n                candidate = np.concatenate([candidate[:1], candidate[2:k+1], candidate[1:2], candidate[k+1:]])\n                candidate = np.roll(candidate, i)\n\n                if len(set(candidate)) != n:\n                    continue\n\n                # Calculate costs\n                cost1 = sum(distance_matrix_1[candidate[l], candidate[(l+1)%n]] for l in range(n))\n                cost2 = sum(distance_matrix_2[candidate[l], candidate[(l+1)%n]] for l in range(n))\n\n                if (cost1 + cost2) < (best_swap_cost[0] + best_swap_cost[1]) or \\\n                   (cost1 <= best_swap_cost[0] and cost2 < best_swap_cost[1]) or \\\n                   (cost1 < best_swap_cost[0] and cost2 <= best_swap_cost[1]):\n                    best_swap_cost = (cost1, cost2)\n                    best_swap = k\n\n            if best_swap != -1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                new_solution = np.roll(new_solution, -i)\n                new_solution = np.concatenate([new_solution[:1], new_solution[2:best_swap+1], new_solution[1:2], new_solution[best_swap+1:]])\n                new_solution = np.roll(new_solution, i)\n\n    # Feasibility check\n    if len(set(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               6.537563592228068,
               5.978792524129621
          ]
     },
     {
          "algorithm": "{The new algorithm combines an adaptive segment-based neighborhood exploration with a multi-objective utility-guided segment insertion strategy. It first identifies promising segments in the selected solution by analyzing their contribution to both objectives, then probabilistically selects segments that show potential for improvement in either objective space, and finally inserts these segments into different positions in the tour while considering their impact on both objectives, ensuring feasibility through careful position validation and segment rotation, with the segment length and insertion pattern dynamically determined by an adaptive probability model that considers both the current solution's structure and the distance matrices' characteristics.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using segment analysis\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on both objectives\n    segment_length = np.random.randint(2, min(5, n // 3))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Extract segment and analyze its contribution to both objectives\n    segment = new_solution[start_pos:start_pos + segment_length]\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length))\n    segment_cost1 += distance_matrix_1[segment[-1], segment[0]] if segment_length > 1 else 0\n\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length))\n    segment_cost2 += distance_matrix_2[segment[-1], segment[0]] if segment_length > 1 else 0\n\n    # Calculate segment's utility for both objectives\n    total_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    utility1 = segment_cost1 / total_cost1 if total_cost1 > 0 else 0\n    utility2 = segment_cost2 / total_cost2 if total_cost2 > 0 else 0\n\n    # Probabilistic segment operation based on utility\n    if utility1 < 0.25 or utility2 < 0.25:\n        # If segment is significantly worse in one objective, consider removing it\n        new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n        # Find best insertion position for the segment\n        best_pos = -1\n        best_utility = float('inf')\n\n        for pos in range(len(new_solution) - segment_length + 1):\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            utility = max(cost1 / total_cost1, cost2 / total_cost2) if total_cost1 > 0 and total_cost2 > 0 else float('inf')\n\n            if utility < best_utility:\n                best_utility = utility\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # If segment is balanced, consider rotating it\n        rotation = np.random.randint(1, segment_length)\n        segment = np.roll(segment, rotation)\n        new_solution[start_pos:start_pos + segment_length] = segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap to restore feasibility\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               6.683277848993857,
               6.04049020037005
          ]
     }
]