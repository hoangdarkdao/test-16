[
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment swapping, probabilistic node reinsertion, and objective-balanced path inversion to dynamically explore the solution space while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment swapping\n    segment_size = max(2, min(3, n // 5))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n    new_solution[pos1:pos1+segment_size], new_solution[pos2:pos2+segment_size] = new_solution[pos2:pos2+segment_size], new_solution[pos1:pos1+segment_size]\n\n    # Step 2: Probabilistic node reinsertion\n    if random.random() < 0.7:\n        node = random.choice(new_solution)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-balanced path inversion\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        inverted_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        inverted_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        obj1_weight = 0.6 if random.random() < 0.7 else 0.4\n        if (obj1_weight * inverted_cost1 + (1-obj1_weight) * inverted_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7745000102125286,
            0.06662243604660034
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that combines dynamic path fragmentation with probabilistic node swapping and objective-guided segment inversion to explore high-quality diverse neighborhoods while maintaining feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    candidates = [sol for sol, obj in archive if (obj[0] + obj[1]) <= avg_cost * 1.2]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    selected = random.choice(candidates)\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic path fragmentation\n    frag_size = max(2, min(5, n // 5))\n    breaks = sorted(random.sample(range(1, n), frag_size - 1))\n    fragments = []\n    prev = 0\n    for b in breaks:\n        fragments.append(new_solution[prev:b])\n        prev = b\n    fragments.append(new_solution[prev:])\n\n    # Phase 2: Probabilistic node swapping\n    if random.random() < 0.5:\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Phase 3: Objective-guided segment inversion\n    if random.random() < 0.3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 6, n - 1))\n        segment = new_solution[start:end+1]\n        obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        if obj1 + obj2 > (obj1 + obj2) * 1.1:\n            new_solution[start:end+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9592359181059527,
            0.4170905351638794
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that combines dynamic path fragmentation with probabilistic node swapping and objective-guided segment inversion to explore high-quality diverse neighborhoods while maintaining feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    candidates = [sol for sol, obj in archive if (obj[0] + obj[1]) <= avg_cost * 1.2]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    selected = random.choice(candidates)\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic path fragmentation\n    frag_size = max(2, min(5, n // 5))\n    breaks = sorted(random.sample(range(1, n), frag_size - 1))\n    fragments = []\n    prev = 0\n    for b in breaks:\n        fragments.append(new_solution[prev:b])\n        prev = b\n    fragments.append(new_solution[prev:])\n\n    # Phase 2: Probabilistic node swapping\n    if random.random() < 0.5:\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Phase 3: Objective-guided segment inversion\n    if random.random() < 0.3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 6, n - 1))\n        segment = new_solution[start:end+1]\n        obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        if obj1 + obj2 > (obj1 + obj2) * 1.1:\n            new_solution[start:end+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9592359181059527,
            0.4170905351638794
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment swapping, probabilistic node reinsertion, and objective-balanced path inversion to dynamically explore the solution space while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment swapping\n    segment_size = max(2, min(3, n // 5))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n    new_solution[pos1:pos1+segment_size], new_solution[pos2:pos2+segment_size] = new_solution[pos2:pos2+segment_size], new_solution[pos1:pos1+segment_size]\n\n    # Step 2: Probabilistic node reinsertion\n    if random.random() < 0.7:\n        node = random.choice(new_solution)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-balanced path inversion\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        inverted_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        inverted_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        obj1_weight = 0.6 if random.random() < 0.7 else 0.4\n        if (obj1_weight * inverted_cost1 + (1-obj1_weight) * inverted_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7745000102125286,
            0.06662243604660034
        ]
    },
    {
        "algorithm": "{A novel multi-phase local search algorithm that combines adaptive segment rotation, probabilistic node relocation, and objective-balanced edge swapping with dynamic neighborhood exploration to generate high-quality neighbors while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective\n    best_sol = min(archive, key=lambda x: x[1][0] + x[1][1])[0]\n    new_solution = best_sol.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive segment rotation\n    segment_size = max(2, min(8, n // 4))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    rotation = random.randint(1, segment_size-1)\n    new_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:end] = new_segment\n\n    # Phase 2: Probabilistic node relocation\n    if random.random() < 0.6:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-2)\n        if j >= i:\n            j += 1\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Phase 3: Objective-balanced edge swapping\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        swapped_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n        if (swapped_cost1 < current_cost1 and swapped_cost2 <= current_cost2 * 1.1) or \\\n           (swapped_cost2 < current_cost2 and swapped_cost1 <= current_cost1 * 1.1):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7894839752240558,
            0.14437991380691528
        ]
    },
    {
        "algorithm": "{A novel adaptive multi-phase local search algorithm that combines dynamic segment relocation, probabilistic node insertion, and objective-weighted edge reversal to intelligently explore the solution space while balancing improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    segment_size = max(2, min(4, n // 6))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Probabilistic node insertion\n    if random.random() < 0.6:\n        node = random.choice(new_solution)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge reversal\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        weight = random.random()\n        if (weight * reversed_cost1 + (1-weight) * reversed_cost2) < (weight * current_cost1 + (1-weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9511987747734297,
            0.2520816922187805
        ]
    },
    {
        "algorithm": "{A novel adaptive multi-phase local search algorithm that combines dynamic segment reconfiguration, probabilistic node insertion, and objective-weighted edge reversal to explore high-quality diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    candidates = [sol for sol, obj in archive if (obj[0] + obj[1]) <= avg_cost * 1.2]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    selected = random.choice(candidates)\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic segment reconfiguration\n    segment_size = max(3, min(7, n // 4))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    new_segment = np.concatenate([segment[:1], segment[1:][::-1]])\n    new_solution[start:end] = new_segment\n\n    # Phase 2: Probabilistic node insertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Phase 3: Objective-weighted edge reversal\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(n), 2))\n        current_cost = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n        reversed_cost = distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        if reversed_cost < current_cost * 0.9:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8217405665124919,
            0.15686273574829102
        ]
    },
    {
        "algorithm": "{A novel adaptive multi-phase local search algorithm that combines dynamic segment reconfiguration, probabilistic node insertion, and objective-weighted edge reversal to explore high-quality diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    candidates = [sol for sol, obj in archive if (obj[0] + obj[1]) <= avg_cost * 1.1]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    selected = random.choice(candidates)\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic segment reconfiguration\n    segment_size = max(4, min(6, n // 3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    new_segment = np.concatenate([segment[:1], segment[1:][::-1]])\n    new_solution[start:end] = new_segment\n\n    # Phase 2: Probabilistic node insertion\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Phase 3: Objective-weighted edge reversal\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        current_cost = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n        reversed_cost = distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        if reversed_cost < current_cost * 0.8:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8965615837102534,
            0.15779626369476318
        ]
    },
    {
        "algorithm": "{An adaptive multi-objective local search algorithm that combines dynamic path fragmentation with probabilistic node swapping and objective-guided segment inversion to explore high-quality diverse neighborhoods while maintaining feasibility through constrained segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    candidates = [sol for sol, obj in archive if (obj[0] + obj[1]) <= avg_cost * 1.2]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    selected = random.choice(candidates)\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic path fragmentation\n    frag_size = max(2, min(5, n // 5))\n    breaks = sorted(random.sample(range(1, n), frag_size - 1))\n    fragments = []\n    prev = 0\n    for b in breaks:\n        fragments.append(new_solution[prev:b])\n        prev = b\n    fragments.append(new_solution[prev:])\n\n    # Phase 2: Probabilistic node swapping\n    if random.random() < 0.5:\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Phase 3: Objective-guided segment inversion\n    if random.random() < 0.3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 6, n - 1))\n        segment = new_solution[start:end+1]\n        obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        if obj1 + obj2 > (obj1 + obj2) * 1.1:\n            new_solution[start:end+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9592359181059527,
            0.4170905351638794
        ]
    },
    {
        "algorithm": "{An adaptive multi-phase local search algorithm that combines dynamic node reordering, probabilistic segment swapping, and hybrid edge reversal with adaptive objective weighting to explore the solution space while balancing improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic node reordering\n    segment_size = max(3, min(5, n // 5))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Probabilistic segment swapping\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:]\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1])\n\n    # Step 3: Hybrid edge reversal with adaptive objective weighting\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        weight = 0.5 * (current_cost1 / (current_cost1 + current_cost2)) + 0.5 * (current_cost2 / (current_cost1 + current_cost2))\n        if (weight * reversed_cost1 + (1-weight) * reversed_cost2) < (weight * current_cost1 + (1-weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9364345016172395,
            0.2411363124847412
        ]
    },
    {
        "algorithm": "{A novel adaptive multi-phase local search algorithm that combines dynamic segment relocation, probabilistic node insertion, and objective-weighted edge reversal to intelligently explore the solution space while balancing improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Dynamic segment relocation\n    segment_size = max(2, min(4, n // 6))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 2: Probabilistic node insertion\n    if random.random() < 0.6:\n        node = random.choice(new_solution)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-weighted edge reversal\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        weight = random.random()\n        if (weight * reversed_cost1 + (1-weight) * reversed_cost2) < (weight * current_cost1 + (1-weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9511987747734297,
            0.2520816922187805
        ]
    },
    {
        "algorithm": "{A novel adaptive multi-phase local search algorithm that combines dynamic segment reconfiguration, probabilistic node insertion, and objective-weighted edge reversal to explore high-quality diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    total_costs = [obj[0] + obj[1] for _, obj in archive]\n    avg_cost = sum(total_costs) / len(total_costs)\n    candidates = [sol for sol, obj in archive if (obj[0] + obj[1]) <= avg_cost * 1.2]\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    selected = random.choice(candidates)\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Dynamic segment reconfiguration\n    segment_size = max(3, min(7, n // 4))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n    new_segment = np.concatenate([segment[:1], segment[1:][::-1]])\n    new_solution[start:end] = new_segment\n\n    # Phase 2: Probabilistic node insertion\n    if random.random() < 0.6:\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Phase 3: Objective-weighted edge reversal\n    if random.random() < 0.4:\n        a, b = sorted(random.sample(range(n), 2))\n        current_cost = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n        reversed_cost = distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        if reversed_cost < current_cost * 0.9:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8217405665124919,
            0.15686273574829102
        ]
    }
]