[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (high ratio of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)  # Avoid division by zero\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge exchange followed by segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: Swap two edges if it improves both objectives\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n\n        # Calculate new objectives\n        old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n           (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n            new_solution = candidate\n            break\n\n    # Segment reversal: Reverse a random segment if it improves the solution\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Calculate new objectives\n    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n    # Accept if both objectives improve or one improves significantly\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n       (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n       (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n        new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               7.938052437621909,
               4.974250410098344
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating each solution's potential for improvement using a combination of objective values and diversity measures. It then applies a novel hybrid local search operator that combines a modified version of the Lin-Kernighan heuristic with a variable-length segment relocation strategy. The operator randomly selects a segment of nodes in the tour and relocates it to a new position while considering both objective spaces, ensuring feasibility by maintaining the TSP constraints. The selection of the segment length and insertion point is guided by a probabilistic approach that balances exploration and exploitation, favoring segments that show high potential for reducing both objectives. The function returns the new neighbor solution after validating its feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([(cost1 + cost2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2)) for _, (cost1, cost2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment length (1 to n//2)\n    segment_length = random.randint(1, n // 2)\n\n    # Randomly select a starting position for the segment\n    start_pos = random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Find the best insertion position considering both objectives\n    best_insert_pos = 0\n    best_cost = float('inf')\n\n    for insert_pos in range(len(new_solution)):\n        # Insert the segment at the current position\n        candidate = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Calculate the total cost in both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Combine the costs with a weighted sum\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = insert_pos\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n",
          "score": [
               6.11088345881558,
               5.468006696741405
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection strategy of focusing on non-dominated solutions from the second provided algorithm with a novel local search operator that integrates both edge-based and node-based perturbations. It first identifies promising solutions by filtering non-dominated ones from the archive, then applies a hybrid local search that alternates between a \"node jump\" operation (where a node is temporarily removed and reinserted at a better position based on both objective spaces) and a \"multi-edge swap\" operation (where multiple edges are simultaneously rearranged to improve both objectives), with the search guided by a Pareto-dominance acceptance criterion to ensure feasible and high-quality solutions are generated.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select a random non-dominated solution\n    selected_idx = np.random.randint(0, len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node Jump + Multi-Edge Swap\n    for _ in range(10):  # Number of local search iterations\n        # Node Jump: Remove a node and reinsert at a better position\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        candidate_positions = list(range(n))\n        candidate_positions.remove(node_pos)\n\n        # Evaluate insertion positions based on both objectives\n        best_pos = None\n        best_score = float('inf')\n        for pos in candidate_positions:\n            # Create temporary solution\n            temp_sol = np.delete(new_solution, node_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            # Calculate objectives\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            # Use Pareto dominance for selection\n            if best_pos is None or (cost1 <= best_score and cost2 <= best_score):\n                if cost1 < best_score or cost2 < best_score:\n                    best_pos = pos\n                    best_score = max(cost1, cost2)\n\n        if best_pos is not None:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n        # Multi-Edge Swap: Swap multiple edges simultaneously\n        if n >= 4:\n            # Select two random edge pairs to swap\n            a, b, c, d = np.random.choice(n, 4, replace=False)\n            if a > b:\n                a, b = b, a\n            if c > d:\n                c, d = d, c\n\n            # Create candidate solution\n            candidate = new_solution.copy()\n            # Swap edges (a,b) and (c,d) with (a,c) and (b,d)\n            candidate[a:b+1] = candidate[a:b+1][::-1]\n            candidate[c:d+1] = candidate[c:d+1][::-1]\n\n            # Calculate objectives\n            old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Accept if Pareto-dominant\n            if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) and (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               5.990936237660408,
               5.777165829116156
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection strategy of focusing on diverse solutions from the first provided algorithm with a novel local search operator that integrates both path inversion and node relocation, guided by a hybrid objective improvement criterion that considers both individual objective improvements and their combined trade-offs. It first partitions the archive into clusters based on both objective values and spatial diversity, then selects a representative solution from the least explored cluster. The local search operator dynamically selects multiple non-overlapping segments from the solution, applies inversion with probability based on local objective improvements, and then performs targeted node relocations to further optimize the tour, with the search guided by a hybrid acceptance criterion that balances individual objective improvements with their combined trade-offs to ensure feasible and high-quality solutions are generated.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    from sklearn.cluster import KMeans\n    import random\n\n    # Cluster-based selection\n    objectives = np.array([obj for _, obj in archive])\n    coords = instance[archive[0][0], :2]\n    diversity = np.array([np.std(coords[:, 0]), np.std(coords[:, 1])])\n\n    cluster_data = np.hstack([objectives, diversity.reshape(1, -1).repeat(len(archive), axis=0)])\n    n_clusters = min(3, len(archive))\n    kmeans = KMeans(n_clusters=n_clusters)\n    labels = kmeans.fit_predict(cluster_data)\n\n    cluster_sizes = np.bincount(labels)\n    least_cluster = np.argmin(cluster_sizes)\n    candidates = [i for i, label in enumerate(labels) if label == least_cluster]\n\n    if not candidates:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Segment inversion with node relocation\n    num_segments = min(3, n // 4)\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments*2))\n    segments = [(segment_indices[i], segment_indices[i+1]) for i in range(0, len(segment_indices), 2)]\n    segments.sort(key=lambda x: x[1]-x[0], reverse=True)\n\n    for start, end in segments:\n        segment = new_solution[start:end+1]\n        if random.random() < 0.6:\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n\n            inverted_segment = segment[::-1]\n            temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= 1.1 * current_cost2) or \\\n               (new_cost1 <= 1.1 * current_cost1 and new_cost2 < current_cost2):\n                new_solution = temp_solution\n\n    # Node relocation with trade-off consideration\n    for _ in range(5):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        candidate_positions = list(range(n))\n        candidate_positions.remove(node_pos)\n\n        best_pos = None\n        best_score = float('inf')\n        for pos in candidate_positions:\n            temp_sol = np.delete(new_solution, node_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            combined_score = 0.7 * cost1 + 0.3 * cost2\n            if combined_score < best_score:\n                best_pos = pos\n                best_score = combined_score\n\n        if best_pos is not None:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               5.041981799207054,
               7.326106261285743
          ]
     },
     {
          "algorithm": "{The new algorithm combines Pareto front analysis with a novel multi-objective path inversion strategy that selectively inverts segments of the tour based on their contribution to both objectives, using a dynamic acceptance criterion that prioritizes solutions improving at least one objective while maintaining or improving the other. The path inversion dynamically adjusts the inversion length and position based on local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure, and incorporates a guided node reinsertion mechanism to further refine the solution while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best trade-off using Pareto front analysis\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective path inversion\n    for _ in range(5):\n        inversion_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(n - inversion_length)\n        end = start + inversion_length\n\n        # Invert the segment\n        inverted_segment = base_solution[start:end][::-1]\n        temp_solution = np.concatenate([\n            base_solution[:start],\n            inverted_segment,\n            base_solution[end:]\n        ])\n\n        # Calculate costs\n        current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            base_solution = temp_solution.copy()\n\n    # Guided node reinsertion\n    for _ in range(10):\n        i = np.random.randint(n)\n        node = base_solution[i]\n\n        # Remove node from its current position\n        temp_solution = np.concatenate([base_solution[:i], base_solution[i+1:]])\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for j in range(n-1):\n            # Insert node between j and j+1\n            candidate = np.insert(temp_solution, j, node)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%(n-1)]] for k in range(n-1))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%(n-1)]] for k in range(n-1))\n\n            # Multi-objective comparison\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost2 < best_cost2 and cost1 <= best_cost1):\n                best_pos = j\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        # Insert node at best position\n        base_solution = np.insert(temp_solution, best_pos, node)\n\n    return base_solution\n\n",
          "score": [
               5.8410884779960055,
               6.302812425962019
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    import random\n\n    # Select a solution with good potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 2:\n        # Exclude the top 20% and bottom 20% to focus on middle-range solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        start_idx = int(0.2 * len(sorted_archive))\n        end_idx = int(0.8 * len(sorted_archive))\n        selected_solution = random.choice(sorted_archive[start_idx:end_idx])[0].copy()\n    else:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment-based perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select 3 non-adjacent edges to perform a 3-opt move\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect the segments in a new order\n    candidates = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment2, segment3, segment4[::-1]]),\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n    ]\n\n    # Evaluate all candidates based on both objectives\n    best_neighbor = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_neighbor = candidate.copy()\n\n    # Step 2: Apply novel segment-based perturbation if 3-opt didn't improve\n    if best_neighbor is None or np.array_equal(best_neighbor, new_solution):\n        # Randomly select a segment and reverse it, then insert elsewhere\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n        insert_pos = random.randint(0, len(remaining))\n        best_neighbor = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    return best_neighbor\n\n",
          "score": [
               6.711106193981905,
               5.67906101484736
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Step 2: Hybrid local search (edge insertion + node reordering)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reorder\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n - 1)\n\n    # Reverse the segment (node reordering)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly insert a node elsewhere (edge insertion)\n    node_to_insert = new_solution[end]\n    new_solution = np.delete(new_solution, end)\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
          "score": [
               6.0500135980359975,
               6.09537249265896
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    max_vals = np.max(objectives, axis=0)\n    normalized = objectives / max_vals\n    combined = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(combined)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search operator: Multi-objective path relinking with coordinate-based swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify nodes with high potential for improvement based on coordinate differences\n    potential_nodes = []\n    for i in range(n):\n        node_id = new_solution[i]\n        next_node_id = new_solution[(i+1)%n]\n        prev_node_id = new_solution[(i-1)%n]\n\n        # Calculate coordinate differences\n        dx1 = instance[node_id, 0] - instance[next_node_id, 0]\n        dy1 = instance[node_id, 1] - instance[next_node_id, 1]\n        dx2 = instance[node_id, 2] - instance[next_node_id, 2]\n        dy2 = instance[node_id, 3] - instance[next_node_id, 3]\n\n        # Calculate potential improvement score\n        score = (dx1**2 + dy1**2 + dx2**2 + dy2**2)**0.5\n        potential_nodes.append((score, i))\n\n    # Sort nodes by improvement potential and select top 20%\n    potential_nodes.sort(reverse=True, key=lambda x: x[0])\n    top_nodes = [i for _, i in potential_nodes[:max(1, len(potential_nodes)//5)]]\n\n    # Perform targeted swaps for selected nodes\n    for i in top_nodes:\n        j = random.choice(top_nodes)\n        if i != j:\n            # Create candidate by swapping nodes\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n\n            # Calculate new objectives\n            old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Accept if both objectives improve or one improves significantly\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n               (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n                new_solution = candidate\n                break\n\n    # Additional improvement: Reverse a segment if it helps\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n       (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n       (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n        new_solution = candidate\n\n    # Validate the new solution\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Invalid tour: Duplicate nodes detected.\")\n\n    return new_solution\n\n",
          "score": [
               6.377108979719962,
               5.81674731463958
          ]
     },
     {
          "algorithm": "{The new algorithm will combine the selection of diverse solutions from the archive with a novel \"objective-aware segment inversion\" operator that identifies segments of the tour where nodes are consistently distant in both objective spaces, inverts these segments, and strategically reinserts them to potentially reduce both objectives simultaneously, while maintaining feasibility through careful segment boundary handling and objective-aware acceptance criteria.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    selected_sol = max(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n\n    # Objective-aware segment inversion\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Find segments where nodes are consistently distant in both objectives\n    segment_length = max(2, n // 5)\n    for _ in range(3):\n        # Randomly select a segment\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate average distance in both objectives\n        avg_dist1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) / (len(segment)-1)\n        avg_dist2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) / (len(segment)-1)\n\n        # If segment is consistently long in both objectives, consider inversion\n        if avg_dist1 > 0.5 * np.mean(distance_matrix_1) and avg_dist2 > 0.5 * np.mean(distance_matrix_2):\n            # Create candidate by inverting the segment\n            candidate = new_solution.copy()\n            candidate[start:start+segment_length] = segment[::-1]\n\n            # Check if inversion improves at least one objective\n            old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n            new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution = candidate.copy()\n\n    # Strategic reinsertion of segments\n    for _ in range(2):\n        # Select a segment to move\n        segment_size = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Remove the segment\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n\n        # Find best insertion position based on both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(remaining)):\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n            # Calculate new objectives\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Use weighted sum of objectives for selection\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
          "score": [
               5.618008886625851,
               7.567143663322766
          ]
     },
     {
          "algorithm": "{The new algorithm employs a diversity-aware, multi-phase evolutionary approach that combines Pareto-frontier analysis with spatial-aware segmental recombination. It first identifies solutions near the Pareto frontier and partitions them into clusters based on both objective values and spatial proximity, then selects a representative from the least explored cluster. The algorithm then performs a novel \"adaptive segmental crossover\" that dynamically selects multiple non-overlapping segments from different solutions, applies inversion with probability based on both objective improvements and spatial coherence, and reconstructs the tour using a greedy insertion strategy that minimizes the combined cost of both objectives while preserving spatial diversity. The final phase employs an \"objective-balanced path optimization\" that adaptively adjusts node positions along the tour using a simulated annealing-inspired acceptance criterion, where the temperature parameter is dynamically adjusted based on the current Pareto dominance relationship between objectives. The method ensures feasibility by maintaining a valid tour structure throughout all operations and incorporates a spatial diversity-preserving mechanism that maintains edge variety across both objective spaces.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    from sklearn.cluster import KMeans\n    import random\n    import numpy as np\n\n    # Pareto-frontier analysis and clustering\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if len(pareto_front) < 2:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        # Cluster solutions near Pareto frontier\n        cluster_data = objectives[pareto_front]\n        n_clusters = min(3, len(pareto_front))\n        kmeans = KMeans(n_clusters=n_clusters)\n        labels = kmeans.fit_predict(cluster_data)\n\n        # Select from least populated cluster\n        cluster_sizes = np.bincount(labels)\n        least_cluster = np.argmin(cluster_sizes)\n        candidates = [pareto_front[i] for i, label in enumerate(labels) if label == least_cluster]\n\n        selected_idx = random.choice(candidates) if candidates else random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Adaptive segmental crossover\n    num_segments = min(4, n // 3)\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments*2))\n    segments = [(segment_indices[i], segment_indices[i+1]) for i in range(0, len(segment_indices), 2)]\n\n    # Sort segments by spatial coherence\n    coords = instance[base_solution, :2]\n    segment_coherence = []\n    for start, end in segments:\n        segment_coords = coords[start:end+1]\n        coherence = np.mean(np.sqrt(np.sum((segment_coords[1:] - segment_coords[:-1])**2, axis=1)))\n        segment_coherence.append((start, end, coherence))\n\n    segments = sorted(segment_coherence, key=lambda x: x[2], reverse=True)\n\n    # Process segments with inversion based on objective-spatial tradeoff\n    for start, end, _ in segments:\n        segment = new_solution[start:end+1]\n        if random.random() < 0.6:\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n\n            inverted_segment = segment[::-1]\n            temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n\n            # Spatial coherence check\n            segment_coords = instance[segment, :2]\n            inverted_coords = instance[inverted_segment, :2]\n            current_spatial = np.sum(np.sqrt(np.sum((segment_coords[1:] - segment_coords[:-1])**2, axis=1)))\n            new_spatial = np.sum(np.sqrt(np.sum((inverted_coords[1:] - inverted_coords[:-1])**2, axis=1)))\n\n            # Accept if at least one objective improves and spatial coherence is maintained\n            if ((new_cost1 < current_cost1 and new_cost2 <= current_cost2) or\n                (new_cost1 <= current_cost1 and new_cost2 < current_cost2)) and new_spatial <= 1.2 * current_spatial:\n                new_solution = temp_solution\n\n    # Objective-balanced path optimization\n    temp = 0.7\n    for _ in range(7):\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            continue\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + \\\n                   distance_matrix_1[temp_solution[j-1], temp_solution[j]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] + \\\n                   distance_matrix_2[temp_solution[j-1], temp_solution[j]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]]\n\n        # Dynamic temperature adjustment based on objective balance\n        objective_ratio = objectives[selected_idx][0] / (objectives[selected_idx][1] + 1e-6)\n        acceptance_prob = min(1, np.exp((current_cost1 - new_cost1) * (1 - objective_ratio) +\n                                       (current_cost2 - new_cost2) * objective_ratio / temp))\n\n        if random.random() < acceptance_prob:\n            new_solution = temp_solution\n            temp *= 0.95  # Cool down based on acceptance\n\n    return new_solution\n\n",
          "score": [
               7.714285579885294,
               5.945738293428606
          ]
     }
]