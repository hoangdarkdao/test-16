[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid Local Search: Combine 2-opt with a novel segment relocation\n    n = len(base_solution)\n\n    # Step 1: Randomly select two non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Step 2: Relocate the segment between a and b to after c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Step 3: Apply 2-opt on the relocated segment\n    i, j = sorted(np.random.choice(range(len(segment)), 2, replace=False))\n    segment[i], segment[j] = segment[j], segment[i]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
          "score": [
               -0.6753597224650268,
               0.0938725471496582
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a high-quality neighbor solution in the bi-objective TSP involves first selecting a promising base solution from the archive by prioritizing those with objectives that are neither dominated nor excessively similar to others, ensuring diversity. Then, it applies a hybrid local search operator that combines a novel edge-swapping mechanism with a variable-length segment relocation strategy. The edge-swapping mechanism identifies critical edges in both objective spaces, swapping them while preserving tour validity, while the segment relocation strategy dynamically adjusts the length of relocated segments based on the local topology of the solution, favoring segments that yield significant cost reductions in either objective. The algorithm ensures feasibility by maintaining permutation validity throughout all operations and uses a probabilistic acceptance criterion to balance exploration and exploitation, favoring neighbors that improve Pareto dominance or show potential for further improvement.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_solution, _ = archive[np.random.choice(len(archive))]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping mechanism\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Variable-length segment relocation\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    # Remove segment and insert elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure solution remains valid (permutation of all nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
          "score": [
               -0.8379564264344043,
               0.2384818196296692
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge assembly with partial 3-opt\n    n = len(base_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Edge assembly: reconnect edges to form a new tour segment\n    new_solution[i:j] = base_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = base_solution[j:k][::-1]  # Reverse another segment\n\n    # Partial 3-opt: attempt to improve the tour by reconnecting three edges\n    if np.random.rand() < 0.5:\n        # Randomly select three nodes and attempt to reconnect them\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n        new_solution[b:c] = base_solution[b:c][::-1]\n\n    # Ensure feasibility: verify no duplicates and all nodes are included\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8337802753264643,
               0.16590946912765503
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in non_dominated])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1.0 / (normalized_obj + 1e-10)\n    probs = weights.sum(axis=1) / weights.sum()\n    selected_idx = np.random.choice(len(non_dominated), p=probs)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Hybrid local search - edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to remove and reinsert\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(n - 1, 5))  # Segment length between 2 and 4\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        remaining = new_solution[end:start]\n\n    # Find a new position to insert the segment\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    if insert_pos == 0:\n        new_solution = np.concatenate([segment, remaining])\n    elif insert_pos == len(remaining):\n        new_solution = np.concatenate([remaining, segment])\n    else:\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Randomly relocate a node\n    if n > 2:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 4: Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9880560877894095,
               0.30501770973205566
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solutions in the archive by evaluating their dominance or non-dominated status, then intelligently selects one based on a hybrid strategy combining a biased random selection and a local search quality assessment. It then applies a novel hybrid local search operator that dynamically alternates between a multi-segment inversion (MSI) and a guided edge insertion (GEI) strategy, where MSI focuses on reversing segments of the tour to improve both objectives, while GEI strategically inserts nodes based on their relative improvement potential in either objective space, ensuring feasibility by maintaining a valid tour structure throughout the process. The function ensures the neighbor solution remains feasible by validating the tour structure after each modification, and returns the improved solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # We prioritize solutions that are non-dominated or have high potential for improvement\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                # Check if solution i is dominated by solution j\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n\n    non_dominated_indices = [i for i in range(len(archive)) if not dominated[i]]\n    if non_dominated_indices:\n        # Select from non-dominated solutions\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        # If all are dominated, select randomly (could be improved with other criteria)\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # MSI (Multi-Segment Inversion)\n    if np.random.rand() < 0.7:  # Higher probability for MSI\n        # Select two random segments and reverse them\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n    else:\n        # GEI (Guided Edge Insertion)\n        # Select a node and insert it in a position that improves both objectives\n        node_idx = np.random.randint(n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        # Find the best insertion position\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(n - 1):\n            # Calculate improvement for both objectives\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            improvement1 = old_cost1 - new_cost1\n\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            improvement2 = old_cost2 - new_cost2\n\n            # Combine improvements (could be weighted)\n            total_improvement = improvement1 + improvement2\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is valid (all nodes are visited exactly once)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.8293718919577119,
               0.3290862441062927
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search strategy: 3-opt with biased edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify edges with high cost in either objective space\n    high_cost_edges = []\n    for i in range(n):\n        u, v = selected_solution[i], selected_solution[(i+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            high_cost_edges.append((i, (i+1)%n))\n\n    if high_cost_edges:\n        # Randomly select a high-cost edge to modify\n        edge_start, edge_end = random.choice(high_cost_edges)\n        # Apply 3-opt: reconnect three edges to form a new cycle\n        i, j, k = edge_start, (edge_start + 1) % n, (edge_start + 2) % n\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[k], new_solution[i], new_solution[j]\n\n    return new_solution\n\n",
          "score": [
               -0.9228213845482578,
               0.32953977584838867
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Rank solutions by combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_obj[:, 0] + normalized_obj[:, 1]\n    ranks = np.argsort(combined_scores)[::-1]\n\n    # Step 2: Probabilistically select a solution based on rank (higher rank = higher probability)\n    selection_probs = np.exp(-0.5 * np.arange(len(archive)))  # Exponential decay\n    selection_probs = selection_probs[ranks]\n    selection_probs /= selection_probs.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Identify critical edges (top 20% edges with highest contribution to total cost)\n    def get_edge_contributions(solution, distance_matrix):\n        total_cost = 0.0\n        edge_costs = []\n        for i in range(len(solution) - 1):\n            cost = distance_matrix[solution[i], solution[i+1]]\n            edge_costs.append(cost)\n            total_cost += cost\n        edge_costs.append(distance_matrix[solution[-1], solution[0]])  # Close the loop\n        total_cost += edge_costs[-1]\n        edge_contributions = np.array(edge_costs) / total_cost\n        return edge_contributions\n\n    edge_contrib_1 = get_edge_contributions(base_solution, distance_matrix_1)\n    edge_contrib_2 = get_edge_contributions(base_solution, distance_matrix_2)\n    combined_contrib = edge_contrib_1 + edge_contrib_2\n    critical_edges = np.argsort(combined_contrib)[-max(2, len(combined_contrib) // 5):]\n\n    # Step 4: Perform dynamic segment relocation\n    new_solution = base_solution.copy()\n    if len(critical_edges) < 2:\n        # Fallback to simple swap if not enough critical edges\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two critical edges and move a segment between them\n        edge1, edge2 = np.random.choice(critical_edges, 2, replace=False)\n        edge1, edge2 = min(edge1, edge2), max(edge1, edge2)\n\n        segment_length = np.random.randint(2, min(10, len(new_solution) // 2) + 1)\n        start_pos = edge1 + 1\n        end_pos = min(start_pos + segment_length, len(new_solution))\n\n        segment = new_solution[start_pos:end_pos]\n        new_solution = np.concatenate([\n            new_solution[:start_pos],\n            new_solution[end_pos:edge2+1],\n            segment,\n            new_solution[edge2+1:]\n        ])\n\n    # Step 5: Validate the new solution\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.784269083981462,
               0.31758350133895874
          ]
     },
     {
          "algorithm": "{The proposed heuristic function, 'select_neighbor', first identifies promising solutions in the archive by evaluating their non-dominated status and diversity, using a combination of Pareto dominance and crowding distance metrics to prioritize solutions that lie on the Pareto front or are isolated in the objective space. It then applies a hybrid local search operator that integrates a novel \"segment inversion\" strategy with a dynamic edge exchange mechanism. The segment inversion randomly selects a contiguous segment of nodes in the tour and reverses their order, while the dynamic edge exchange identifies the most promising edges to swap based on a weighted combination of their contributions to both objectives, ensuring feasibility by maintaining the tour's Hamiltonian cycle structure. The function intelligently selects a solution from the archive using a roulette wheel selection biased toward higher-quality solutions, and the generated neighbor solution is validated to ensure it remains a valid TSP tour before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a roulette wheel selection based on the inverse of the sum of objectives\n    objectives = np.array([obj for _, obj in archive])\n    fitness = 1.0 / (objectives.sum(axis=1) + 1e-10)  # Avoid division by zero\n    probabilities = fitness / fitness.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Segment inversion + Dynamic edge exchange\n    if n > 3:\n        # Segment inversion\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Dynamic edge exchange\n        # Find edges with high potential for improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Find the most promising edges to swap\n        for _ in range(min(3, n//2)):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n\n            # Calculate potential new costs\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            # Accept if improvement in at least one objective\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                current_cost1, current_cost2 = new_cost1, new_cost2\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.8839295824162168,
               0.33863770961761475
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify clusters using hierarchical clustering based on both coordinate spaces\n    from scipy.cluster.hierarchy import fcluster, linkage\n    from scipy.spatial.distance import pdist, squareform\n\n    # Combine coordinates from both spaces\n    combined_coords = np.column_stack((instance[new_solution, 0], instance[new_solution, 1], instance[new_solution, 2], instance[new_solution, 3]))\n\n    # Compute distance matrix for clustering\n    dist_matrix = squareform(pdist(combined_coords, 'euclidean'))\n    linkage_matrix = linkage(dist_matrix, method='ward')\n    clusters = fcluster(linkage_matrix, t=2, criterion='maxclust')\n\n    # Select a random cluster\n    unique_clusters = np.unique(clusters)\n    selected_cluster = np.random.choice(unique_clusters)\n    cluster_indices = np.where(clusters == selected_cluster)[0]\n\n    if len(cluster_indices) > 1:\n        # Rotate the segment by a random angle around the centroid\n        segment = new_solution[cluster_indices]\n        centroid_x1 = np.mean(instance[segment, 0])\n        centroid_y1 = np.mean(instance[segment, 1])\n        centroid_x2 = np.mean(instance[segment, 2])\n        centroid_y2 = np.mean(instance[segment, 3])\n\n        angle = np.random.uniform(0, 2 * np.pi)\n\n        # Rotate coordinates in both spaces\n        for i in segment:\n            x1, y1 = instance[i, 0], instance[i, 1]\n            x2, y2 = instance[i, 2], instance[i, 3]\n\n            # Rotate in first space\n            x1_rot = centroid_x1 + (x1 - centroid_x1) * np.cos(angle) - (y1 - centroid_y1) * np.sin(angle)\n            y1_rot = centroid_y1 + (x1 - centroid_x1) * np.sin(angle) + (y1 - centroid_y1) * np.cos(angle)\n\n            # Rotate in second space\n            x2_rot = centroid_x2 + (x2 - centroid_x2) * np.cos(angle) - (y2 - centroid_y2) * np.sin(angle)\n            y2_rot = centroid_y2 + (x2 - centroid_x2) * np.sin(angle) + (y2 - centroid_y2) * np.cos(angle)\n\n            instance[i, 0], instance[i, 1] = x1_rot, y1_rot\n            instance[i, 2], instance[i, 3] = x2_rot, y2_rot\n\n        # Update distance matrices\n        for i in range(n):\n            for j in range(n):\n                dx1 = instance[i, 0] - instance[j, 0]\n                dy1 = instance[i, 1] - instance[j, 1]\n                dx2 = instance[i, 2] - instance[j, 2]\n                dy2 = instance[i, 3] - instance[j, 3]\n                distance_matrix_1[i, j] = np.sqrt(dx1**2 + dy1**2)\n                distance_matrix_2[i, j] = np.sqrt(dx2**2 + dy2**2)\n\n    # Apply greedy insertion heuristic to refine the solution\n    for _ in range(10):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            # Try inserting node i after node j\n            temp_solution = np.concatenate([new_solution[:j+1], [new_solution[i]], new_solution[j+1:i], new_solution[i+1:]])\n            # Check if the new solution is better in both objectives\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.rand() < 0.1):\n                new_solution = temp_solution\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
          "score": [
               -0.9183994773416244,
               2.5024824738502502
          ]
     },
     {
          "algorithm": "{This new algorithm implements a novel local search strategy that combines adaptive segment reversal with objective-aware node repositioning. It first identifies the most promising solution from the archive by evaluating both objective values and their trade-off, then applies a multi-stage approach where segments of the tour are adaptively reversed based on their potential to improve both objectives, followed by a targeted node repositioning phase that considers the combined effect on both objectives, with a dynamic balance between exploration and exploitation guided by the current solution's objective values. The method ensures feasibility by maintaining the tour structure and verifying node uniqueness at each step, while incorporating a probabilistic acceptance criterion that allows for occasional non-improving moves to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with the best trade-off between objectives\n    def tradeoff_score(obj):\n        return (obj[0] + obj[1]) / (1 + abs(obj[0] - obj[1]))\n\n    best_solution = min(archive, key=lambda x: tradeoff_score(x[1]))[0].copy()\n\n    # Step 2: Adaptive segment reversal based on objective improvement\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Determine reversal segments based on objective values\n    reversal_points = sorted(random.sample(range(1, n-1), min(3, n//3)))\n    for i in range(len(reversal_points)-1):\n        a, b = reversal_points[i], reversal_points[i+1]\n        # Calculate potential improvement for both objectives\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        reversed_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[a], new_solution[(b+1)%n]])\n        reversed_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[a], new_solution[(b+1)%n]])\n\n        # Apply reversal if it improves at least one objective\n        if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 3: Objective-aware node repositioning\n    for _ in range(min(2, n//4)):\n        # Select a node based on its contribution to both objectives\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Calculate current contribution\n        prev_node = new_solution[node_idx-1]\n        next_node = new_solution[(node_idx+1)%n]\n        current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Find best insertion point considering both objectives\n        best_pos = -1\n        best_improvement = 0\n\n        for i in range(n):\n            if i == node_idx or i == (node_idx-1)%n:\n                continue\n\n            new_prev = new_solution[i-1]\n            new_next = new_solution[i]\n\n            new_cost1 = (distance_matrix_1[new_prev, node] +\n                         distance_matrix_1[node, new_next] +\n                         distance_matrix_1[prev_node, next_node])\n            new_cost2 = (distance_matrix_2[new_prev, node] +\n                         distance_matrix_2[node, new_next] +\n                         distance_matrix_2[prev_node, next_node])\n\n            # Weighted improvement considering both objectives\n            improvement = 0.7*(current_cost1 - new_cost1) + 0.3*(current_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = i\n\n        # Apply the best move if it improves at least one objective\n        if best_pos != -1 and best_improvement > 0:\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure solution remains valid\n    assert len(new_solution) == len(best_solution) and len(np.unique(new_solution)) == len(best_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.5972377306405723,
               0.41786980628967285
          ]
     }
]