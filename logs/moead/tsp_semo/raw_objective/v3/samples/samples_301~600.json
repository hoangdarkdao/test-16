[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct positions\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n\n    # Extract segments\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    segment4 = new_solution[d:]\n\n    # Apply biased segment reversal and reinsertion\n    if np.random.rand() < 0.7:\n        # Reverse segments with higher probability\n        if np.random.rand() < 0.5:\n            new_order = np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n        else:\n            new_order = np.concatenate([segment1, segment4, segment2[::-1], segment3[::-1]])\n    else:\n        # Reinsert segments with some probability\n        if np.random.rand() < 0.5:\n            new_order = np.concatenate([segment1, segment3, segment2, segment4])\n        else:\n            new_order = np.concatenate([segment1, segment4, segment3, segment2])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_order)) == n:\n        new_solution[a:d] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.453435812308798,
            6.446993842260369
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct positions\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n\n    # Extract segments\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    segment4 = new_solution[d:]\n\n    # Apply biased segment reversal and reinsertion\n    if np.random.rand() < 0.7:\n        # Reverse segments with higher probability\n        if np.random.rand() < 0.5:\n            new_order = np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n        else:\n            new_order = np.concatenate([segment1, segment4, segment2[::-1], segment3[::-1]])\n    else:\n        # Reinsert segments with some probability\n        if np.random.rand() < 0.5:\n            new_order = np.concatenate([segment1, segment3, segment2, segment4])\n        else:\n            new_order = np.concatenate([segment1, segment4, segment3, segment2])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_order)) == n:\n        new_solution[a:d] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution from the archive with the highest sum of normalized objectives, then applies a novel local search operator that combines segment reversal with biased edge insertion, ensuring feasibility by validating the tour structure before returning the neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_sum = -float('inf')\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / distance_matrix_1.max()\n        norm_obj2 = obj2 / distance_matrix_2.max()\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply novel local search operator\n    if n > 3:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n\n        # Insert reversed segment after a random position\n        insert_pos = np.random.randint(0, n)\n        while insert_pos in range(a, b):\n            insert_pos = np.random.randint(0, n)\n\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates and ensure tour validity\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) == n:\n            return new_solution\n\n    # Fallback: swap two random nodes if the above fails\n    i, j = np.random.choice(range(n), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    return new_solution\n\n",
        "score": [
            10.4282284473474,
            10.597234575887025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_sum = -float('inf')\n    selected_solution = None\n    for sol, (obj1, obj2) in archive:\n        norm_obj1 = obj1 / distance_matrix_1.max()\n        norm_obj2 = obj2 / distance_matrix_2.max()\n        current_sum = norm_obj1 + norm_obj2\n        if current_sum > max_sum:\n            max_sum = current_sum\n            selected_solution = sol\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply novel local search operator\n    if n > 3:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        segment = new_solution[a:b]\n        reversed_segment = segment[::-1]\n\n        # Insert reversed segment after a random position\n        insert_pos = np.random.randint(0, n)\n        while insert_pos in range(a, b):\n            insert_pos = np.random.randint(0, n)\n\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates and ensure tour validity\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) == n:\n            return new_solution\n\n    # Fallback: swap two random nodes if the above fails\n    i, j = np.random.choice(range(n), size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    return new_solution\n\n"
    }
]