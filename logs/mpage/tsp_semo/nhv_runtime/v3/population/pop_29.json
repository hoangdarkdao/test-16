[
     {
          "algorithm": "{This new algorithm introduces a hierarchical local search approach that combines a multi-objective-aware node clustering strategy with a novel edge contraction-expansion mechanism. It first identifies clusters of nodes based on their proximity in both objective spaces, then selectively contracts edges between distant clusters while expanding edges within clusters, followed by a probabilistic node reordering that prioritizes edges with balanced distance improvements across objectives. The method incorporates a dynamic cluster size adjustment based on the current solution's objective balance, ensuring exploration of diverse neighborhoods while maintaining feasibility through careful validation and fallback mechanisms.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    obj_balance = np.abs(objectives[:, 0] - objectives[:, 1]) / (objectives.sum(axis=1) + 1e-6)\n    weights = 1.0 / (obj_balance + 1e-6)\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Step 2: Cluster nodes based on both distance matrices\n    cluster_size = max(3, min(8, n // 3))\n    clusters = []\n    remaining = set(range(n))\n    while remaining:\n        center = np.random.choice(list(remaining))\n        cluster = [center]\n        remaining.remove(center)\n        for _ in range(cluster_size - 1):\n            if not remaining:\n                break\n            closest = min(remaining, key=lambda x: distance_matrix_1[center, x] + distance_matrix_2[center, x])\n            cluster.append(closest)\n            remaining.remove(closest)\n        clusters.append(cluster)\n\n    # Step 3: Edge contraction-expansion within clusters\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n        # Contract edges between cluster nodes\n        for i in range(len(cluster)):\n            for j in range(i+1, len(cluster)):\n                a, b = cluster[i], cluster[j]\n                if a > b:\n                    a, b = b, a\n                # Check if swapping a and b improves both objectives\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta1 + delta2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        # Expand edges within cluster\n        for i in range(len(cluster)-1):\n            a, b = cluster[i], cluster[i+1]\n            if a > b:\n                a, b = b, a\n            # Check if moving b after a improves both objectives\n            if b != (a+1)%n:\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n                if delta1 + delta2 < 0:\n                    # Move b after a\n                    node = new_solution[b]\n                    new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n                    insert_pos = np.where(new_solution == new_solution[a])[0][0] + 1\n                    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 4: Probabilistic node reordering based on objective balance\n    obj1, obj2 = archive[selected_idx][1]\n    if abs(obj1 - obj2) > 0.2 * (obj1 + obj2):\n        # More aggressive reordering when objectives are unbalanced\n        for _ in range(3):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            # Check if swapping segments improves both objectives\n            delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                     distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                     distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n            if delta1 + delta2 < 0:\n                new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 5: Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -1.0807467550296899,
               0.6731994152069092
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a novel \"objective-balanced path inversion\" strategy that first selects a solution from the archive based on a combined objective score, then dynamically partitions the tour into balanced segments where each segment's length is determined by the harmonic mean of the segment's individual objective costs, followed by a probabilistic inversion of these segments with a probability inversely proportional to their objective balance, while maintaining feasibility through careful segment boundary tracking and a fallback mechanism that ensures connectivity by reinserting any disconnected segments back into the tour, all while incorporating a dynamic objective weighting that adapts to the archive's current non-dominated front to guide the search toward more balanced solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Dynamic segment partitioning based on objective balance\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        cost1 = distance_matrix_1[current_segment[-1], node]\n        cost2 = distance_matrix_2[current_segment[-1], node]\n\n        # Calculate segment length based on harmonic mean\n        if cost1 + cost2 > 0:\n            segment_length = 2 * cost1 * cost2 / (cost1 + cost2 + 1e-6)\n        else:\n            segment_length = 1\n\n        if len(current_segment) < segment_length:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Probabilistic segment inversion\n    for seg in segments:\n        if len(seg) < 2:\n            continue\n\n        # Calculate segment's objective balance\n        seg_cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        seg_cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        balance = abs(seg_cost1 - seg_cost2) / (seg_cost1 + seg_cost2 + 1e-6)\n\n        # Inversion probability inversely proportional to balance\n        if np.random.random() < 1.0 / (balance + 1e-6):\n            seg.reverse()\n\n    # Reconstruct solution from segments\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(new_solution) != n + 1 or len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return np.array(new_solution)\n\n",
          "score": [
               -1.0044415389105121,
               0.0769835114479065
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a \"multi-objective tour decomposition and recombination\" strategy that first selects a solution from the archive based on a novel \"objective diversity metric\" which prioritizes solutions with unbalanced improvements in either objective, then decomposes the tour into overlapping segments using a \"dual-objective segment clustering\" approach that groups nodes based on their connection costs in both objectives, followed by a \"probabilistic segment merging and splitting\" process that intelligently combines and divides segments while incorporating a \"cross-objective segment transposition\" mechanism that moves segments between different positions in the tour based on their potential to improve the underperforming objective, with the recombination decisions guided by a weighted combination of segment-specific costs and their objective-specific connection potential, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment transposition if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(obj_diversity)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment decomposition based on both objectives\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate segment properties\n        if len(current_segment) > 1:\n            # Average costs in current segment\n            avg_cost1 = sum(distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n            avg_cost2 = sum(distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n\n            # Variance in connection costs\n            var_cost1 = np.var([distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n            var_cost2 = np.var([distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n        else:\n            avg_cost1 = avg_cost2 = var_cost1 = var_cost2 = 0\n\n        # Decide whether to start new segment\n        if (cost1 > 1.5 * avg_cost1 or cost2 > 1.5 * avg_cost2) or (var_cost1 > 0.3 or var_cost2 > 0.3) or len(current_segment) >= 5:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Segment transformation with objective awareness\n    transformed_segments = []\n    for segment in segments:\n        if len(segment) > 2:\n            # Calculate segment costs\n            seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Decide transformation based on objective balance\n            if seg_cost1 > seg_cost2:\n                # Improve objective 1 by reversing segment\n                transformed_segments.append(segment[::-1])\n            else:\n                # Improve objective 2 by rotating segment\n                rotation = np.random.randint(1, len(segment))\n                transformed_segments.append(segment[rotation:] + segment[:rotation])\n        else:\n            transformed_segments.append(segment)\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in transformed_segments:\n        new_solution.extend(segment)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple inversion of a random segment\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9342277012596714,
               0.0691184401512146
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a \"multi-objective tour decomposition and recombination\" strategy that first selects a solution from the archive based on a novel \"objective diversity metric\" which prioritizes solutions with unbalanced improvements in either objective, then decomposes the tour into overlapping segments using a \"dual-objective segment clustering\" approach that groups nodes based on their connection costs in both objectives, followed by a \"probabilistic segment merging and splitting\" process that intelligently combines and divides segments while incorporating a \"cross-objective segment transposition\" mechanism that moves segments between different positions in the tour based on their potential to improve the underperforming objective, with the recombination decisions guided by a weighted combination of segment-specific costs and their objective-specific connection potential, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment transposition if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(obj_diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment decomposition based on both objectives\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate segment properties\n        if len(current_segment) > 1:\n            # Average costs in current segment\n            avg_cost1 = sum(distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n            avg_cost2 = sum(distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n\n            # Variance in connection costs\n            var_cost1 = np.var([distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n            var_cost2 = np.var([distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n        else:\n            avg_cost1 = avg_cost2 = var_cost1 = var_cost2 = 0\n\n        # Decide whether to start new segment\n        if (cost1 > 1.5 * avg_cost1 or cost2 > 1.5 * avg_cost2) or (var_cost1 > 0.3 or var_cost2 > 0.3) or len(current_segment) >= 5:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Segment transformation with objective awareness\n    transformed_segments = []\n    for segment in segments:\n        if len(segment) > 2:\n            # Calculate segment costs\n            seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Decide transformation based on objective balance\n            if seg_cost1 > seg_cost2:\n                # Improve objective 1 by reversing segment\n                transformed_segments.append(segment[::-1])\n            else:\n                # Improve objective 2 by rotating segment\n                rotation = np.random.randint(1, len(segment))\n                transformed_segments.append(segment[rotation:] + segment[:rotation])\n        else:\n            transformed_segments.append(segment)\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in transformed_segments:\n        new_solution.extend(segment)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple inversion of a random segment\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9483890474490249,
               0.07203096151351929
          ]
     },
     {
          "algorithm": "{The new algorithm combines a multi-objective-aware node prioritization strategy with a novel adaptive segment inversion mechanism that first identifies critical nodes based on their sensitivity to both objectives, then dynamically adjusts segment boundaries using a correlation-aware inversion process that selectively inverts segments when the correlation between objectives in the segment is negative, while prioritizing nodes that show high sensitivity to both objectives, and incorporating a probabilistic segment merging approach that intelligently combines adjacent segments when their connection costs in both objectives show strong positive correlation, with the segment inversion decisions guided by a weighted combination of node-specific sensitivity, segment-specific correlation, and the overall objective balance, ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple node swap if the solution becomes invalid, while maintaining a balance between exploration and exploitation through dynamic adjustment of the inversion probability based on the current solution's objective balance.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective balance\n    objectives = np.array([obj for _, obj in archive])\n    obj_balance = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(obj_balance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Identify critical nodes based on sensitivity to both objectives\n    sensitivity = np.zeros(n)\n    for i in range(n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1)%n]\n\n        # Calculate sensitivity to each objective\n        sens1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        sens2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        sensitivity[i] = abs(sens1 - sens2) / (sens1 + sens2 + 1e-6)\n\n    # Dynamic segment boundary adjustment with adaptive inversion\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate segment correlation\n        if len(current_segment) > 1:\n            seg_costs1 = [distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)]\n            seg_costs2 = [distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)]\n            seg_correlation = np.corrcoef(seg_costs1, seg_costs2)[0, 1]\n        else:\n            seg_correlation = 0\n\n        # Decide whether to merge or invert\n        if seg_correlation < -0.5 and np.random.rand() < 0.7:\n            # Invert segment if correlation is negative\n            current_segment = current_segment[::-1]\n            segments.append(current_segment)\n            current_segment = [node]\n        elif seg_correlation > 0.7 or len(current_segment) >= 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n    segments.append(current_segment)\n\n    # Prioritize critical nodes in inversion decisions\n    for i in range(len(segments)):\n        if len(segments[i]) > 1:\n            # Check if segment contains critical nodes\n            critical_in_segment = any(sensitivity[np.where(base_solution == node)[0][0]] > 0.3 for node in segments[i])\n            if critical_in_segment and np.random.rand() < 0.5:\n                segments[i] = segments[i][::-1]\n\n    # Reconstruct solution\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -1.010863107439068,
               0.10437172651290894
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a \"multi-objective tour restructuring and hybrid segment fusion\" strategy that first selects a solution from the archive based on a novel \"objective correlation metric\" which prioritizes solutions where the improvement directions in both objectives are highly correlated, then decomposes the tour into variable-length segments using a \"dual-objective segment fusion\" approach that intelligently merges adjacent nodes when their connection costs in both objectives show strong positive correlation, followed by a \"probabilistic segment reordering and inversion\" process that reorders segments based on their potential to improve the underperforming objective while considering the correlation between objectives, with the reordering decisions guided by a weighted combination of segment-specific costs, their objective-specific connection potential, and the correlation between the objectives, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment reordering if the solution becomes invalid, incorporating a \"correlation-aware segment inversion\" mechanism that inverts segments when the correlation between objectives in the segment is negative, to potentially improve both objectives simultaneously.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective correlation\n    objectives = np.array([obj for _, obj in archive])\n    correlation = np.corrcoef(objectives[:, 0], objectives[:, 1])[0, 1]\n    if correlation > 0.5:\n        selected_idx = np.argmax(np.abs(objectives[:, 0] - objectives[:, 1]))\n    else:\n        selected_idx = np.argmin(np.abs(objectives[:, 0] - objectives[:, 1]))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dual-objective segment fusion\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate correlation in current segment\n        if len(current_segment) > 1:\n            seg_costs1 = [distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)]\n            seg_costs2 = [distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)]\n            seg_correlation = np.corrcoef(seg_costs1, seg_costs2)[0, 1]\n        else:\n            seg_correlation = 0\n\n        # Decide whether to merge with current segment\n        if seg_correlation > 0.7 or len(current_segment) >= 4:\n            current_segment.append(node)\n        else:\n            segments.append(current_segment)\n            current_segment = [node]\n    segments.append(current_segment)\n\n    # Probabilistic segment reordering and inversion\n    if len(segments) > 1:\n        # Calculate current objectives\n        obj1 = sum(distance_matrix_1[base_solution[i], base_solution[i+1]] for i in range(n-1))\n        obj2 = sum(distance_matrix_2[base_solution[i], base_solution[i+1]] for i in range(n-1))\n        obj_balance = obj1 - obj2\n\n        # Calculate segment properties\n        segment_props = []\n        for seg in segments:\n            seg_cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            seg_cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            seg_corr = np.corrcoef(\n                [distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1)],\n                [distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1)]\n            )[0, 1]\n            segment_props.append((seg_cost1, seg_cost2, seg_corr))\n\n        # Reorder segments\n        if obj_balance > 0:  # Objective 1 is worse\n            # Sort segments by potential to improve objective 1 (considering correlation)\n            segments_sorted = sorted(\n                range(len(segments)),\n                key=lambda i: segment_props[i][0] - (0.5 * segment_props[i][2] * segment_props[i][1])\n            )\n            new_order = segments_sorted\n        else:  # Objective 2 is worse\n            # Sort segments by potential to improve objective 2 (considering correlation)\n            segments_sorted = sorted(\n                range(len(segments)),\n                key=lambda i: segment_props[i][1] - (0.5 * segment_props[i][2] * segment_props[i][0])\n            )\n            new_order = segments_sorted\n\n        # Invert segments with negative correlation\n        for i in range(len(segments)):\n            if segment_props[i][2] < -0.3:\n                segments[i] = segments[i][::-1]\n\n        # Apply new order\n        new_segments = [segments[i] for i in new_order]\n        new_solution = []\n        for seg in new_segments:\n            new_solution.extend(seg)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple segment reordering\n        np.random.shuffle(segments)\n        new_solution = []\n        for seg in segments:\n            new_solution.extend(seg)\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -1.053888153118009,
               1.1229557991027832
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a \"multi-objective tour reconfiguration and adaptive segment permutation\" strategy that first selects a solution from the archive based on a novel \"objective balance metric\" which prioritizes solutions with balanced improvements in both objectives, then decomposes the tour into non-overlapping segments using a \"dual-objective segment analysis\" approach that evaluates each node's contribution to both objectives, followed by an \"adaptive segment permutation and rotation\" process that reorders segments based on their potential to simultaneously improve both objectives while considering the correlation between objectives, with the permutation decisions guided by a weighted combination of segment-specific costs, their objective-specific connection potential, and the correlation between the objectives, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment rotation if the solution becomes invalid, incorporating an \"objective-aware segment permutation\" mechanism that permutes segments when the correlation between objectives in the segment is positive, to potentially improve both objectives simultaneously, and an \"adaptive segment rotation\" mechanism that rotates segments when the correlation is negative, to potentially balance both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with most balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    balance = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmin(balance)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment decomposition based on both objectives\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate segment properties\n        if len(current_segment) > 1:\n            # Average costs in current segment\n            avg_cost1 = sum(distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n            avg_cost2 = sum(distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n\n            # Correlation in current segment\n            seg_costs1 = [distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)]\n            seg_costs2 = [distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)]\n            seg_corr = np.corrcoef(seg_costs1, seg_costs2)[0, 1] if len(seg_costs1) > 1 else 0\n        else:\n            avg_cost1 = avg_cost2 = seg_corr = 0\n\n        # Decide whether to start new segment\n        if (cost1 > 1.5 * avg_cost1 or cost2 > 1.5 * avg_cost2) or (seg_corr < -0.3) or len(current_segment) >= 4:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Adaptive segment permutation and rotation\n    if len(segments) > 1:\n        # Calculate segment properties\n        segment_props = []\n        for seg in segments:\n            seg_cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            seg_cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            seg_corr = np.corrcoef(\n                [distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1)],\n                [distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1)]\n            )[0, 1] if len(seg) > 2 else 0\n            segment_props.append((seg_cost1, seg_cost2, seg_corr))\n\n        # Permute segments based on correlation\n        permuted_segments = []\n        for i in range(len(segments)):\n            if segment_props[i][2] > 0.5:  # Positive correlation, permute\n                if len(segments[i]) > 2:\n                    # Find best permutation\n                    best_perm = segments[i]\n                    best_score = segment_props[i][0] + segment_props[i][1]\n                    for _ in range(3):\n                        perm = segments[i].copy()\n                        np.random.shuffle(perm)\n                        perm_cost1 = sum(distance_matrix_1[perm[j], perm[j+1]] for j in range(len(perm)-1))\n                        perm_cost2 = sum(distance_matrix_2[perm[j], perm[j+1]] for j in range(len(perm)-1))\n                        if perm_cost1 + perm_cost2 < best_score:\n                            best_perm = perm\n                            best_score = perm_cost1 + perm_cost2\n                    permuted_segments.append(best_perm)\n                else:\n                    permuted_segments.append(segments[i])\n            else:  # Negative correlation, rotate\n                if len(segments[i]) > 2:\n                    rotation = np.random.randint(1, len(segments[i]))\n                    permuted_segments.append(segments[i][rotation:] + segments[i][:rotation])\n                else:\n                    permuted_segments.append(segments[i])\n        segments = permuted_segments\n\n    # Reconstruct solution\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple rotation of a random segment\n        i = np.random.randint(1, len(segments))\n        rotation = np.random.randint(1, len(segments[i]))\n        segments[i] = segments[i][rotation:] + segments[i][:rotation]\n        new_solution = []\n        for seg in segments:\n            new_solution.extend(seg)\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.993879851155183,
               0.09145128726959229
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a \"multi-objective tour decomposition and recombination\" strategy that first selects a solution from the archive based on a novel \"objective diversity metric\" which prioritizes solutions with unbalanced improvements in either objective, then decomposes the tour into overlapping segments using a \"dual-objective segment clustering\" approach that groups nodes based on their connection costs in both objectives, followed by a \"probabilistic segment merging and splitting\" process that intelligently combines and divides segments while incorporating a \"cross-objective segment transposition\" mechanism that moves segments between different positions in the tour based on their potential to improve the underperforming objective, with the recombination decisions guided by a weighted combination of segment-specific costs and their objective-specific connection potential, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment transposition if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    obj_diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(obj_diversity)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Segment decomposition based on both objectives\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        # Calculate connection costs\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Calculate segment properties\n        if len(current_segment) > 1:\n            # Average costs in current segment\n            avg_cost1 = sum(distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n            avg_cost2 = sum(distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n\n            # Variance in connection costs\n            var_cost1 = np.var([distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n            var_cost2 = np.var([distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n        else:\n            avg_cost1 = avg_cost2 = var_cost1 = var_cost2 = 0\n\n        # Decide whether to start new segment\n        if (cost1 > 1.5 * avg_cost1 or cost2 > 1.5 * avg_cost2) or (var_cost1 > 0.3 or var_cost2 > 0.3) or len(current_segment) >= 5:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    # Segment transformation with objective awareness\n    transformed_segments = []\n    for segment in segments:\n        if len(segment) > 2:\n            # Calculate segment costs\n            seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Decide transformation based on objective balance\n            if seg_cost1 > seg_cost2:\n                # Improve objective 1 by reversing segment\n                transformed_segments.append(segment[::-1])\n            else:\n                # Improve objective 2 by rotating segment\n                rotation = np.random.randint(1, len(segment))\n                transformed_segments.append(segment[rotation:] + segment[:rotation])\n        else:\n            transformed_segments.append(segment)\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in transformed_segments:\n        new_solution.extend(segment)\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    if len(np.unique(new_solution[:-1])) != n:\n        # Fallback to simple inversion of a random segment\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9267536484343754,
               0.07081156969070435
          ]
     },
     {
          "algorithm": "{This new algorithm introduces a \"multi-objective tour decomposition and recombination\" strategy that first selects a solution from the archive based on a novel \"objective diversity metric\" which prioritizes solutions with unbalanced improvements in either objective, then decomposes the tour into overlapping segments using a \"dual-objective segment clustering\" approach that groups nodes based on their connection costs in both objectives, followed by a \"probabilistic segment merging and splitting\" process that intelligently combines and divides segments while incorporating a \"cross-objective segment transposition\" mechanism that moves segments between different positions in the tour based on their potential to improve the underperforming objective, with the recombination decisions guided by a weighted combination of segment-specific costs and their objective-specific connection potential, while ensuring feasibility through a comprehensive validation process that verifies node coverage and tour connectivity, and includes a fallback mechanism to a simple segment transposition if the solution becomes invalid.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    obj_diversity = np.abs(objectives[:, 0] - objectives[:, 1])\n    selected_idx = np.argmax(obj_diversity)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    segments = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = current_segment[-1]\n\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        if len(current_segment) > 1:\n            avg_cost1 = sum(distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n            avg_cost2 = sum(distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)) / (len(current_segment)-1)\n            var_cost1 = np.var([distance_matrix_1[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n            var_cost2 = np.var([distance_matrix_2[current_segment[j], current_segment[j+1]] for j in range(len(current_segment)-1)])\n        else:\n            avg_cost1 = avg_cost2 = var_cost1 = var_cost2 = 0\n\n        if (cost1 > 1.5 * avg_cost1 or cost2 > 1.5 * avg_cost2) or (var_cost1 > 0.3 or var_cost2 > 0.3) or len(current_segment) >= 5:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n    segments.append(current_segment)\n\n    transformed_segments = []\n    for i, segment in enumerate(segments):\n        if len(segment) > 2:\n            seg_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n            seg_cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n            if seg_cost1 > seg_cost2:\n                transformed_segments.append(segment[::-1])\n            else:\n                rotation = np.random.randint(1, len(segment))\n                transformed_segments.append(segment[rotation:] + segment[:rotation])\n        else:\n            transformed_segments.append(segment)\n\n    new_solution = []\n    for segment in transformed_segments:\n        new_solution.extend(segment)\n\n    new_solution.append(new_solution[0])\n\n    if len(np.unique(new_solution[:-1])) != n:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9236383996036828,
               0.06979376077651978
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol_i, obj_i))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Step 2: Select a solution based on objective values and diversity\n    objectives = np.array([obj for _, obj in pareto_front])\n    normalized_obj = objectives / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = []\n    for sol, _ in pareto_front:\n        unique_edges = set()\n        for i in range(len(sol)):\n            unique_edges.add((min(sol[i], sol[(i+1)%len(sol)]), max(sol[i], sol[(i+1)%len(sol)])))\n        diversity_scores.append(len(unique_edges))\n    diversity_scores = np.array(diversity_scores) / (np.max(diversity_scores) + 1e-10)\n\n    selection_scores = 0.7 * (1 - normalized_obj[:, 0]) + 0.3 * diversity_scores\n    selected_idx = np.argmax(selection_scores)\n    base_solution = pareto_front[selected_idx][0].copy()\n\n    # Step 3: Multi-segment crossover operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select two random segments from the base solution\n    seg1_start = np.random.randint(0, n)\n    seg1_length = np.random.randint(2, min(4, n//2))\n    seg1_end = (seg1_start + seg1_length) % n\n\n    seg2_start = np.random.randint(0, n)\n    while abs(seg2_start - seg1_start) < 2 or abs(seg2_start - seg1_end) < 2:\n        seg2_start = np.random.randint(0, n)\n    seg2_length = np.random.randint(2, min(4, n//2))\n    seg2_end = (seg2_start + seg2_length) % n\n\n    # Extract segments\n    if seg1_start < seg1_end:\n        seg1 = new_solution[seg1_start:seg1_end]\n    else:\n        seg1 = np.concatenate([new_solution[seg1_start:], new_solution[:seg1_end]])\n\n    if seg2_start < seg2_end:\n        seg2 = new_solution[seg2_start:seg2_end]\n    else:\n        seg2 = np.concatenate([new_solution[seg2_start:], new_solution[:seg2_end]])\n\n    # Select a third segment from another solution in the archive\n    other_sol = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n    seg3_start = np.random.randint(0, n)\n    seg3_length = np.random.randint(2, min(4, n//2))\n    seg3_end = (seg3_start + seg3_length) % n\n\n    if seg3_start < seg3_end:\n        seg3 = other_sol[seg3_start:seg3_end]\n    else:\n        seg3 = np.concatenate([other_sol[seg3_start:], other_sol[:seg3_end]])\n\n    # Combine segments to form new solution\n    remaining_nodes = set(range(n)) - set(seg1) - set(seg2) - set(seg3)\n    new_solution = np.concatenate([seg1, seg2, seg3, np.array(list(remaining_nodes))])\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0059111292081795,
               0.346810519695282
          ]
     }
]