[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment-based perturbation\n    n = len(new_solution)\n    if n < 4:\n        # If too small, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select three random segments to modify\n        segments = np.sort(np.random.choice(n, 3, replace=False))\n        a, b, c = segments\n\n        # Extract segments\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Recombine segments with novel perturbation\n        new_order = np.concatenate([\n            segment1,\n            segment3[::-1],  # Reverse middle segment\n            segment2,\n            segment4\n        ])\n\n        # Ensure all nodes are visited exactly once\n        if len(np.unique(new_order)) == n:\n            new_solution = new_order\n\n    return new_solution\n\n",
          "score": [
               -0.79853724529653,
               0.20083975791931152
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 4, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment inversion\n    if end < n:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.002562955635491,
               0.30344176292419434
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined objective value (to explore less crowded regions)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: Combine segment inversion with adaptive perturbation based on objective diversity\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a random 4-opt move if possible\n        if n >= 4:\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[j:k][::-1],\n                new_solution[i:j],\n                new_solution[k:l][::-1],\n                new_solution[l:]\n            ])\n        else:\n            # Simple swap for very small instances\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive segment selection based on objective diversity\n        obj_diversity = archive[selected_idx][1][0] / archive[selected_idx][1][1] if archive[selected_idx][1][1] != 0 else 1.0\n\n        if obj_diversity > 1.5:\n            # More aggressive perturbation when objectives are diverse\n            segments = sorted(random.sample(range(1, n-1), 3))\n            a, b, c = segments\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:c][::-1],\n                new_solution[a:b],\n                new_solution[c:][::-1]\n            ])\n        else:\n            # More conservative perturbation when objectives are balanced\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[j:][::-1],\n                new_solution[i:j]\n            ])\n\n    # Ensure all nodes are visited exactly once\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple valid move if the above fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.8878011692665726,
               0.21410870552062988
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 4, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment inversion\n    if end < n:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0217187909531733,
               0.3751102089881897
          ]
     },
     {
          "algorithm": "{The new algorithm will first identify solutions in the archive that show potential for improvement by analyzing both their objective values and the diversity of their node sequences, then apply a novel 'multi-dimensional cluster inversion' strategy that randomly groups nodes into clusters based on their geometric proximity in both coordinate spaces, inverts each cluster's sequence while maintaining spatial coherence, and optimally reassigns edges between clusters by considering both distance matrices, all while ensuring feasibility by verifying that the resulting tour remains a valid permutation of all nodes and maintaining the circular nature of the tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate potential improvement score considering both objectives and diversity\n        obj_score = (obj[0] + obj[1]) / 2\n        diversity_score = len(set(sol)) / len(sol)\n        improvement_score = obj_score * diversity_score\n        candidates.append((sol, improvement_score))\n\n    candidates.sort(key=lambda x: -x[1])\n    selected = candidates[0][0].copy()\n\n    # Step 2: Apply multi-dimensional cluster inversion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Create clusters based on geometric proximity in both spaces\n    clusters = []\n    remaining = list(range(n))\n    while len(remaining) > 0:\n        # Randomly select a seed node\n        seed = random.choice(remaining)\n        cluster = [seed]\n        remaining.remove(seed)\n\n        # Find nearby nodes in both spaces\n        for node in remaining[:]:\n            x1_seed, y1_seed, x2_seed, y2_seed = instance[selected[seed]]\n            x1_node, y1_node, x2_node, y2_node = instance[selected[node]]\n\n            # Calculate distances in both spaces\n            dist1 = np.sqrt((x1_seed - x1_node)**2 + (y1_seed - y1_node)**2)\n            dist2 = np.sqrt((x2_seed - x2_node)**2 + (y2_seed - y2_node)**2)\n\n            # Add to cluster if close in both spaces\n            if dist1 < np.mean(distance_matrix_1) * 0.5 and dist2 < np.mean(distance_matrix_2) * 0.5:\n                cluster.append(node)\n                remaining.remove(node)\n\n        if len(cluster) > 1:\n            clusters.append(cluster)\n\n    # Invert each cluster while maintaining spatial coherence\n    for cluster in clusters:\n        # Find the cluster's centroid in both spaces\n        centroid1_x = np.mean([instance[selected[node]][0] for node in cluster])\n        centroid1_y = np.mean([instance[selected[node]][1] for node in cluster])\n        centroid2_x = np.mean([instance[selected[node]][2] for node in cluster])\n        centroid2_y = np.mean([instance[selected[node]][3] for node in cluster])\n\n        # Sort nodes in the cluster by angle relative to centroid in both spaces\n        def angle_sort_key(node):\n            x1, y1, x2, y2 = instance[selected[node]]\n            angle1 = np.arctan2(y1 - centroid1_y, x1 - centroid1_x)\n            angle2 = np.arctan2(y2 - centroid2_y, x2 - centroid2_x)\n            return (angle1 + angle2) / 2\n\n        cluster_sorted = sorted(cluster, key=angle_sort_key)\n        new_solution[cluster] = [selected[node] for node in cluster_sorted[::-1]]\n\n    # Step 3: Optimally reassign edges between clusters\n    for i in range(len(clusters)-1):\n        cluster1 = clusters[i]\n        cluster2 = clusters[i+1]\n\n        # Find best edge to connect clusters\n        best_improvement = 0\n        best_edge = None\n\n        for a in cluster1:\n            for b in cluster2:\n                # Current edges\n                prev_a = selected[a-1] if a > 0 else selected[-1]\n                next_a = selected[(a+1)%n]\n                prev_b = selected[b-1] if b > 0 else selected[-1]\n                next_b = selected[(b+1)%n]\n\n                # Current costs\n                current_cost1 = (distance_matrix_1[prev_a, selected[a]] +\n                                distance_matrix_1[selected[a], next_a] +\n                                distance_matrix_1[prev_b, selected[b]] +\n                                distance_matrix_1[selected[b], next_b])\n                current_cost2 = (distance_matrix_2[prev_a, selected[a]] +\n                                distance_matrix_2[selected[a], next_a] +\n                                distance_matrix_2[prev_b, selected[b]] +\n                                distance_matrix_2[selected[b], next_b])\n\n                # New costs if we connect a to b\n                new_cost1 = (distance_matrix_1[prev_a, selected[a]] +\n                            distance_matrix_1[selected[a], selected[b]] +\n                            distance_matrix_1[selected[b], next_a] +\n                            distance_matrix_1[prev_b, selected[b]] +\n                            distance_matrix_1[selected[b], next_b])\n                new_cost2 = (distance_matrix_2[prev_a, selected[a]] +\n                            distance_matrix_2[selected[a], selected[b]] +\n                            distance_matrix_2[selected[b], next_a] +\n                            distance_matrix_2[prev_b, selected[b]] +\n                            distance_matrix_2[selected[b], next_b])\n\n                improvement = (current_cost1 + current_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_edge = (a, b)\n\n        # Apply the best edge connection\n        if best_edge:\n            a, b = best_edge\n            a_pos = np.where(new_solution == selected[a])[0][0]\n            b_pos = np.where(new_solution == selected[b])[0][0]\n\n            if a_pos > b_pos:\n                a_pos, b_pos = b_pos, a_pos\n\n            new_solution[a_pos+1:b_pos] = new_solution[a_pos+1:b_pos][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.036349290086442,
               2.395252764225006
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 4, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment inversion\n    if end < n:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9119965028668441,
               0.27439093589782715
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the current best)\n    selected = None\n    max_gap = -1\n    for sol, obj in archive:\n        gap = abs(obj[0] - obj[1])  # Measure the diversity of objectives\n        if gap > max_gap:\n            max_gap = gap\n            selected = sol\n\n    if selected is None:\n        selected = archive[0][0]\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine 3-opt with a biased random swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three segments to perform a 3-opt move\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Create all possible 3-opt variants and select the best one\n    variants = [\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:][::-1]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:][::-1]])\n    ]\n\n    # Evaluate variants based on both objectives\n    best_variant = None\n    best_score = float('inf')\n    for variant in variants:\n        cost1 = sum(distance_matrix_1[variant[i], variant[i+1]] for i in range(-1, n-1))\n        cost2 = sum(distance_matrix_2[variant[i], variant[i+1]] for i in range(-1, n-1))\n        score = cost1 + cost2  # Simple weighted sum for selection\n        if score < best_score:\n            best_score = score\n            best_variant = variant\n\n    if best_variant is not None:\n        new_solution = best_variant.copy()\n\n    # Apply a biased random swap based on distance matrix\n    a, b = random.sample(range(n), 2)\n    if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a]] < \\\n       distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               -0.6417830066181451,
               0.25273948907852173
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the backbone idea of combining selection pressure with solution transformation, but instead of relying on traditional local search operators or node reordering, it employs a novel \"objective-aware segment inversion\" strategy that dynamically inverts segments of the tour based on their relative contributions to each objective. The algorithm first selects a solution from the archive using a multi-objective fitness metric that balances objective values with structural diversity, then applies a probabilistic segment inversion where segments are flipped with a bias toward those that show the greatest potential for improvement in either objective, while maintaining feasibility through careful boundary handling and validation. This approach ensures both targeted exploitation of objective-specific improvements and controlled exploration of the solution space, creating a more diverse set of high-quality neighbors compared to traditional methods.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on a multi-objective fitness metric\n    def compute_fitness(solution, objective):\n        # Normalize objectives\n        max_obj1 = max(obj[0] for _, obj in archive)\n        max_obj2 = max(obj[1] for _, obj in archive)\n        norm_obj1 = objective[0] / max_obj1 if max_obj1 != 0 else 0\n        norm_obj2 = objective[1] / max_obj2 if max_obj2 != 0 else 0\n\n        # Compute segment diversity\n        n = len(solution)\n        segments = []\n        for i in range(n):\n            u = solution[i]\n            v = solution[(i + 1) % n]\n            segments.append((min(u, v), max(u, v)))\n        segment_diversity = len(set(segments))\n\n        # Fitness score: balance between objectives and segment diversity\n        fitness = 0.5 * (norm_obj1 + norm_obj2) + 0.5 * (1 / segment_diversity if segment_diversity > 0 else 0)\n        return fitness\n\n    # Evaluate all solutions in the archive and select the best\n    best_solution = None\n    best_fitness = float('-inf')\n    for solution, objective in archive:\n        fitness = compute_fitness(solution, objective)\n        if fitness > best_fitness:\n            best_fitness = fitness\n            best_solution = solution.copy()\n\n    if best_solution is None:\n        best_solution = archive[0][0].copy()\n\n    new_solution = best_solution.copy()\n\n    # Apply objective-aware segment inversion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Compute current costs\n    def compute_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(len(solution)):\n            u = solution[i]\n            v = solution[(i + 1) % len(solution)]\n            cost += distance_matrix[u, v]\n        return cost\n\n    original_cost1 = compute_cost(best_solution, distance_matrix_1)\n    original_cost2 = compute_cost(best_solution, distance_matrix_2)\n\n    # Select a random segment to potentially invert\n    segment_length = np.random.randint(2, min(5, n//2))\n    start_pos = np.random.randint(0, n - segment_length)\n    end_pos = start_pos + segment_length\n\n    # Create a temporary inverted solution\n    temp_solution = new_solution.copy()\n    temp_solution[start_pos:end_pos] = temp_solution[start_pos:end_pos][::-1]\n\n    # Compute new costs\n    new_cost1 = compute_cost(temp_solution, distance_matrix_1)\n    new_cost2 = compute_cost(temp_solution, distance_matrix_2)\n\n    # Compute cost differences\n    cost_diff1 = new_cost1 - original_cost1\n    cost_diff2 = new_cost2 - original_cost2\n\n    # Accept inversion if it improves either objective or with a probability\n    if (cost_diff1 < 0 or cost_diff2 < 0) or np.random.random() < 0.2:\n        new_solution = temp_solution\n\n    # Additional diversification: with small probability, perform a random swap\n    if np.random.random() < 0.1:\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.974212227430837,
               3.875964939594269
          ]
     },
     {
          "algorithm": "{The common backbone idea in the provided algorithms is the selection of promising solutions from an archive based on their objective values and application of hybrid local search operators to generate improved neighbors while ensuring feasibility. The new algorithm will first identify solutions with high potential for improvement by analyzing their objective values and diversity, then apply a novel 'multi-segment inversion and edge reassignment' strategy that randomly selects multiple non-overlapping segments of the tour, reverses each segment, and then optimally reassigns edges between segments to improve both objectives, all while maintaining feasibility by ensuring no nodes are skipped or revisited.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate potential improvement score (combination of objective values and diversity)\n        improvement_score = (obj[0] + obj[1]) / (1 + np.var(obj))\n        candidates.append((sol, improvement_score))\n\n    candidates.sort(key=lambda x: -x[1])\n    selected = candidates[0][0].copy()\n\n    # Step 2: Apply multi-segment inversion and edge reassignment\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Generate multiple non-overlapping segments\n    segments = []\n    remaining = list(range(n))\n    while len(remaining) > 1:\n        # Randomly select segment length\n        seg_length = random.randint(2, min(5, len(remaining)))\n        # Randomly select starting point\n        start_idx = random.choice(remaining)\n        start_pos = remaining.index(start_idx)\n        # Get segment indices\n        seg_indices = remaining[start_pos:start_pos+seg_length]\n        segments.append(seg_indices)\n        # Remove segment from remaining\n        remaining = [x for x in remaining if x not in seg_indices]\n\n    # Reverse each segment\n    for seg in segments:\n        if len(seg) > 1:\n            new_solution[seg] = new_solution[seg][::-1]\n\n    # Optimally reassign edges between segments\n    for i in range(len(segments)-1):\n        seg1 = segments[i]\n        seg2 = segments[i+1]\n\n        # Find best edge to connect segments\n        best_improvement = 0\n        best_edge = None\n\n        # Try all possible connections between segments\n        for a in seg1:\n            for b in seg2:\n                # Current edges\n                prev_a = new_solution[a-1] if a > 0 else new_solution[-1]\n                next_a = new_solution[(a+1)%n]\n                prev_b = new_solution[b-1] if b > 0 else new_solution[-1]\n                next_b = new_solution[(b+1)%n]\n\n                # Current costs\n                current_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                                distance_matrix_1[new_solution[a], next_a] +\n                                distance_matrix_1[prev_b, new_solution[b]] +\n                                distance_matrix_1[new_solution[b], next_b])\n                current_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                                distance_matrix_2[new_solution[a], next_a] +\n                                distance_matrix_2[prev_b, new_solution[b]] +\n                                distance_matrix_2[new_solution[b], next_b])\n\n                # New costs if we connect a to b\n                new_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                            distance_matrix_1[new_solution[a], new_solution[b]] +\n                            distance_matrix_1[new_solution[b], next_a] +\n                            distance_matrix_1[prev_b, new_solution[b]] +\n                            distance_matrix_1[new_solution[b], next_b])\n                new_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                            distance_matrix_2[new_solution[a], new_solution[b]] +\n                            distance_matrix_2[new_solution[b], next_a] +\n                            distance_matrix_2[prev_b, new_solution[b]] +\n                            distance_matrix_2[new_solution[b], next_b])\n\n                improvement = (current_cost1 + current_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_edge = (a, b)\n\n        # Apply the best edge connection\n        if best_edge:\n            a, b = best_edge\n            # Reorder the solution to connect a to b\n            a_pos = np.where(new_solution == a)[0][0]\n            b_pos = np.where(new_solution == b)[0][0]\n\n            if a_pos > b_pos:\n                a_pos, b_pos = b_pos, a_pos\n\n            # Reorder the segment between a and b\n            new_solution[a_pos+1:b_pos] = new_solution[a_pos+1:b_pos][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
          "score": [
               -0.955673343787872,
               1.648804247379303
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the current best)\n    selected = None\n    max_gap = -1\n    for sol, obj in archive:\n        gap = abs(obj[0] - obj[1])  # Measure the diversity of objectives\n        if gap > max_gap:\n            max_gap = gap\n            selected = sol\n\n    if selected is None:\n        selected = archive[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Select a random segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Find the best position to insert the reversed segment\n    best_pos = -1\n    best_cost = float('inf')\n\n    for pos in range(n):\n        if pos >= a and pos < b:\n            continue  # Skip positions within the original segment\n\n        # Create a candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment[::-1],\n            new_solution[pos:],\n            new_solution[a:b]\n        ])\n\n        # Calculate the cost\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(-1, n-1))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(-1, n-1))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment[::-1],\n            new_solution[best_pos:],\n            new_solution[a:b]\n        ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If the solution is invalid, revert to the original\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8996560143835762,
               0.345630943775177
          ]
     }
]