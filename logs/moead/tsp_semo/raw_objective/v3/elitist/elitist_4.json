[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.765381223706096,
            6.829708949278469
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.765381223706096,
            6.829708949278469
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of its objectives, then applies a novel local search operator that combines segment reversal with biased insertion of nodes from a randomly chosen segment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and a position to insert it\n    start, end = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[start:end]\n\n    # Reverse the segment with probability 0.7\n    if np.random.rand() < 0.7:\n        segment = segment[::-1]\n\n    # Remove the original segment\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Randomly select a new insertion point\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n\n    # Insert the modified segment\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n",
        "score": [
            5.31705703469663,
            7.117861950740304
        ]
    },
    {
        "algorithm": "{A novel algorithm that selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 4-opt with a biased segment reversal strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: 4-opt with biased segment reversal\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    segment4 = new_solution[d:]\n\n    # Reconnect segments with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment3, segment2, segment4])\n    else:\n        new_order = np.concatenate([segment1, segment4, segment3[::-1], segment2[::-1]])\n\n    # Ensure solution remains valid\n    if len(np.unique(new_order)) == n:\n        new_solution[a:d] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.113311059141555,
            8.138167066786565
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 4-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select four edges to modify\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    segment4 = new_solution[d:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3, segment4[::-1]])\n    else:\n        new_order = np.concatenate([segment1, segment4, segment3[::-1], segment2])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:d] = new_order\n    else:\n        # Fallback to reversing a random segment if the above fails\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.954977864677905,
            5.913752711816938
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines segment reversal with biased random insertion of nodes to escape local optima while maintaining solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment and reverse it\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b]\n    new_solution[a:b] = segment[::-1]\n\n    # Randomly insert a node from another part of the tour\n    if np.random.rand() < 0.7:\n        c = np.random.choice(range(n))\n        node = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        insert_pos = np.random.choice(range(n-1))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.279319690477692,
            5.831770185517046
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    # Apply a novel local search operator: \"Biased Segment Reversal with Objective-Aware Insertion\"\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[a:b]\n\n    # Reverse the segment with a bias towards reducing the higher-cost objective\n    if np.random.rand() < 0.7:  # Higher probability to reverse\n        new_solution[a:b] = segment[::-1]\n\n    # Objective-aware insertion: find the best insertion point for the reversed segment\n    if np.random.rand() < 0.5:  # Apply insertion with 50% probability\n        best_pos = a\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos >= a and pos < b:\n                continue  # Skip the original segment position\n\n            # Temporarily insert the reversed segment\n            temp_solution = np.concatenate([new_solution[:pos], segment[::-1], new_solution[pos:]])\n            temp_solution = np.delete(temp_solution, range(pos, pos + len(segment)))\n\n            # Calculate the cost in both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Prefer solutions that reduce the higher-cost objective\n            total_cost = max(cost1, cost2)\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_pos], segment[::-1], new_solution[best_pos:]])\n        new_solution = np.delete(new_solution, range(best_pos, best_pos + len(segment)))\n\n    return new_solution\n\n",
        "score": [
            9.405815450473165,
            5.521342826652818
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution with high potential for improvement by considering both objective costs and applies a novel \"segmented inversion with objective-aware insertion\" operator that reverses segments and strategically reinserts them based on the combined cost reduction in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse and reinsert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b]\n    remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    # Evaluate potential insertion points based on combined cost reduction\n    best_insertion = None\n    min_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Try inserting the reversed segment at position i\n        candidate = np.concatenate([remaining[:i], segment[::-1], remaining[i:]])\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insertion = candidate\n\n    if best_insertion is not None:\n        new_solution = best_insertion\n    else:\n        # Fallback to random swap if no improvement found\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.524100728355354,
            6.100611625385507
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] if x[1][0] != 0 and x[1][1] != 0 else 1))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select four nodes to modify\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n\n    # Apply a 4-opt-like local search with biased random selection\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    segment4 = new_solution[d:]\n\n    # Reconnect the segments in a new order with bias towards reducing both objectives\n    if np.random.rand() < 0.7:\n        new_order = np.concatenate([segment1, segment3[::-1], segment2, segment4[::-1]])\n    else:\n        new_order = np.concatenate([segment1[::-1], segment2, segment4, segment3[::-1]])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_order)) == n:\n        new_solution[a:d] = new_order\n    else:\n        # Fallback to reversing a random segment if the above fails\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.5506636902122635,
            5.645563490204664
        ]
    }
]