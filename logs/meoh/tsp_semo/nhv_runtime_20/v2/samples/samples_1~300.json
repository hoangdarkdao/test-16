[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7408560644247593,
            0.243660569190979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7408560644247593,
            0.243660569190979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7408560644247593,
            0.243660569190979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7807776801797127,
            0.4909664988517761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{This algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7807776801797127,
            0.4909664988517761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a hybrid local search operator that combines 3-opt with a novel segment inversion and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion and reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Try segment inversion\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Try segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8588519433664235,
            0.22379541397094727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion and reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Try segment inversion\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Try segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a hybrid local search operator that combines 3-opt with a novel segment inversion and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion and reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Try segment inversion\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Try segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8588519433664235,
            0.22379541397094727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion and reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Try segment inversion\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Try segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a hybrid local search operator that combines 3-opt with a novel segment inversion and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion and reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Try segment inversion\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Try segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8588519433664235,
            0.22379541397094727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion and reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Try segment inversion\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Try segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines edge swaps and node insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    if n > 3:\n        # Randomly choose between edge swap or node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7895037245011808,
            0.217376708984375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    if n > 3:\n        # Randomly choose between edge swap or node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines edge swaps and node insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    if n > 3:\n        # Randomly choose between edge swap or node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7895037245011808,
            0.217376708984375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    if n > 3:\n        # Randomly choose between edge swap or node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search: Combine node swapping with a dynamic segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    segment_length = np.random.randint(2, min(5, n))\n    start_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment in a new random position\n    insert_pos = np.random.randint(0, n - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Dynamic node swapping: Swap nodes based on their distance in both objective spaces\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if the swap doesn't improve both objectives\n        if (cost1_after >= cost1_before) and (cost2_after >= cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8047933069582259,
            0.22342205047607422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search: Combine node swapping with a dynamic segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    segment_length = np.random.randint(2, min(5, n))\n    start_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment in a new random position\n    insert_pos = np.random.randint(0, n - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Dynamic node swapping: Swap nodes based on their distance in both objective spaces\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if the swap doesn't improve both objectives\n        if (cost1_after >= cost1_before) and (cost2_after >= cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node chain inversion\" with a \"multi-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion + multi-segment rotation\n    if n > 5:\n        # Node chain inversion: Select a random chain of 3-5 nodes and invert them\n        chain_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n        new_solution[start:start+chain_length] = chain[::-1]\n\n        # Multi-segment rotation: Select 2-3 segments and rotate them\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = np.roll(segment, np.random.randint(1, length))\n\n    return new_solution\n\n",
        "score": [
            -0.8931201048817249,
            0.2385823130607605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion + multi-segment rotation\n    if n > 5:\n        # Node chain inversion: Select a random chain of 3-5 nodes and invert them\n        chain_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n        new_solution[start:start+chain_length] = chain[::-1]\n\n        # Multi-segment rotation: Select 2-3 segments and rotate them\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = np.roll(segment, np.random.randint(1, length))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node chain inversion\" with a \"multi-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion + multi-segment rotation\n    if n > 5:\n        # Node chain inversion: Select a random chain of 3-5 nodes and invert them\n        chain_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n        new_solution[start:start+chain_length] = chain[::-1]\n\n        # Multi-segment rotation: Select 2-3 segments and rotate them\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = np.roll(segment, np.random.randint(1, length))\n\n    return new_solution\n\n",
        "score": [
            -0.8931201048817249,
            0.2385823130607605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion + multi-segment rotation\n    if n > 5:\n        # Node chain inversion: Select a random chain of 3-5 nodes and invert them\n        chain_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n        new_solution[start:start+chain_length] = chain[::-1]\n\n        # Multi-segment rotation: Select 2-3 segments and rotate them\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = np.roll(segment, np.random.randint(1, length))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment relocation and inversion strategy\n    if n > 3:\n        # Select a random segment\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j]\n\n        # Remove the segment and store it\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n\n        # Invert the segment\n        segment = segment[::-1]\n\n        # Find the best position to reinsert the segment\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(remaining)):\n            # Insert segment at position pos\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n            # Calculate total cost in both objectives\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n\n            if cost1 + cost2 < min_cost:\n                min_cost = cost1 + cost2\n                best_pos = pos\n\n        # Reinsert the segment at the best position\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8435315910137725,
            0.5050657391548157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment relocation and inversion strategy\n    if n > 3:\n        # Select a random segment\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        segment = new_solution[i:j]\n\n        # Remove the segment and store it\n        remaining = np.concatenate([new_solution[:i], new_solution[j:]])\n\n        # Invert the segment\n        segment = segment[::-1]\n\n        # Find the best position to reinsert the segment\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(remaining)):\n            # Insert segment at position pos\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n            # Calculate total cost in both objectives\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n\n            if cost1 + cost2 < min_cost:\n                min_cost = cost1 + cost2\n                best_pos = pos\n\n        # Reinsert the segment at the best position\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined quality-diversity metric, then applies a hybrid local search combining segment relocation and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined quality-diversity trade-off\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        quality = obj[0] + obj[1]\n        diversity = np.sum(sol != archive[0][0])\n        score = quality * (1 + 0.1 * diversity)  # Balance quality and diversity\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation + edge swapping\n    if n >= 4:\n        # Randomly select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution)+1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Randomly swap two non-adjacent edges\n        if n >= 4:\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.893841244784518,
            0.46345454454421997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined quality-diversity trade-off\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        quality = obj[0] + obj[1]\n        diversity = np.sum(sol != archive[0][0])\n        score = quality * (1 + 0.1 * diversity)  # Balance quality and diversity\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation + edge swapping\n    if n >= 4:\n        # Randomly select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution)+1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Randomly swap two non-adjacent edges\n        if n >= 4:\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined quality-diversity metric, then applies a hybrid local search combining segment relocation and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined quality-diversity trade-off\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        quality = obj[0] + obj[1]\n        diversity = np.sum(sol != archive[0][0])\n        score = quality * (1 + 0.1 * diversity)  # Balance quality and diversity\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation + edge swapping\n    if n >= 4:\n        # Randomly select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution)+1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Randomly swap two non-adjacent edges\n        if n >= 4:\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.893841244784518,
            0.46345454454421997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined quality-diversity trade-off\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        quality = obj[0] + obj[1]\n        diversity = np.sum(sol != archive[0][0])\n        score = quality * (1 + 0.1 * diversity)  # Balance quality and diversity\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation + edge swapping\n    if n >= 4:\n        # Randomly select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution)+1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Randomly swap two non-adjacent edges\n        if n >= 4:\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{The new algorithm combines a novel segment relocation strategy with a multi-objective-aware segment inversion, where segments are relocated based on their potential to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment relocation: Move a segment to a position that improves both objectives\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        best_pos = i\n        min_cost = float('inf')\n\n        # Evaluate potential positions for the segment\n        for pos in range(n - (j - i) + 1):\n            if pos == i:\n                continue\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Multi-objective-aware segment inversion: Invert a segment if it improves both objectives\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if (cost1 < current_cost1 and cost2 < current_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8362971610778605,
            0.428544819355011
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment relocation: Move a segment to a position that improves both objectives\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        best_pos = i\n        min_cost = float('inf')\n\n        # Evaluate potential positions for the segment\n        for pos in range(n - (j - i) + 1):\n            if pos == i:\n                continue\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Multi-objective-aware segment inversion: Invert a segment if it improves both objectives\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if (cost1 < current_cost1 and cost2 < current_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This algorithm selects a solution with balanced objective improvement potential, then applies a novel hybrid local search combining adaptive segment swapping and objective-aware edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective improvement potential\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(archive_sorted))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Adaptive segment swapping\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Objective-aware edge flipping\n    for i in range(1, n-1):\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8612328424689331,
            0.30258631706237793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective improvement potential\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(archive_sorted))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Adaptive segment swapping\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Objective-aware edge flipping\n    for i in range(1, n-1):\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined improvement potential in both objectives, then applies a novel segment rotation and edge swap operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_solution = archive[0][0].copy()\n    max_potential = -float('inf')\n    for sol, (cost1, cost2) in archive:\n        potential = -cost1 - cost2  # Higher negative costs indicate better potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment rotation operation\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7222753164251589,
            0.19529563188552856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_solution = archive[0][0].copy()\n    max_potential = -float('inf')\n    for sol, (cost1, cost2) in archive:\n        potential = -cost1 - cost2  # Higher negative costs indicate better potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment rotation operation\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined improvement potential in both objectives, then applies a novel segment rotation and edge swap operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_solution = archive[0][0].copy()\n    max_potential = -float('inf')\n    for sol, (cost1, cost2) in archive:\n        potential = -cost1 - cost2  # Higher negative costs indicate better potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment rotation operation\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7222753164251589,
            0.19529563188552856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_solution = archive[0][0].copy()\n    max_potential = -float('inf')\n    for sol, (cost1, cost2) in archive:\n        potential = -cost1 - cost2  # Higher negative costs indicate better potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment rotation operation\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A new hybrid local search algorithm that combines a novel segment relocation with a dynamic inversion strategy to explore diverse neighborhoods while ensuring feasibility, by first selecting a promising solution from the archive and then applying a combination of segment operations and dynamic inversions to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment relocation: Move a segment to a new position\n    if n > 4:\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Dynamic inversion: Invert segments based on distance matrices\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        # Decide inversion based on distance matrices\n        cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        if cost_after < cost_before:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8578526905831331,
            0.2900117039680481
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment relocation: Move a segment to a new position\n    if n > 4:\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Dynamic inversion: Invert segments based on distance matrices\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        # Decide inversion based on distance matrices\n        cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        if cost_after < cost_before:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A novel hybrid local search algorithm that combines a multi-segment shuffle with a distance-aware segment inversion to explore diverse neighborhoods while maintaining feasibility by ensuring no nodes are skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (top 30% in combined objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment shuffle: Randomly select and shuffle 4 distinct segments\n    if n > 4:\n        segments = sorted(np.random.choice(range(1, n-1), 4, replace=False))\n        segments = [0] + segments + [n]\n        segment_indices = list(range(len(segments)-1))\n        np.random.shuffle(segment_indices)\n        shuffled_segments = []\n        for i in segment_indices:\n            start, end = segments[i], segments[i+1]\n            shuffled_segments.append(new_solution[start:end])\n        new_solution = np.concatenate(shuffled_segments)\n\n    # Distance-aware segment inversion: Invert a segment based on high-distance nodes\n    if n > 4:\n        # Find the segment with the highest total distance in either objective space\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(1, n-2):\n            for j in range(i+1, n-1):\n                total_dist = 0\n                for k in range(i, j):\n                    total_dist += distance_matrix_1[new_solution[k], new_solution[k+1]]\n                    total_dist += distance_matrix_2[new_solution[k], new_solution[k+1]]\n                if total_dist > max_dist:\n                    max_dist = total_dist\n                    best_i, best_j = i, j\n        # Invert the selected segment\n        if best_i < best_j:\n            new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8281017419290546,
            1.116881787776947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (top 30% in combined objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment shuffle: Randomly select and shuffle 4 distinct segments\n    if n > 4:\n        segments = sorted(np.random.choice(range(1, n-1), 4, replace=False))\n        segments = [0] + segments + [n]\n        segment_indices = list(range(len(segments)-1))\n        np.random.shuffle(segment_indices)\n        shuffled_segments = []\n        for i in segment_indices:\n            start, end = segments[i], segments[i+1]\n            shuffled_segments.append(new_solution[start:end])\n        new_solution = np.concatenate(shuffled_segments)\n\n    # Distance-aware segment inversion: Invert a segment based on high-distance nodes\n    if n > 4:\n        # Find the segment with the highest total distance in either objective space\n        max_dist = -1\n        best_i, best_j = 0, 0\n        for i in range(1, n-2):\n            for j in range(i+1, n-1):\n                total_dist = 0\n                for k in range(i, j):\n                    total_dist += distance_matrix_1[new_solution[k], new_solution[k+1]]\n                    total_dist += distance_matrix_2[new_solution[k], new_solution[k+1]]\n                if total_dist > max_dist:\n                    max_dist = total_dist\n                    best_i, best_j = i, j\n        # Invert the selected segment\n        if best_i < best_j:\n            new_solution[best_i:best_j] = new_solution[best_i:best_j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{This algorithm selects a solution with the best trade-off between the two objectives using a Pareto-dominance aware metric, then applies a segment-based local search combining edge rotation and segment inversion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives (using Pareto-dominance)\n    selected_solution = archive[0][0].copy()\n    best_score = float('inf')\n\n    for sol, obj in archive:\n        # Score based on normalized objective values\n        norm_obj1 = obj[0] / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj[1] / (distance_matrix_2.max() * len(sol))\n        score = norm_obj1 + norm_obj2\n\n        if score < best_score:\n            best_score = score\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment-based local search with edge rotation and inversion\n    # Randomly select a segment and rotate it\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = segment\n\n    # Randomly invert another segment\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9391051457395756,
            0.26499444246292114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives (using Pareto-dominance)\n    selected_solution = archive[0][0].copy()\n    best_score = float('inf')\n\n    for sol, obj in archive:\n        # Score based on normalized objective values\n        norm_obj1 = obj[0] / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj[1] / (distance_matrix_2.max() * len(sol))\n        score = norm_obj1 + norm_obj2\n\n        if score < best_score:\n            best_score = score\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment-based local search with edge rotation and inversion\n    # Randomly select a segment and rotate it\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = segment\n\n    # Randomly invert another segment\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a promising solution from the archive based on a diversity-aware metric, then applies a hybrid local search combining edge insertion and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from the first solution in the archive)\n    selected_solution = archive[0][0].copy()\n    max_diversity = -1\n    for sol, _ in archive:\n        diversity = np.sum(sol != selected_solution)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: edge insertion + segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    edge = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [edge], new_solution[j+1:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{This algorithm selects a solution with the best trade-off between the two objectives using a Pareto-dominance aware metric, then applies a segment-based local search combining edge rotation and segment inversion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives (using Pareto-dominance)\n    selected_solution = archive[0][0].copy()\n    best_score = float('inf')\n\n    for sol, obj in archive:\n        # Score based on normalized objective values\n        norm_obj1 = obj[0] / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj[1] / (distance_matrix_2.max() * len(sol))\n        score = norm_obj1 + norm_obj2\n\n        if score < best_score:\n            best_score = score\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment-based local search with edge rotation and inversion\n    # Randomly select a segment and rotate it\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = segment\n\n    # Randomly invert another segment\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9391051457395756,
            0.26499444246292114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives (using Pareto-dominance)\n    selected_solution = archive[0][0].copy()\n    best_score = float('inf')\n\n    for sol, obj in archive:\n        # Score based on normalized objective values\n        norm_obj1 = obj[0] / (distance_matrix_1.max() * len(sol))\n        norm_obj2 = obj[1] / (distance_matrix_2.max() * len(sol))\n        score = norm_obj1 + norm_obj2\n\n        if score < best_score:\n            best_score = score\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment-based local search with edge rotation and inversion\n    # Randomly select a segment and rotate it\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = segment\n\n    # Randomly invert another segment\n    c, d = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel heuristic that combines adaptive segment selection with a multi-objective-aware inversion operator to explore diverse neighborhoods while balancing exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on adaptive objective balance\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment selection\n    if n > 3:\n        # Select segments based on both distance matrices\n        segment_length = max(2, n // 4)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Calculate segment cost in both objectives\n        cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        total_cost = cost1 + cost2\n\n        # Decide whether to invert based on multi-objective balance\n        if total_cost > np.mean([x[1][0] + x[1][1] for x in archive]):\n            # Invert segment with probabilistic bias towards better objective\n            if np.random.random() < 0.7:  # Higher probability for better segments\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Additional adaptive perturbation\n    if n > 4 and np.random.random() < 0.3:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        if np.random.random() < 0.5:\n            segment = segment[::-1]\n        else:\n            np.random.shuffle(segment)\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8627941421469847,
            0.9591155052185059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on adaptive objective balance\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective aware segment selection\n    if n > 3:\n        # Select segments based on both distance matrices\n        segment_length = max(2, n // 4)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Calculate segment cost in both objectives\n        cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        total_cost = cost1 + cost2\n\n        # Decide whether to invert based on multi-objective balance\n        if total_cost > np.mean([x[1][0] + x[1][1] for x in archive]):\n            # Invert segment with probabilistic bias towards better objective\n            if np.random.random() < 0.7:  # Higher probability for better segments\n                new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Additional adaptive perturbation\n    if n > 4 and np.random.random() < 0.3:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        if np.random.random() < 0.5:\n            segment = segment[::-1]\n        else:\n            np.random.shuffle(segment)\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a hybrid local search operator that combines 3-opt with a novel segment inversion and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion and reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Try segment inversion\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Try segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The algorithm prioritizes solutions with the highest potential for improvement by using a score function that combines objective values and diversity metrics, then applies a hybrid local search operator that combines 4-opt with a novel segment rotation and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score function: prioritize solutions with highest objective values and diversity\n    def score(solution, objective):\n        cost1, cost2 = objective\n        diversity = np.sum(np.abs(np.diff(solution)))\n        return (cost1 + cost2) * diversity\n\n    scored_solutions = [(score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 4-opt with segment rotation and reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    if random.random() < 0.5:\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    else:\n        # Segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:d+1], segment, new_solution[d+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9511032336705769,
            0.8404332399368286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score function: prioritize solutions with highest objective values and diversity\n    def score(solution, objective):\n        cost1, cost2 = objective\n        diversity = np.sum(np.abs(np.diff(solution)))\n        return (cost1 + cost2) * diversity\n\n    scored_solutions = [(score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 4-opt with segment rotation and reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    if random.random() < 0.5:\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    else:\n        # Segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:d+1], segment, new_solution[d+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a hybrid local search operator that combines 3-opt with a novel segment inversion and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion and reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Try segment inversion\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Try segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{The algorithm prioritizes solutions with the highest potential for improvement by using a score function that combines objective values and diversity metrics, then applies a hybrid local search operator that combines 4-opt with a novel segment rotation and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score function: prioritize solutions with highest objective values and diversity\n    def score(solution, objective):\n        cost1, cost2 = objective\n        diversity = np.sum(np.abs(np.diff(solution)))\n        return (cost1 + cost2) * diversity\n\n    scored_solutions = [(score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 4-opt with segment rotation and reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    if random.random() < 0.5:\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    else:\n        # Segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:d+1], segment, new_solution[d+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9511032336705769,
            0.8404332399368286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score function: prioritize solutions with highest objective values and diversity\n    def score(solution, objective):\n        cost1, cost2 = objective\n        diversity = np.sum(np.abs(np.diff(solution)))\n        return (cost1 + cost2) * diversity\n\n    scored_solutions = [(score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 4-opt with segment rotation and reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    if random.random() < 0.5:\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    else:\n        # Segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:d+1], segment, new_solution[d+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined improvement potential in both objectives, then applies a novel segment rotation and edge swap operation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_solution = archive[0][0].copy()\n    max_potential = -float('inf')\n    for sol, (cost1, cost2) in archive:\n        potential = -cost1 - cost2  # Higher negative costs indicate better potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment rotation operation\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on the highest combined improvement potential in both objectives, then applies a novel segment rotation and edge swap operation to generate a neighbor solution while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_solution = archive[0][0].copy()\n    max_potential = -float('inf')\n    for sol, (cost1, cost2) in archive:\n        potential = -cost1 - cost2  # Higher negative costs indicate better potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment rotation operation\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This algorithm selects a solution from the archive based on the highest improvement potential in either objective, then applies a novel hybrid 3-opt and node reinsertion operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest improvement potential in either objective\n    selected_solution = archive[0][0].copy()\n    max_potential = -float('inf')\n    for sol, (cost1, cost2) in archive:\n        potential = max(-cost1, -cost2)  # Higher negative cost indicates better potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid 3-opt operation\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_segment = np.concatenate([segment1, segment2[::-1]])\n    new_solution[a:c+1] = new_segment\n\n    # Node reinsertion operation\n    i = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    j = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5966788079232805,
            0.24443000555038452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest improvement potential in either objective\n    selected_solution = archive[0][0].copy()\n    max_potential = -float('inf')\n    for sol, (cost1, cost2) in archive:\n        potential = max(-cost1, -cost2)  # Higher negative cost indicates better potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid 3-opt operation\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b+1:c+1]\n    new_segment = np.concatenate([segment1, segment2[::-1]])\n    new_solution[a:c+1] = new_segment\n\n    # Node reinsertion operation\n    i = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    j = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution with balanced objective improvement potential, then applies a novel hybrid local search combining adaptive segment swapping and objective-aware edge flipping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective improvement potential\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(archive_sorted))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Adaptive segment swapping\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Objective-aware edge flipping\n    for i in range(1, n-1):\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This new algorithm selects the best solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining segment inversion and adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select best solution\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Adaptive edge swapping\n    for i in range(1, n-2):\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i]]\n\n        if (cost1_after < cost1_before or cost2_after < cost2_before) and (np.random.random() < 0.3):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8259321254217014,
            0.28143310546875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select best solution\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Adaptive edge swapping\n    for i in range(1, n-2):\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i]]\n\n        if (cost1_after < cost1_before or cost2_after < cost2_before) and (np.random.random() < 0.3):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a novel combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node chain inversion\" with a \"multi-segment rotation\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion + multi-segment rotation\n    if n > 5:\n        # Node chain inversion: Select a random chain of 3-5 nodes and invert them\n        chain_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n        new_solution[start:start+chain_length] = chain[::-1]\n\n        # Multi-segment rotation: Select 2-3 segments and rotate them\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = np.roll(segment, np.random.randint(1, length))\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a hybrid local search combining \"node segment reversal\" with \"multi-segment shift\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objective values and solution quality\n    weighted_scores = [0.7 * (sol[1][0] + sol[1][1]) + 0.3 * (np.sum(distance_matrix_1[sol[0], np.roll(sol[0], -1)]) + np.sum(distance_matrix_2[sol[0], np.roll(sol[0], -1)])) for sol in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment reversal + multi-segment shift\n    if n > 6:\n        # Node segment reversal: Select a random segment of 4-6 nodes and reverse it\n        segment_length = np.random.randint(4, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Multi-segment shift: Select 2 segments and shift them by 1-2 positions\n        segment_starts = sorted(np.random.choice(range(1, n-2), 2, replace=False))\n        for start in segment_starts:\n            shift = np.random.randint(1, 3)\n            new_solution[start:start+2] = np.roll(new_solution[start:start+2], shift)\n\n    return new_solution\n\n",
        "score": [
            -0.6263125721959135,
            0.8682889938354492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objective values and solution quality\n    weighted_scores = [0.7 * (sol[1][0] + sol[1][1]) + 0.3 * (np.sum(distance_matrix_1[sol[0], np.roll(sol[0], -1)]) + np.sum(distance_matrix_2[sol[0], np.roll(sol[0], -1)])) for sol in archive]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment reversal + multi-segment shift\n    if n > 6:\n        # Node segment reversal: Select a random segment of 4-6 nodes and reverse it\n        segment_length = np.random.randint(4, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Multi-segment shift: Select 2 segments and shift them by 1-2 positions\n        segment_starts = sorted(np.random.choice(range(1, n-2), 2, replace=False))\n        for start in segment_starts:\n            shift = np.random.randint(1, 3)\n            new_solution[start:start+2] = np.roll(new_solution[start:start+2], shift)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a hybrid local search operator that combines 3-opt with a novel segment inversion and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion and reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Try segment inversion\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Try segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a hybrid local search operator that combines 3-opt with a novel segment inversion and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion and reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Try segment inversion\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Try segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9408094873441832,
            0.21406221389770508
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a novel combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node chain inversion\" with a \"multi-segment rotation\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion + multi-segment rotation\n    if n > 5:\n        # Node chain inversion: Select a random chain of 3-5 nodes and invert them\n        chain_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n        new_solution[start:start+chain_length] = chain[::-1]\n\n        # Multi-segment rotation: Select 2-3 segments and rotate them\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = np.roll(segment, np.random.randint(1, length))\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search: Combine node swapping with a dynamic segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    segment_length = np.random.randint(2, min(5, n))\n    start_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment in a new random position\n    insert_pos = np.random.randint(0, n - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Dynamic node swapping: Swap nodes based on their distance in both objective spaces\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if the swap doesn't improve both objectives\n        if (cost1_after >= cost1_before) and (cost2_after >= cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel \"multi-segment crossover\" local search that combines segments from different parts of the solution with a dynamic node reordering step to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover: Select 2-3 non-overlapping segments and swap them between different parts of the solution\n    if n > 5:\n        num_segments = np.random.randint(2, 4)\n        segment_positions = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        # Extract segments\n        segments = []\n        for i in range(num_segments):\n            start = segment_positions[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segments.append(new_solution[start:start+length])\n\n        # Swap segments between different parts of the solution\n        if len(segments) >= 2:\n            for i in range(len(segments)):\n                target_pos = np.random.randint(0, n - len(segments[(i+1)%len(segments)]) + 1)\n                segment = segments[(i+1)%len(segments)]\n                new_solution = np.concatenate([\n                    new_solution[:target_pos],\n                    segment,\n                    new_solution[target_pos + len(segment):]\n                ])\n\n        # Dynamic node reordering: Reorder nodes in each segment based on their distance in both objective spaces\n        for i in range(num_segments):\n            start = segment_positions[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                # Sort segment nodes based on their average distance to adjacent nodes in both spaces\n                segment_order = sorted(range(len(segment)), key=lambda x: (\n                    (distance_matrix_1[segment[x-1], segment[x]] + distance_matrix_1[segment[x], segment[(x+1)%len(segment)]]) / 2 +\n                    (distance_matrix_2[segment[x-1], segment[x]] + distance_matrix_2[segment[x], segment[(x+1)%len(segment)]]) / 2\n                ))\n                new_solution[start:start+length] = segment[segment_order]\n\n    return new_solution\n\n",
        "score": [
            -0.8961761055146749,
            0.2633103132247925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover: Select 2-3 non-overlapping segments and swap them between different parts of the solution\n    if n > 5:\n        num_segments = np.random.randint(2, 4)\n        segment_positions = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        # Extract segments\n        segments = []\n        for i in range(num_segments):\n            start = segment_positions[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segments.append(new_solution[start:start+length])\n\n        # Swap segments between different parts of the solution\n        if len(segments) >= 2:\n            for i in range(len(segments)):\n                target_pos = np.random.randint(0, n - len(segments[(i+1)%len(segments)]) + 1)\n                segment = segments[(i+1)%len(segments)]\n                new_solution = np.concatenate([\n                    new_solution[:target_pos],\n                    segment,\n                    new_solution[target_pos + len(segment):]\n                ])\n\n        # Dynamic node reordering: Reorder nodes in each segment based on their distance in both objective spaces\n        for i in range(num_segments):\n            start = segment_positions[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                # Sort segment nodes based on their average distance to adjacent nodes in both spaces\n                segment_order = sorted(range(len(segment)), key=lambda x: (\n                    (distance_matrix_1[segment[x-1], segment[x]] + distance_matrix_1[segment[x], segment[(x+1)%len(segment)]]) / 2 +\n                    (distance_matrix_2[segment[x-1], segment[x]] + distance_matrix_2[segment[x], segment[(x+1)%len(segment)]]) / 2\n                ))\n                new_solution[start:start+length] = segment[segment_order]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search: Combine node swapping with a dynamic segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    segment_length = np.random.randint(2, min(5, n))\n    start_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment in a new random position\n    insert_pos = np.random.randint(0, n - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Dynamic node swapping: Swap nodes based on their distance in both objective spaces\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if the swap doesn't improve both objectives\n        if (cost1_after >= cost1_before) and (cost2_after >= cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined quality-diversity metric, then applies a hybrid local search combining segment relocation and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined quality-diversity trade-off\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        quality = obj[0] + obj[1]\n        diversity = np.sum(sol != archive[0][0])\n        score = quality * (1 + 0.1 * diversity)  # Balance quality and diversity\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation + edge swapping\n    if n >= 4:\n        # Randomly select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution)+1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Randomly swap two non-adjacent edges\n        if n >= 4:\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search: Combine node swapping with a dynamic segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    segment_length = np.random.randint(2, min(5, n))\n    start_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment in a new random position\n    insert_pos = np.random.randint(0, n - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Dynamic node swapping: Swap nodes based on their distance in both objective spaces\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if the swap doesn't improve both objectives\n        if (cost1_after >= cost1_before) and (cost2_after >= cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined quality-diversity metric, then applies a hybrid local search combining segment relocation and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined quality-diversity trade-off\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        quality = obj[0] + obj[1]\n        diversity = np.sum(sol != archive[0][0])\n        score = quality * (1 + 0.1 * diversity)  # Balance quality and diversity\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation + edge swapping\n    if n >= 4:\n        # Randomly select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution)+1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Randomly swap two non-adjacent edges\n        if n >= 4:\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined quality-diversity metric, then applies a hybrid local search combining segment relocation and edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined quality-diversity trade-off\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        quality = obj[0] + obj[1]\n        diversity = np.sum(sol != archive[0][0])\n        score = quality * (1 + 0.1 * diversity)  # Balance quality and diversity\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation + edge swapping\n    if n >= 4:\n        # Randomly select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution)+1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Randomly swap two non-adjacent edges\n        if n >= 4:\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search: Combine node swapping with a dynamic segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    segment_length = np.random.randint(2, min(5, n))\n    start_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment in a new random position\n    insert_pos = np.random.randint(0, n - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Dynamic node swapping: Swap nodes based on their distance in both objective spaces\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if the swap doesn't improve both objectives\n        if (cost1_after >= cost1_before) and (cost2_after >= cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This algorithm selects a solution from the archive using a novelty-based metric that combines both objectives and spatial distribution, then applies a hybrid local search that combines adaptive segment inversion and distance-aware node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best novelty metric (combining objectives and spatial distribution)\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        # Novelty metric: weighted combination of objectives and spatial distribution\n        obj_score = -(obj[0] * obj[1])  # Negative because we want to maximize this\n        spatial_score = 0\n        for j in range(len(sol)-1):\n            x1, y1, x2, y2 = instance[sol[j]]\n            nx1, ny1, nx2, ny2 = instance[sol[j+1]]\n            spatial_score += (x1 - nx1)**2 + (y1 - ny1)**2 + (x2 - nx2)**2 + (y2 - ny2)**2\n        score = obj_score + 0.5 * spatial_score\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion + distance-aware insertion\n    if n >= 4:\n        # Adaptive segment inversion\n        segment_size = min(n // 4, 5)\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution[start:start+segment_size] = segment[::-1]\n\n        # Distance-aware node insertion\n        if n >= 6:\n            # Find the most distant node in both spaces\n            max_dist_idx = 0\n            max_dist = -1\n            for i in range(n):\n                dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                total_dist = dist1 + dist2\n                if total_dist > max_dist:\n                    max_dist = total_dist\n                    max_dist_idx = i\n\n            # Remove and reinsert the most distant node\n            node = new_solution[max_dist_idx]\n            new_solution = np.concatenate([new_solution[:max_dist_idx], new_solution[max_dist_idx+1:]])\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7678598913168725,
            1.4393470287322998
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best novelty metric (combining objectives and spatial distribution)\n    selected_idx = 0\n    best_score = -float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        # Novelty metric: weighted combination of objectives and spatial distribution\n        obj_score = -(obj[0] * obj[1])  # Negative because we want to maximize this\n        spatial_score = 0\n        for j in range(len(sol)-1):\n            x1, y1, x2, y2 = instance[sol[j]]\n            nx1, ny1, nx2, ny2 = instance[sol[j+1]]\n            spatial_score += (x1 - nx1)**2 + (y1 - ny1)**2 + (x2 - nx2)**2 + (y2 - ny2)**2\n        score = obj_score + 0.5 * spatial_score\n        if score > best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: adaptive segment inversion + distance-aware insertion\n    if n >= 4:\n        # Adaptive segment inversion\n        segment_size = min(n // 4, 5)\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution[start:start+segment_size] = segment[::-1]\n\n        # Distance-aware node insertion\n        if n >= 6:\n            # Find the most distant node in both spaces\n            max_dist_idx = 0\n            max_dist = -1\n            for i in range(n):\n                dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                total_dist = dist1 + dist2\n                if total_dist > max_dist:\n                    max_dist = total_dist\n                    max_dist_idx = i\n\n            # Remove and reinsert the most distant node\n            node = new_solution[max_dist_idx]\n            new_solution = np.concatenate([new_solution[:max_dist_idx], new_solution[max_dist_idx+1:]])\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines edge swaps and node insertions to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    if n > 3:\n        # Randomly choose between edge swap or node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This algorithm selects a solution from the archive based on the maximum improvement potential in either objective space, then applies a novel segment reversal with adaptive length to create a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solution with the highest potential for improvement in either objective\n        archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n        selected_solution = archive_sorted[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with dynamic length\n    if n > 3:\n        segment_length = min(n // 2, max(2, random.randint(1, n // 3)))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7335958935357609,
            0.2639051079750061
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solution with the highest potential for improvement in either objective\n        archive_sorted = sorted(archive, key=lambda x: max(x[1]))\n        selected_solution = archive_sorted[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with dynamic length\n    if n > 3:\n        segment_length = min(n // 2, max(2, random.randint(1, n // 3)))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines edge swaps and node insertions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    if n > 3:\n        # Randomly choose between edge swap or node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm prioritizes solutions with the highest potential for improvement by using a score function that combines objective values and diversity metrics, then applies a hybrid local search operator that combines 4-opt with a novel segment rotation and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score function: prioritize solutions with highest objective values and diversity\n    def score(solution, objective):\n        cost1, cost2 = objective\n        diversity = np.sum(np.abs(np.diff(solution)))\n        return (cost1 + cost2) * diversity\n\n    scored_solutions = [(score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 4-opt with segment rotation and reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    if random.random() < 0.5:\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    else:\n        # Segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:d+1], segment, new_solution[d+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on its objective values and applies a hybrid local search operator that combines a novel segment inversion with a probabilistic node relocation strategy to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment inversion with probabilistic node relocation\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    if random.random() < 0.7:\n        # Segment inversion\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        # Probabilistic node relocation\n        for i in range(a, b+1):\n            if random.random() < 0.3:\n                j = random.randint(0, n-1)\n                if j < a or j > b:\n                    node = new_solution[i]\n                    new_solution = np.delete(new_solution, i)\n                    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7897431537219419,
            0.24744963645935059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with the best combined objective value\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hybrid local search: segment inversion with probabilistic node relocation\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    if random.random() < 0.7:\n        # Segment inversion\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        # Probabilistic node relocation\n        for i in range(a, b+1):\n            if random.random() < 0.3:\n                j = random.randint(0, n-1)\n                if j < a or j > b:\n                    node = new_solution[i]\n                    new_solution = np.delete(new_solution, i)\n                    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of normalized objective scores, then applies a novel local search strategy that combines adaptive segment rotation and edge inversion with probabilistic acceptance to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.roll(segment, rotation)\n\n    # Probabilistic edge inversion\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        prob = 1 / (1 + np.exp(-(cost1_change + cost2_change) / 10))\n        if np.random.random() < prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9486911193508105,
            0.2556688189506531
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.roll(segment, rotation)\n\n    # Probabilistic edge inversion\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        prob = 1 / (1 + np.exp(-(cost1_change + cost2_change) / 10))\n        if np.random.random() < prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search: Combine node swapping with a dynamic segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    segment_length = np.random.randint(2, min(5, n))\n    start_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment in a new random position\n    insert_pos = np.random.randint(0, n - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Dynamic node swapping: Swap nodes based on their distance in both objective spaces\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if the swap doesn't improve both objectives\n        if (cost1_after >= cost1_before) and (cost2_after >= cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (top 15% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: max(x[1][0], x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment reversal combined with dynamic node insertion\n    if n > 3:\n        # Select a segment to reverse\n        segment_length = np.random.randint(2, min(4, n//2))\n        start_pos = np.random.randint(0, n - segment_length)\n        segment = new_solution[start_pos:start_pos + segment_length][::-1]\n\n        # Temporarily remove the segment\n        temp_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n        # Calculate insertion positions and costs\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            # Insert segment at position pos and calculate total cost\n            candidate = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([temp_solution[:best_pos], segment, temp_solution[best_pos:]])\n\n        # Dynamic node insertion: Find the best node to insert elsewhere\n        if n > 4:\n            best_node = -1\n            best_gain = 0\n\n            for i in range(n):\n                node = new_solution[i]\n                # Remove node and find best insertion position\n                temp = np.array([x for x in new_solution if x != node])\n                for pos in range(n-1):\n                    candidate = np.concatenate([temp[:pos], [node], temp[pos:]])\n                    cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                    cost1_after = distance_matrix_1[candidate[pos-1], node] + distance_matrix_1[node, candidate[(pos+1)%(n-1)]]\n                    cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                    cost2_after = distance_matrix_2[candidate[pos-1], node] + distance_matrix_2[node, candidate[(pos+1)%(n-1)]]\n\n                    gain = (cost1_before - cost1_after) + (cost2_before - cost2_after)\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_node = i\n                        best_pos = pos\n\n            if best_node != -1 and best_gain > 0:\n                node = new_solution[best_node]\n                new_solution = np.array([x for x in new_solution if x != node])\n                new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.681860746712524,
            3.2354902029037476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (top 15% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: max(x[1][0], x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment reversal combined with dynamic node insertion\n    if n > 3:\n        # Select a segment to reverse\n        segment_length = np.random.randint(2, min(4, n//2))\n        start_pos = np.random.randint(0, n - segment_length)\n        segment = new_solution[start_pos:start_pos + segment_length][::-1]\n\n        # Temporarily remove the segment\n        temp_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n        # Calculate insertion positions and costs\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            # Insert segment at position pos and calculate total cost\n            candidate = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([temp_solution[:best_pos], segment, temp_solution[best_pos:]])\n\n        # Dynamic node insertion: Find the best node to insert elsewhere\n        if n > 4:\n            best_node = -1\n            best_gain = 0\n\n            for i in range(n):\n                node = new_solution[i]\n                # Remove node and find best insertion position\n                temp = np.array([x for x in new_solution if x != node])\n                for pos in range(n-1):\n                    candidate = np.concatenate([temp[:pos], [node], temp[pos:]])\n                    cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n                    cost1_after = distance_matrix_1[candidate[pos-1], node] + distance_matrix_1[node, candidate[(pos+1)%(n-1)]]\n                    cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                    cost2_after = distance_matrix_2[candidate[pos-1], node] + distance_matrix_2[node, candidate[(pos+1)%(n-1)]]\n\n                    gain = (cost1_before - cost1_after) + (cost2_before - cost2_after)\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_node = i\n                        best_pos = pos\n\n            if best_node != -1 and best_gain > 0:\n                node = new_solution[best_node]\n                new_solution = np.array([x for x in new_solution if x != node])\n                new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware metric, then applies a novel local search strategy that combines segment relocation with adaptive objective-aware swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity metric (max difference between objectives)\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment relocation with objective-aware selection\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Adaptive swapping based on objective improvement\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9037914779447663,
            0.29375189542770386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity metric (max difference between objectives)\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment relocation with objective-aware selection\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Adaptive swapping based on objective improvement\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9013681893931123,
            0.14917200803756714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9013681893931123,
            0.14917200803756714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm prioritizes solutions with the highest potential for improvement by using a score function that combines objective values and diversity metrics, then applies a hybrid local search operator that combines 4-opt with a novel segment rotation and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score function: prioritize solutions with highest objective values and diversity\n    def score(solution, objective):\n        cost1, cost2 = objective\n        diversity = np.sum(np.abs(np.diff(solution)))\n        return (cost1 + cost2) * diversity\n\n    scored_solutions = [(score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 4-opt with segment rotation and reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    if random.random() < 0.5:\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    else:\n        # Segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:d+1], segment, new_solution[d+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search strategy that combines adaptive segment insertion with a multi-objective edge swapping mechanism to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to identify Pareto front solutions\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    objectives = [obj for _, obj in archive]\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and dominates(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Multi-objective edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] +\n                        distance_matrix_1[temp_solution[j-1], temp_solution[j]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] +\n                        distance_matrix_2[temp_solution[j-1], temp_solution[j]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Apply swap if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9484562338684307,
            0.4640764594078064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to identify Pareto front solutions\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1]) and (a[0] < b[0] or a[1] < b[1])\n\n    objectives = [obj for _, obj in archive]\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and dominates(other_obj, obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n\n    # Multi-objective edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] +\n                        distance_matrix_1[temp_solution[j-1], temp_solution[j]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] +\n                        distance_matrix_2[temp_solution[j-1], temp_solution[j]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Apply swap if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines edge swaps and node insertions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    if n > 3:\n        # Randomly choose between edge swap or node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines edge swaps and node insertions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    if n > 3:\n        # Randomly choose between edge swap or node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement, then applies a novel local search strategy that combines segment reversal with targeted node repositioning to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly decide between segment reversal or targeted repositioning\n        if random.random() < 0.5:\n            # Segment reversal with objective-aware selection\n            # Identify the segment with the highest combined distance in both objectives\n            max_gain = -1\n            best_i, best_j = 0, 0\n            for i in range(n-1):\n                for j in range(i+1, min(i+10, n)):  # Limit search window for efficiency\n                    segment = new_solution[i:j+1]\n                    # Calculate original and reversed segment costs\n                    orig_cost1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n                    orig_cost2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n                    reversed_segment = segment[::-1]\n                    rev_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n                    rev_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n                    # Calculate potential gain\n                    gain = (orig_cost1 + orig_cost2) - (rev_cost1 + rev_cost2)\n                    if gain > max_gain:\n                        max_gain = gain\n                        best_i, best_j = i, j\n            if max_gain > 0:\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n        else:\n            # Targeted repositioning based on objective imbalance\n            # Identify the node with the highest difference in distances between objectives\n            max_diff = -1\n            best_node = 0\n            for i in range(n):\n                node = new_solution[i]\n                prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n                # Calculate current distances\n                curr_dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                curr_dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                # Calculate potential new positions\n                for j in range(n):\n                    if j != i and j != (i-1) % n and j != (i+1) % n:\n                        # Calculate distances if moved to position j\n                        new_prev = new_solution[j-1] if j > 0 else new_solution[-1]\n                        new_next = new_solution[j] if j < n-1 else new_solution[0]\n                        new_dist1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n                        new_dist2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n                        # Calculate difference in distances\n                        diff1 = new_dist1 - curr_dist1\n                        diff2 = new_dist2 - curr_dist2\n                        total_diff = abs(diff1) + abs(diff2)\n                        if total_diff > max_diff:\n                            max_diff = total_diff\n                            best_node = i\n                            best_pos = j\n            if max_diff > 0:\n                node = new_solution[best_node]\n                new_solution = np.delete(new_solution, best_node)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.860556296209215,
            1.2405003309249878
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Randomly decide between segment reversal or targeted repositioning\n        if random.random() < 0.5:\n            # Segment reversal with objective-aware selection\n            # Identify the segment with the highest combined distance in both objectives\n            max_gain = -1\n            best_i, best_j = 0, 0\n            for i in range(n-1):\n                for j in range(i+1, min(i+10, n)):  # Limit search window for efficiency\n                    segment = new_solution[i:j+1]\n                    # Calculate original and reversed segment costs\n                    orig_cost1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n                    orig_cost2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n                    reversed_segment = segment[::-1]\n                    rev_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n                    rev_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n                    # Calculate potential gain\n                    gain = (orig_cost1 + orig_cost2) - (rev_cost1 + rev_cost2)\n                    if gain > max_gain:\n                        max_gain = gain\n                        best_i, best_j = i, j\n            if max_gain > 0:\n                new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n        else:\n            # Targeted repositioning based on objective imbalance\n            # Identify the node with the highest difference in distances between objectives\n            max_diff = -1\n            best_node = 0\n            for i in range(n):\n                node = new_solution[i]\n                prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n                # Calculate current distances\n                curr_dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                curr_dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                # Calculate potential new positions\n                for j in range(n):\n                    if j != i and j != (i-1) % n and j != (i+1) % n:\n                        # Calculate distances if moved to position j\n                        new_prev = new_solution[j-1] if j > 0 else new_solution[-1]\n                        new_next = new_solution[j] if j < n-1 else new_solution[0]\n                        new_dist1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n                        new_dist2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n                        # Calculate difference in distances\n                        diff1 = new_dist1 - curr_dist1\n                        diff2 = new_dist2 - curr_dist2\n                        total_diff = abs(diff1) + abs(diff2)\n                        if total_diff > max_diff:\n                            max_diff = total_diff\n                            best_node = i\n                            best_pos = j\n            if max_diff > 0:\n                node = new_solution[best_node]\n                new_solution = np.delete(new_solution, best_node)\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a novel combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node chain inversion\" with a \"multi-segment rotation\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion + multi-segment rotation\n    if n > 5:\n        # Node chain inversion: Select a random chain of 3-5 nodes and invert them\n        chain_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n        new_solution[start:start+chain_length] = chain[::-1]\n\n        # Multi-segment rotation: Select 2-3 segments and rotate them\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = np.roll(segment, np.random.randint(1, length))\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a novel combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node chain inversion\" with a \"multi-segment rotation\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion + multi-segment rotation\n    if n > 5:\n        # Node chain inversion: Select a random chain of 3-5 nodes and invert them\n        chain_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n        new_solution[start:start+chain_length] = chain[::-1]\n\n        # Multi-segment rotation: Select 2-3 segments and rotate them\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = np.roll(segment, np.random.randint(1, length))\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel \"multi-segment crossover\" local search that combines segments from different parts of the solution with a dynamic node reordering step to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover: Select 2-3 non-overlapping segments and swap them between different parts of the solution\n    if n > 5:\n        num_segments = np.random.randint(2, 4)\n        segment_positions = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        # Extract segments\n        segments = []\n        for i in range(num_segments):\n            start = segment_positions[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segments.append(new_solution[start:start+length])\n\n        # Swap segments between different parts of the solution\n        if len(segments) >= 2:\n            for i in range(len(segments)):\n                target_pos = np.random.randint(0, n - len(segments[(i+1)%len(segments)]) + 1)\n                segment = segments[(i+1)%len(segments)]\n                new_solution = np.concatenate([\n                    new_solution[:target_pos],\n                    segment,\n                    new_solution[target_pos + len(segment):]\n                ])\n\n        # Dynamic node reordering: Reorder nodes in each segment based on their distance in both objective spaces\n        for i in range(num_segments):\n            start = segment_positions[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                # Sort segment nodes based on their average distance to adjacent nodes in both spaces\n                segment_order = sorted(range(len(segment)), key=lambda x: (\n                    (distance_matrix_1[segment[x-1], segment[x]] + distance_matrix_1[segment[x], segment[(x+1)%len(segment)]]) / 2 +\n                    (distance_matrix_2[segment[x-1], segment[x]] + distance_matrix_2[segment[x], segment[(x+1)%len(segment)]]) / 2\n                ))\n                new_solution[start:start+length] = segment[segment_order]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel \"adaptive segment inversion and reinsertion\" local search that dynamically selects and inverts segments of the tour while reinserting them at positions optimized for both objective spaces, ensuring feasibility through careful segment handling and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))  # Top 5 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion and reinsertion\n    if n > 5:\n        # Select a segment to invert\n        segment_start = np.random.randint(0, n - 3)\n        segment_length = np.random.randint(3, min(8, n - segment_start))\n        segment = new_solution[segment_start:segment_start + segment_length]\n        inverted_segment = segment[::-1]\n\n        # Remove the original segment\n        new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n        # Find optimal insertion position considering both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution) + 1):\n            # Insert the inverted segment at position pos\n            candidate = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n            # Calculate cost in both spaces\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n\n            # Combine costs with adaptive weighting\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert the inverted segment at the best position\n        new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n        # Additional optimization: reorder nodes in the inverted segment based on both objectives\n        if segment_length > 2:\n            segment_pos = best_pos\n            segment = new_solution[segment_pos:segment_pos + segment_length]\n            segment_order = sorted(range(len(segment)), key=lambda x: (\n                (distance_matrix_1[segment[x-1], segment[x]] + distance_matrix_1[segment[x], segment[(x+1)%len(segment)]]) / 2 +\n                (distance_matrix_2[segment[x-1], segment[x]] + distance_matrix_2[segment[x], segment[(x+1)%len(segment)]]) / 2\n            ))\n            new_solution[segment_pos:segment_pos + segment_length] = segment[segment_order]\n\n    return new_solution\n\n",
        "score": [
            -0.8580410236214548,
            0.6227623820304871
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))  # Top 5 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion and reinsertion\n    if n > 5:\n        # Select a segment to invert\n        segment_start = np.random.randint(0, n - 3)\n        segment_length = np.random.randint(3, min(8, n - segment_start))\n        segment = new_solution[segment_start:segment_start + segment_length]\n        inverted_segment = segment[::-1]\n\n        # Remove the original segment\n        new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n        # Find optimal insertion position considering both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution) + 1):\n            # Insert the inverted segment at position pos\n            candidate = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n            # Calculate cost in both spaces\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate)))\n\n            # Combine costs with adaptive weighting\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert the inverted segment at the best position\n        new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n        # Additional optimization: reorder nodes in the inverted segment based on both objectives\n        if segment_length > 2:\n            segment_pos = best_pos\n            segment = new_solution[segment_pos:segment_pos + segment_length]\n            segment_order = sorted(range(len(segment)), key=lambda x: (\n                (distance_matrix_1[segment[x-1], segment[x]] + distance_matrix_1[segment[x], segment[(x+1)%len(segment)]]) / 2 +\n                (distance_matrix_2[segment[x-1], segment[x]] + distance_matrix_2[segment[x], segment[(x+1)%len(segment)]]) / 2\n            ))\n            new_solution[segment_pos:segment_pos + segment_length] = segment[segment_order]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search: Combine node swapping with a dynamic segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    segment_length = np.random.randint(2, min(5, n))\n    start_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment in a new random position\n    insert_pos = np.random.randint(0, n - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Dynamic node swapping: Swap nodes based on their distance in both objective spaces\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if the swap doesn't improve both objectives\n        if (cost1_after >= cost1_before) and (cost2_after >= cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A new hybrid local search algorithm that combines a novel segment relocation with a dynamic inversion strategy to explore diverse neighborhoods while ensuring feasibility, by first selecting a promising solution from the archive and then applying a combination of segment operations and dynamic inversions to generate high-quality neighbors.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment relocation: Move a segment to a new position\n    if n > 4:\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Dynamic inversion: Invert segments based on distance matrices\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        # Decide inversion based on distance matrices\n        cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        if cost_after < cost_before:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{A new hybrid local search algorithm that combines a novel edge exchange strategy with a dynamic path reversal operation, where it first selects a solution from the archive based on its Pareto dominance front, then identifies critical edges in both objective spaces, exchanges them, and reverses segments to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the Pareto front (non-dominated solutions)\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = np.random.choice(pareto_front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange strategy: identify critical edges in both objectives\n    if n > 3:\n        # Find the worst edge in each objective space\n        worst_edge1 = max(range(n), key=lambda i: distance_matrix_1[new_solution[i-1], new_solution[i]])\n        worst_edge2 = max(range(n), key=lambda i: distance_matrix_2[new_solution[i-1], new_solution[i]])\n\n        # Exchange the nodes of the worst edges\n        if worst_edge1 != worst_edge2:\n            i1 = worst_edge1 - 1\n            j1 = worst_edge1\n            i2 = worst_edge2 - 1\n            j2 = worst_edge2\n\n            # Perform edge exchange\n            new_solution[i1], new_solution[i2] = new_solution[i2], new_solution[i1]\n\n    # Dynamic path reversal: reverse a segment based on combined objective improvement\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        cost1_before = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n        cost2_before = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n        segment_reversed = segment[::-1]\n        new_solution_reversed = np.concatenate([new_solution[:i], segment_reversed, new_solution[j:]])\n\n        cost1_after = sum(distance_matrix_1[new_solution_reversed[k-1], new_solution_reversed[k]] for k in range(i, j+1))\n        cost2_after = sum(distance_matrix_2[new_solution_reversed[k-1], new_solution_reversed[k]] for k in range(i, j+1))\n\n        # Accept reversal if it improves both objectives\n        if cost1_after < cost1_before and cost2_after < cost2_before:\n            new_solution = new_solution_reversed\n\n    return new_solution\n\n",
        "score": [
            -0.8768569154487762,
            8.192715287208557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the Pareto front (non-dominated solutions)\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = np.random.choice(pareto_front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange strategy: identify critical edges in both objectives\n    if n > 3:\n        # Find the worst edge in each objective space\n        worst_edge1 = max(range(n), key=lambda i: distance_matrix_1[new_solution[i-1], new_solution[i]])\n        worst_edge2 = max(range(n), key=lambda i: distance_matrix_2[new_solution[i-1], new_solution[i]])\n\n        # Exchange the nodes of the worst edges\n        if worst_edge1 != worst_edge2:\n            i1 = worst_edge1 - 1\n            j1 = worst_edge1\n            i2 = worst_edge2 - 1\n            j2 = worst_edge2\n\n            # Perform edge exchange\n            new_solution[i1], new_solution[i2] = new_solution[i2], new_solution[i1]\n\n    # Dynamic path reversal: reverse a segment based on combined objective improvement\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        cost1_before = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n        cost2_before = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n        segment_reversed = segment[::-1]\n        new_solution_reversed = np.concatenate([new_solution[:i], segment_reversed, new_solution[j:]])\n\n        cost1_after = sum(distance_matrix_1[new_solution_reversed[k-1], new_solution_reversed[k]] for k in range(i, j+1))\n        cost2_after = sum(distance_matrix_2[new_solution_reversed[k-1], new_solution_reversed[k]] for k in range(i, j+1))\n\n        # Accept reversal if it improves both objectives\n        if cost1_after < cost1_before and cost2_after < cost2_before:\n            new_solution = new_solution_reversed\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted sum of normalized objective scores, then applies a novel local search strategy that combines adaptive segment rotation and edge inversion with probabilistic acceptance to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and compute weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        rotation = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.roll(segment, rotation)\n\n    # Probabilistic edge inversion\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        prob = 1 / (1 + np.exp(-(cost1_change + cost2_change) / 10))\n        if np.random.random() < prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score with adaptive weights that vary per iteration, then applies a hybrid local search combining segment reversal and probabilistic edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weight selection based on solution diversity\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Dynamic weight adjustment\n    diversity = np.std(normalized_obj, axis=0)\n    weights = diversity / np.sum(diversity)\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    if n >= 4:\n        segment_len = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - segment_len)\n        new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n    # Probabilistic edge swap with adaptive temperature\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        temperature = 10 * (1 - np.mean(normalized_obj[selected_idx]))\n        prob = 1 / (1 + np.exp(-(cost1_change + cost2_change) / temperature))\n        if np.random.random() < prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7404932060627332,
            0.3060135245323181
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Adaptive weight selection based on solution diversity\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Dynamic weight adjustment\n    diversity = np.std(normalized_obj, axis=0)\n    weights = diversity / np.sum(diversity)\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    if n >= 4:\n        segment_len = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - segment_len)\n        new_solution[start:start+segment_len] = new_solution[start:start+segment_len][::-1]\n\n    # Probabilistic edge swap with adaptive temperature\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        temperature = 10 * (1 - np.mean(normalized_obj[selected_idx]))\n        prob = 1 / (1 + np.exp(-(cost1_change + cost2_change) / temperature))\n        if np.random.random() < prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"multi-segment reordering\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + multi-segment reordering\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and invert it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Multi-segment reordering: Select 3 non-overlapping segments and reorder them\n        if n > 8:\n            points = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n            a, b, c = points[0], points[1], points[2]\n\n            segments = [\n                new_solution[:a],\n                new_solution[a:b],\n                new_solution[b:c],\n                new_solution[c:]\n            ]\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n    return new_solution\n\n",
        "score": [
            -0.9158633450203952,
            0.21772384643554688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + multi-segment reordering\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and invert it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Multi-segment reordering: Select 3 non-overlapping segments and reorder them\n        if n > 8:\n            points = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n            a, b, c = points[0], points[1], points[2]\n\n            segments = [\n                new_solution[:a],\n                new_solution[a:b],\n                new_solution[b:c],\n                new_solution[c:]\n            ]\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825132786060556,
            2.4285667538642883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825132786060556,
            2.4285667538642883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{This algorithm selects a solution from the archive based on its position in the Pareto front, then applies a novel hybrid local search strategy that combines adaptive segment insertion with dynamic edge swapping to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best crowding distance in the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum(np.abs(objectives - np.roll(objectives, 1, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Dynamic edge swapping with objective-aware selection\n    if n >= 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while abs(i - j) <= 1:\n            j = np.random.randint(1, n-1)\n\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]))\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]))\n\n        # Apply swap if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7038975009723714,
            0.3016282320022583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best crowding distance in the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum(np.abs(objectives - np.roll(objectives, 1, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Dynamic edge swapping with objective-aware selection\n    if n >= 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while abs(i - j) <= 1:\n            j = np.random.randint(1, n-1)\n\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]))\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]))\n\n        # Apply swap if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware objective score, then applies a novel local search strategy combining adaptive path inversion with objective-balanced edge reallocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity-aware objective score\n    objectives = [obj for _, obj in archive]\n    obj1_scores = [obj[0] for obj in objectives]\n    obj2_scores = [obj[1] for obj in objectives]\n\n    if len(archive) > 1:\n        std_obj1 = np.std(obj1_scores)\n        std_obj2 = np.std(obj2_scores)\n        diversity_scores = [(obj1_scores[i] - min(obj1_scores))/max(1, std_obj1) + (obj2_scores[i] - min(obj2_scores))/max(1, std_obj2) for i in range(len(archive))]\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion with objective balance\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Calculate objective impact\n        cost1_change = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))) - \\\n                      (distance_matrix_1[segment[-1], segment[0]] + sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))))\n\n        cost2_change = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))) - \\\n                      (distance_matrix_2[segment[-1], segment[0]] + sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))))\n\n        # Balance objectives if needed\n        if (cost1_change > 0 and cost2_change < 0) or (cost1_change < 0 and cost2_change > 0):\n            new_solution[a:b+1] = segment[::-1]\n\n    # Objective-balanced edge reallocation\n    if n >= 5:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(0, n)\n\n        # Calculate potential cost changes\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]] +\n                       distance_matrix_1[new_solution[k], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]] +\n                       distance_matrix_2[new_solution[k], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Apply reallocation if it improves both objectives\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8263224668767757,
            0.9230151176452637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity-aware objective score\n    objectives = [obj for _, obj in archive]\n    obj1_scores = [obj[0] for obj in objectives]\n    obj2_scores = [obj[1] for obj in objectives]\n\n    if len(archive) > 1:\n        std_obj1 = np.std(obj1_scores)\n        std_obj2 = np.std(obj2_scores)\n        diversity_scores = [(obj1_scores[i] - min(obj1_scores))/max(1, std_obj1) + (obj2_scores[i] - min(obj2_scores))/max(1, std_obj2) for i in range(len(archive))]\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion with objective balance\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n        # Calculate objective impact\n        cost1_change = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))) - \\\n                      (distance_matrix_1[segment[-1], segment[0]] + sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment))))\n\n        cost2_change = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))) - \\\n                      (distance_matrix_2[segment[-1], segment[0]] + sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment))))\n\n        # Balance objectives if needed\n        if (cost1_change > 0 and cost2_change < 0) or (cost1_change < 0 and cost2_change > 0):\n            new_solution[a:b+1] = segment[::-1]\n\n    # Objective-balanced edge reallocation\n    if n >= 5:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+1, n-1)\n        k = np.random.randint(0, n)\n\n        # Calculate potential cost changes\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]] +\n                       distance_matrix_1[new_solution[k], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]] +\n                       distance_matrix_2[new_solution[k], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Apply reallocation if it improves both objectives\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n",
        "score": [
            -0.8305491903840492,
            0.09524679183959961
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"multi-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + multi-segment rotation\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and invert it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Multi-segment rotation: Select three segments and rotate their positions\n        if n > 12:\n            segment_indices = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            a, b = segment_indices[0], segment_indices[1]\n\n            # Rotate segments: [0..a), [a..b), [b..n)\n            new_solution = np.concatenate([new_solution[b:], new_solution[:a], new_solution[a:b]])\n\n    return new_solution\n\n",
        "score": [
            -0.7915527629532735,
            0.25824183225631714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + multi-segment rotation\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and invert it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Multi-segment rotation: Select three segments and rotate their positions\n        if n > 12:\n            segment_indices = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            a, b = segment_indices[0], segment_indices[1]\n\n            # Rotate segments: [0..a), [a..b), [b..n)\n            new_solution = np.concatenate([new_solution[b:], new_solution[:a], new_solution[a:b]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment inversion with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.7:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8740049338447734,
            0.18587791919708252
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.7:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining adaptive node relocation with objective-aware edge flipping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using crowding distance\n    objectives = [obj for _, obj in archive]\n    obj1 = [o[0] for o in objectives]\n    obj2 = [o[1] for o in objectives]\n\n    sorted_idx1 = np.argsort(obj1)\n    sorted_idx2 = np.argsort(obj2)\n\n    crowding = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive)-1:\n            crowding[i] = float('inf')\n        else:\n            crowding[i] = (obj1[sorted_idx1[i+1]] - obj1[sorted_idx1[i-1]]) / (max(obj1) - min(obj1)) + \\\n                          (obj2[sorted_idx2[i+1]] - obj2[sorted_idx2[i-1]]) / (max(obj2) - min(obj2))\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    if n >= 4:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(2, n)\n        while j == i or j == i+1:\n            j = np.random.randint(2, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Objective-aware edge flipping\n    if n >= 4:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+2, n)\n        if j > i+1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[i+1]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[i+1]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i:j+1] = np.concatenate([new_solution[j:j+1], new_solution[i+1:j][::-1], new_solution[i:i+1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7372836679814094,
            0.4251450300216675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using crowding distance\n    objectives = [obj for _, obj in archive]\n    obj1 = [o[0] for o in objectives]\n    obj2 = [o[1] for o in objectives]\n\n    sorted_idx1 = np.argsort(obj1)\n    sorted_idx2 = np.argsort(obj2)\n\n    crowding = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive)-1:\n            crowding[i] = float('inf')\n        else:\n            crowding[i] = (obj1[sorted_idx1[i+1]] - obj1[sorted_idx1[i-1]]) / (max(obj1) - min(obj1)) + \\\n                          (obj2[sorted_idx2[i+1]] - obj2[sorted_idx2[i-1]]) / (max(obj2) - min(obj2))\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    if n >= 4:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(2, n)\n        while j == i or j == i+1:\n            j = np.random.randint(2, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Objective-aware edge flipping\n    if n >= 4:\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+2, n)\n        if j > i+1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[i+1]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[i+1]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i:j+1] = np.concatenate([new_solution[j:j+1], new_solution[i+1:j][::-1], new_solution[i:i+1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines edge swaps and node insertions to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    if n > 3:\n        # Randomly choose between edge swap or node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and node centrality, then applies a novel local search strategy that combines adaptive k-opt moves with objective-aware edge replacements to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score and centrality\n    scores = []\n    for sol, obj in archive:\n        # Calculate centrality as average distance to all other nodes\n        centrality = 0\n        for i in range(len(sol)):\n            for j in range(i+1, len(sol)):\n                centrality += distance_matrix_1[sol[i], sol[j]] + distance_matrix_2[sol[i], sol[j]]\n        scores.append(obj[0] + obj[1] - centrality)  # Higher centrality is better\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt move (k between 3 and 5)\n    if n >= 6:\n        k = random.randint(3, 5)\n        if n >= k:\n            # Select k distinct nodes\n            nodes = random.sample(range(n), k)\n            # Replace the segment with a new random order\n            segment = new_solution[nodes]\n            random.shuffle(segment)\n            for i, node in zip(nodes, segment):\n                new_solution[i] = node\n\n    # Objective-aware edge replacement\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply replacement if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8044553343011107,
            7.567783057689667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score and centrality\n    scores = []\n    for sol, obj in archive:\n        # Calculate centrality as average distance to all other nodes\n        centrality = 0\n        for i in range(len(sol)):\n            for j in range(i+1, len(sol)):\n                centrality += distance_matrix_1[sol[i], sol[j]] + distance_matrix_2[sol[i], sol[j]]\n        scores.append(obj[0] + obj[1] - centrality)  # Higher centrality is better\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt move (k between 3 and 5)\n    if n >= 6:\n        k = random.randint(3, 5)\n        if n >= k:\n            # Select k distinct nodes\n            nodes = random.sample(range(n), k)\n            # Replace the segment with a new random order\n            segment = new_solution[nodes]\n            random.shuffle(segment)\n            for i, node in zip(nodes, segment):\n                new_solution[i] = node\n\n    # Objective-aware edge replacement\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply replacement if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted objective score combining both objectives with adaptive weights, then applies a hybrid local search strategy that includes segment reversal with objective-aware selection and edge swapping with adaptive neighborhood restriction to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objectives and select solution with best weighted score\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    norm_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-8)\n    norm_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-8)\n    weights = np.random.uniform(0.3, 0.7)  # Random adaptive weights\n    combined_scores = weights * norm_obj1 + (1 - weights) * norm_obj2\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if n >= 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length - 1\n        segment = new_solution[a:b+1]\n\n        # Calculate potential cost change\n        cost1_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        cost1_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        # Apply if improves at least one objective\n        if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n            new_solution[a:b+1] = segment[::-1]\n\n    # Edge swapping with adaptive neighborhood restriction\n    if n >= 4:\n        neighborhood_size = min(8, n//2)\n        i = np.random.randint(1, neighborhood_size)\n        j = np.random.randint(i+1, min(i+neighborhood_size, n-1))\n\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Apply if improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8029929918264385,
            0.9625248312950134
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objectives and select solution with best weighted score\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    norm_obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-8)\n    norm_obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-8)\n    weights = np.random.uniform(0.3, 0.7)  # Random adaptive weights\n    combined_scores = weights * norm_obj1 + (1 - weights) * norm_obj2\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if n >= 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length - 1\n        segment = new_solution[a:b+1]\n\n        # Calculate potential cost change\n        cost1_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        cost1_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n        # Apply if improves at least one objective\n        if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n            new_solution[a:b+1] = segment[::-1]\n\n    # Edge swapping with adaptive neighborhood restriction\n    if n >= 4:\n        neighborhood_size = min(8, n//2)\n        i = np.random.randint(1, neighborhood_size)\n        j = np.random.randint(i+1, min(i+neighborhood_size, n-1))\n\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Apply if improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hypervolume-based selection criterion, then applies a novel local search strategy combining adaptive node insertion and multi-objective edge flipping to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hypervolume-based selection\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0)\n    hypervolumes = np.prod(ref_point - objectives, axis=1)\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Multi-objective edge flipping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6938357605790711,
            0.26503461599349976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hypervolume-based selection\n    objectives = np.array([obj for _, obj in archive])\n    ref_point = np.max(objectives, axis=0)\n    hypervolumes = np.prod(ref_point - objectives, axis=1)\n    selected_idx = np.argmax(hypervolumes)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Multi-objective edge flipping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.959617718588408,
            0.19279181957244873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search strategy combining adaptive node swapping and objective-balanced segment inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity score (minimize objective correlation)\n    objectives = np.array([obj for _, obj in archive])\n    correlations = np.array([np.corrcoef(objectives[:,0], objectives[:,1])[0,1]])\n    selected_idx = np.argmin(correlations)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node swapping with objective balancing\n    if n >= 3:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Apply swap if it improves at least one objective or balances both\n        if cost1_change < 0 or cost2_change < 0 or (abs(cost1_change) < abs(cost2_change) and cost1_change < 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Objective-balanced segment inversion\n    if n >= 5:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        # Calculate potential cost change for segment inversion\n        cost1_change = (distance_matrix_1[new_solution[a-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(b+1)%n]] -\n                        distance_matrix_1[new_solution[a-1], segment[0]] - distance_matrix_1[segment[-1], new_solution[(b+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[a-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(b+1)%n]] -\n                        distance_matrix_2[new_solution[a-1], segment[0]] - distance_matrix_2[segment[-1], new_solution[(b+1)%n]])\n\n        # Apply inversion if it improves at least one objective or balances both\n        if cost1_change < 0 or cost2_change < 0 or (abs(cost1_change) < abs(cost2_change) and cost1_change < 0):\n            new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7908180288971947,
            0.41264575719833374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity score (minimize objective correlation)\n    objectives = np.array([obj for _, obj in archive])\n    correlations = np.array([np.corrcoef(objectives[:,0], objectives[:,1])[0,1]])\n    selected_idx = np.argmin(correlations)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node swapping with objective balancing\n    if n >= 3:\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Apply swap if it improves at least one objective or balances both\n        if cost1_change < 0 or cost2_change < 0 or (abs(cost1_change) < abs(cost2_change) and cost1_change < 0):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Objective-balanced segment inversion\n    if n >= 5:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        # Calculate potential cost change for segment inversion\n        cost1_change = (distance_matrix_1[new_solution[a-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(b+1)%n]] -\n                        distance_matrix_1[new_solution[a-1], segment[0]] - distance_matrix_1[segment[-1], new_solution[(b+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[a-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(b+1)%n]] -\n                        distance_matrix_2[new_solution[a-1], segment[0]] - distance_matrix_2[segment[-1], new_solution[(b+1)%n]])\n\n        # Apply inversion if it improves at least one objective or balances both\n        if cost1_change < 0 or cost2_change < 0 or (abs(cost1_change) < abs(cost2_change) and cost1_change < 0):\n            new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"node cluster rotation\" local search strategy that rotates clusters of nodes around a central pivot point to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node cluster rotation: Select a cluster of nodes and rotate them around a pivot\n    if n > 3:\n        cluster_size = np.random.randint(2, min(5, n//2))\n        pivot = np.random.randint(0, n)\n        cluster_start = (pivot + 1) % n\n        cluster_end = (cluster_start + cluster_size) % n\n\n        if cluster_start < cluster_end:\n            cluster = new_solution[cluster_start:cluster_end].copy()\n            rotated_cluster = np.roll(cluster, np.random.randint(1, cluster_size))\n            new_solution[cluster_start:cluster_end] = rotated_cluster\n        else:\n            cluster1 = new_solution[cluster_start:].copy()\n            cluster2 = new_solution[:cluster_end].copy()\n            combined_cluster = np.concatenate([cluster1, cluster2])\n            rotated_cluster = np.roll(combined_cluster, np.random.randint(1, cluster_size))\n            new_solution[cluster_start:] = rotated_cluster[:len(cluster1)]\n            new_solution[:cluster_end] = rotated_cluster[len(cluster1):]\n\n    return new_solution\n\n",
        "score": [
            -0.7887912950468445,
            0.2803707718849182
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node cluster rotation: Select a cluster of nodes and rotate them around a pivot\n    if n > 3:\n        cluster_size = np.random.randint(2, min(5, n//2))\n        pivot = np.random.randint(0, n)\n        cluster_start = (pivot + 1) % n\n        cluster_end = (cluster_start + cluster_size) % n\n\n        if cluster_start < cluster_end:\n            cluster = new_solution[cluster_start:cluster_end].copy()\n            rotated_cluster = np.roll(cluster, np.random.randint(1, cluster_size))\n            new_solution[cluster_start:cluster_end] = rotated_cluster\n        else:\n            cluster1 = new_solution[cluster_start:].copy()\n            cluster2 = new_solution[:cluster_end].copy()\n            combined_cluster = np.concatenate([cluster1, cluster2])\n            rotated_cluster = np.roll(combined_cluster, np.random.randint(1, cluster_size))\n            new_solution[cluster_start:] = rotated_cluster[:len(cluster1)]\n            new_solution[:cluster_end] = rotated_cluster[len(cluster1):]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This new algorithm selects a solution from the archive based on a Pareto dominance-aware selection criterion, then applies a hybrid local search that combines adaptive node clustering and cross-space edge replacement to generate a neighbor solution while balancing improvements in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with Pareto dominance consideration\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering\n    if n >= 4:\n        cluster_size = max(2, n // 4)\n        cluster_start = np.random.randint(0, n - cluster_size + 1)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Find best insertion point in another cluster\n        other_start = np.random.randint(0, n - cluster_size + 1)\n        while abs(other_start - cluster_start) < cluster_size:\n            other_start = np.random.randint(0, n - cluster_size + 1)\n\n        # Move cluster to new position\n        new_solution = np.concatenate([\n            new_solution[:cluster_start],\n            new_solution[cluster_start+cluster_size:other_start],\n            cluster,\n            new_solution[other_start:]\n        ])\n\n    # Cross-space edge replacement\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate cost changes considering both spaces\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply replacement if it improves at least one objective or maintains quality\n        if cost1_change <= 0 or cost2_change <= 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8548959080761918,
            0.7770338654518127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with Pareto dominance consideration\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering\n    if n >= 4:\n        cluster_size = max(2, n // 4)\n        cluster_start = np.random.randint(0, n - cluster_size + 1)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Find best insertion point in another cluster\n        other_start = np.random.randint(0, n - cluster_size + 1)\n        while abs(other_start - cluster_start) < cluster_size:\n            other_start = np.random.randint(0, n - cluster_size + 1)\n\n        # Move cluster to new position\n        new_solution = np.concatenate([\n            new_solution[:cluster_start],\n            new_solution[cluster_start+cluster_size:other_start],\n            cluster,\n            new_solution[other_start:]\n        ])\n\n    # Cross-space edge replacement\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate cost changes considering both spaces\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply replacement if it improves at least one objective or maintains quality\n        if cost1_change <= 0 or cost2_change <= 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{The new algorithm selects a solution from the archive based on a dynamic score combining objective values and solution diversity, then applies a hybrid local search combining a novel segment inversion with a dynamic segment relocation to explore high-quality neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(archive[0][0])\n    if n < 4:\n        return archive[0][0].copy()\n\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        diversity = np.sum(np.abs(sol - np.mean(sol)))\n        scores.append((obj1 + obj2) / (1 + diversity))\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    if random.random() < 0.7:\n        c = random.randint(0, n-1)\n        if c < a or c > b:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7057998351156245,
            0.4466180205345154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(archive[0][0])\n    if n < 4:\n        return archive[0][0].copy()\n\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        diversity = np.sum(np.abs(sol - np.mean(sol)))\n        scores.append((obj1 + obj2) / (1 + diversity))\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    if random.random() < 0.7:\n        c = random.randint(0, n-1)\n        if c < a or c > b:\n            segment = new_solution[a:b+1]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that balances the two objectives, then applies a hybrid local search strategy that combines adaptive segment rotation and objective-aware edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with best combined score\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-8)\n    obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-8)\n    combined_score = 0.6 * obj1_norm + 0.4 * obj2_norm\n    selected_idx = np.argmin(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Objective-aware edge insertion\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if j - i > 1:\n            # Calculate potential cost change\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                           distance_matrix_1[new_solution[i], new_solution[i+1]])\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                           distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n            # Apply insertion if it improves at least one objective\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7427694988942921,
            0.24581927061080933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with best combined score\n    obj1 = np.array([obj[0] for _, obj in archive])\n    obj2 = np.array([obj[1] for _, obj in archive])\n    obj1_norm = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-8)\n    obj2_norm = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-8)\n    combined_score = 0.6 * obj1_norm + 0.4 * obj2_norm\n    selected_idx = np.argmin(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Objective-aware edge insertion\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if j - i > 1:\n            # Calculate potential cost change\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                           distance_matrix_1[new_solution[i], new_solution[i+1]])\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                           distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n            # Apply insertion if it improves at least one objective\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment inversion with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.7:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a hybrid local search combining adaptive segment relocation with objective-aware edge reordering to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    obj1_mean, obj2_mean = np.mean(objectives, axis=0)\n    improvement_potential = np.sum(np.abs(objectives - [obj1_mean, obj2_mean]), axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relocation\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n    insert_pos = random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Objective-aware edge reordering\n    if n >= 4:\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        while j == i or j == i+1 or j == i-1:\n            j = random.randint(1, n-2)\n\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8155077345597095,
            0.3055095076560974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    obj1_mean, obj2_mean = np.mean(objectives, axis=0)\n    improvement_potential = np.sum(np.abs(objectives - [obj1_mean, obj2_mean]), axis=1)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relocation\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n    insert_pos = random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Objective-aware edge reordering\n    if n >= 4:\n        i = random.randint(1, n-2)\n        j = random.randint(1, n-2)\n        while j == i or j == i+1 or j == i-1:\n            j = random.randint(1, n-2)\n\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding distance metric that identifies solutions in less crowded regions, then applies a hybrid local search combining random segment reversal and adaptive node insertion to generate a neighbor solution while balancing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(1, len(sorted_objectives)-1):\n        crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0]) + \\\n                                (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1])\n\n    selected_idx = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment reversal\n    if n >= 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.choice(range(1, n-1))\n        j = np.random.choice(range(n))\n        while j == i or j == i-1 or j == (i+1)%n:\n            j = np.random.choice(range(n))\n\n        cost1_change = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[(i+1)%n]] - \\\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] - \\\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n\n        cost2_change = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[(i+1)%n]] - \\\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] - \\\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        if cost1_change < 0 and cost2_change < 0:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8870795052254854,
            0.33554428815841675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for i in range(1, len(sorted_objectives)-1):\n        crowding_distances[i] = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) / (sorted_objectives[-1, 0] - sorted_objectives[0, 0]) + \\\n                                (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1]) / (sorted_objectives[-1, 1] - sorted_objectives[0, 1])\n\n    selected_idx = sorted_indices[np.argmax(crowding_distances)]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment reversal\n    if n >= 3:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.choice(range(1, n-1))\n        j = np.random.choice(range(n))\n        while j == i or j == i-1 or j == (i+1)%n:\n            j = np.random.choice(range(n))\n\n        cost1_change = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[(i+1)%n]] - \\\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] - \\\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n\n        cost2_change = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[(i+1)%n]] - \\\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] - \\\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        if cost1_change < 0 and cost2_change < 0:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-segment inversion and relocation\" strategy to generate a neighbor solution by inverting multiple non-overlapping segments and relocating them to different positions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    num_segments = np.random.randint(2, min(4, n // 2))\n    segment_lengths = np.random.randint(2, min(5, n // num_segments), size=num_segments)\n    segment_starts = np.random.choice(range(n - sum(segment_lengths) + 1), size=num_segments, replace=False)\n\n    segments = []\n    for i in range(num_segments):\n        start = segment_starts[i]\n        length = segment_lengths[i]\n        segments.append(new_solution[start:start+length])\n\n    for i, segment in enumerate(segments):\n        segments[i] = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:segment_starts[0]]] +\n                                  [segment for segment in segments] +\n                                  [new_solution[segment_starts[-1]+segment_lengths[-1]:]])\n\n    if len(new_solution) != n:\n        new_solution = base_solution.copy()\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9289765557424794,
            0.26593953371047974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    num_segments = np.random.randint(2, min(4, n // 2))\n    segment_lengths = np.random.randint(2, min(5, n // num_segments), size=num_segments)\n    segment_starts = np.random.choice(range(n - sum(segment_lengths) + 1), size=num_segments, replace=False)\n\n    segments = []\n    for i in range(num_segments):\n        start = segment_starts[i]\n        length = segment_lengths[i]\n        segments.append(new_solution[start:start+length])\n\n    for i, segment in enumerate(segments):\n        segments[i] = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:segment_starts[0]]] +\n                                  [segment for segment in segments] +\n                                  [new_solution[segment_starts[-1]+segment_lengths[-1]:]])\n\n    if len(new_solution) != n:\n        new_solution = base_solution.copy()\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"cross-segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + cross-segment insertion\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and invert it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment insertion: Select a segment and insert it into another position\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.delete(new_solution, slice(start, start+segment_length))\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9351150882676877,
            0.2972075343132019
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + cross-segment insertion\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and invert it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment insertion: Select a segment and insert it into another position\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.delete(new_solution, slice(start, start+segment_length))\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of normalized objectives, then applies a hybrid local search combining adaptive node insertion with objective-aware edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        weighted_scores = [(0.7 * (obj[0] - min_obj1)/(max_obj1 - min_obj1) + 0.3 * (obj[1] - min_obj2)/(max_obj2 - min_obj2)) for _, obj in archive]\n        selected_idx = np.argmin(weighted_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6620320163442277,
            0.14544594287872314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        weighted_scores = [(0.7 * (obj[0] - min_obj1)/(max_obj1 - min_obj1) + 0.3 * (obj[1] - min_obj2)/(max_obj2 - min_obj2)) for _, obj in archive]\n        selected_idx = np.argmin(weighted_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"multi-segment reordering\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + multi-segment reordering\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and invert it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Multi-segment reordering: Select 3 non-overlapping segments and reorder them\n        if n > 8:\n            points = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n            a, b, c = points[0], points[1], points[2]\n\n            segments = [\n                new_solution[:a],\n                new_solution[a:b],\n                new_solution[b:c],\n                new_solution[c:]\n            ]\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a hybrid local search combining a novel \"node chain relocation\" with an \"adaptive segment crossover\" to generate a neighbor solution while ensuring feasibility and prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node chain relocation: Extract a chain of 2-5 consecutive nodes and relocate it\n    if n > 5:\n        chain_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n\n        # Find the best insertion point that minimizes the sum of both objectives\n        best_cost = float('inf')\n        best_pos = start\n        for pos in range(n - chain_length + 1):\n            if pos == start:\n                continue\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                chain,\n                np.delete(new_solution, range(start, start+chain_length))\n            ])\n\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Apply the relocation\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            chain,\n            np.delete(new_solution, range(start, start+chain_length))\n        ])\n\n    # Adaptive segment crossover: Select two non-overlapping segments and swap them\n    if n > 8:\n        points = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        a, b = points[0], points[1]\n\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Evaluate all possible orderings of the segments\n        candidates = [\n            np.concatenate([segment1, segment2, segment3]),\n            np.concatenate([segment1, segment3, segment2]),\n            np.concatenate([segment2, segment1, segment3]),\n            np.concatenate([segment2, segment3, segment1]),\n            np.concatenate([segment3, segment1, segment2]),\n            np.concatenate([segment3, segment2, segment1])\n        ]\n\n        best_candidate = min(candidates, key=lambda x: sum(distance_matrix_1[x[i-1], x[i]] for i in range(n)) + sum(distance_matrix_2[x[i-1], x[i]] for i in range(n)))\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8959357224365689,
            0.7490707039833069
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Node chain relocation: Extract a chain of 2-5 consecutive nodes and relocate it\n    if n > 5:\n        chain_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n\n        # Find the best insertion point that minimizes the sum of both objectives\n        best_cost = float('inf')\n        best_pos = start\n        for pos in range(n - chain_length + 1):\n            if pos == start:\n                continue\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                chain,\n                np.delete(new_solution, range(start, start+chain_length))\n            ])\n\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Apply the relocation\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            chain,\n            np.delete(new_solution, range(start, start+chain_length))\n        ])\n\n    # Adaptive segment crossover: Select two non-overlapping segments and swap them\n    if n > 8:\n        points = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        a, b = points[0], points[1]\n\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Evaluate all possible orderings of the segments\n        candidates = [\n            np.concatenate([segment1, segment2, segment3]),\n            np.concatenate([segment1, segment3, segment2]),\n            np.concatenate([segment2, segment1, segment3]),\n            np.concatenate([segment2, segment3, segment1]),\n            np.concatenate([segment3, segment1, segment2]),\n            np.concatenate([segment3, segment2, segment1])\n        ]\n\n        best_candidate = min(candidates, key=lambda x: sum(distance_matrix_1[x[i-1], x[i]] for i in range(n)) + sum(distance_matrix_2[x[i-1], x[i]] for i in range(n)))\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{The algorithm selects the best solution from the archive based on the sum of normalized objectives, then applies a novel multi-segment swap and insertion operator that dynamically adjusts segment sizes and positions to explore high-quality neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 0:\n        norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = norm_objectives.sum(axis=1)\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = max(2, min(5, random.randint(1, n // 2)))\n    a = random.randint(0, n - segment_length)\n    b = a + segment_length\n\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8789961824634134,
            0.21609127521514893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 0:\n        norm_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = norm_objectives.sum(axis=1)\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = max(2, min(5, random.randint(1, n // 2)))\n    a = random.randint(0, n - segment_length)\n    b = a + segment_length\n\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{The new algorithm selects a solution from the archive based on a score combining normalized objective values and tour diversity, then applies a hybrid local search combining a novel segment reversal with a dynamic reordering strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for _, obj in archive]\n    obj1 = [o[0] for o in objectives]\n    obj2 = [o[1] for o in objectives]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n\n    scores = []\n    for i, (sol, (o1, o2)) in enumerate(archive):\n        norm_obj1 = (o1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (o2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        diversity = len(set(sol)) / len(sol)\n        scores.append(norm_obj1 * 0.4 + norm_obj2 * 0.4 + diversity * 0.2)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8645802214193887,
            0.5170796513557434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for _, obj in archive]\n    obj1 = [o[0] for o in objectives]\n    obj2 = [o[1] for o in objectives]\n\n    max_obj1, min_obj1 = max(obj1), min(obj1)\n    max_obj2, min_obj2 = max(obj2), min(obj2)\n\n    scores = []\n    for i, (sol, (o1, o2)) in enumerate(archive):\n        norm_obj1 = (o1 - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n        norm_obj2 = (o2 - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n        diversity = len(set(sol)) / len(sol)\n        scores.append(norm_obj1 * 0.4 + norm_obj2 * 0.4 + diversity * 0.2)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm prioritizes solutions with the highest potential for improvement by using a score function that combines objective values and diversity metrics, then applies a hybrid local search operator that combines 4-opt with a novel segment rotation and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score function: prioritize solutions with highest objective values and diversity\n    def score(solution, objective):\n        cost1, cost2 = objective\n        diversity = np.sum(np.abs(np.diff(solution)))\n        return (cost1 + cost2) * diversity\n\n    scored_solutions = [(score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Hybrid local search: 4-opt with segment rotation and reinsertion\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    if random.random() < 0.5:\n        # Segment rotation\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n    else:\n        # Segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:d+1], segment, new_solution[d+1:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution structure diversity, then applies a novel hybrid local search operator combining adaptive k-opt moves with objective-aware segment reversal and reinsertion to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score and structural diversity\n    def score(solution, objective):\n        cost1, cost2 = objective\n        structural_diversity = np.sum(np.abs(np.diff(solution))) + np.sum(np.abs(np.diff(np.diff(solution))))\n        return (cost1 + cost2) * structural_diversity\n\n    scored_solutions = [(score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive k-opt with objective-aware segment operations\n    k = min(5, n-1)\n    points = sorted(random.sample(range(n), k))\n\n    # Determine operation type based on objective balance\n    cost1, cost2 = archive[0][1]\n    if cost1 > cost2:\n        # Prefer segment reversal for cost1 improvement\n        i, j = points[0], points[-1]\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Prefer segment reinsertion for cost2 improvement\n        i, j = points[1], points[-2]\n        segment = new_solution[i:j+1]\n        insert_pos = random.choice([p for p in range(n) if p not in range(i, j+1)])\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Objective-aware edge swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if abs(i-j) > 1:\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] -\n                     distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[i+1]])\n            delta2 = (distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n            if delta1 < 0 or delta2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9055286336157244,
            1.8557729721069336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score and structural diversity\n    def score(solution, objective):\n        cost1, cost2 = objective\n        structural_diversity = np.sum(np.abs(np.diff(solution))) + np.sum(np.abs(np.diff(np.diff(solution))))\n        return (cost1 + cost2) * structural_diversity\n\n    scored_solutions = [(score(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(reverse=True, key=lambda x: x[0])\n    base_solution = scored_solutions[0][1].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive k-opt with objective-aware segment operations\n    k = min(5, n-1)\n    points = sorted(random.sample(range(n), k))\n\n    # Determine operation type based on objective balance\n    cost1, cost2 = archive[0][1]\n    if cost1 > cost2:\n        # Prefer segment reversal for cost1 improvement\n        i, j = points[0], points[-1]\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Prefer segment reinsertion for cost2 improvement\n        i, j = points[1], points[-2]\n        segment = new_solution[i:j+1]\n        insert_pos = random.choice([p for p in range(n) if p not in range(i, j+1)])\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Objective-aware edge swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if abs(i-j) > 1:\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i+1]] -\n                     distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[i+1]])\n            delta2 = (distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n            if delta1 < 0 or delta2 < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify non-dominated solutions, then applies a hybrid local search combining segment reversal with adaptive node relocation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = new_solution[i:j+1]\n        new_segment = segment[::-1]\n        new_solution[i:j+1] = new_segment\n\n        # Check if reversal improves either objective\n        cost1_old = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost1_new = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        cost2_old = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        cost2_new = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if cost1_new > cost1_old and cost2_new > cost2_old:\n            new_solution[i:j+1] = segment\n\n    # Adaptive node relocation\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9077999803093265,
            0.45672422647476196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, i])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding_distances[sorted_order[j]] += (sorted_objectives[sorted_order[j+1], i] - sorted_objectives[sorted_order[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = new_solution[i:j+1]\n        new_segment = segment[::-1]\n        new_solution[i:j+1] = new_segment\n\n        # Check if reversal improves either objective\n        cost1_old = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost1_new = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        cost2_old = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        cost2_new = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if cost1_new > cost1_old and cost2_new > cost2_old:\n            new_solution[i:j+1] = segment\n\n    # Adaptive node relocation\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = np.random.randint(1, n-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines an adaptive segment rotation with a dynamic node reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    rotation_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        c = random.randint(0, n-1)\n        node = new_solution[c]\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [node]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation_amount)\n\n    return new_solution\n\n",
        "score": [
            -0.9387007969809918,
            0.34488093852996826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    rotation_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        c = random.randint(0, n-1)\n        node = new_solution[c]\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [node]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation_amount)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a novel local search strategy combining adaptive node relocation with multi-objective edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation with objective-aware selection\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n\n        # Calculate cost changes for both objectives\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Multi-objective edge reversal\n    if n >= 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n\n        # Calculate cost changes for both objectives\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            # Reverse the segment between i and j\n            if i < j:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                segment = np.concatenate([new_solution[i:], new_solution[:j+1]])\n                reversed_segment = segment[::-1]\n                new_solution = np.concatenate([reversed_segment[len(segment)-j-1:], reversed_segment[:len(segment)-j-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.777728472409219,
            0.5967714190483093
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation with objective-aware selection\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n\n        # Calculate cost changes for both objectives\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Multi-objective edge reversal\n    if n >= 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n\n        # Calculate cost changes for both objectives\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            # Reverse the segment between i and j\n            if i < j:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                segment = np.concatenate([new_solution[i:], new_solution[:j+1]])\n                reversed_segment = segment[::-1]\n                new_solution = np.concatenate([reversed_segment[len(segment)-j-1:], reversed_segment[:len(segment)-j-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a dynamic segment insertion with a probabilistic edge reversal strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    if random.random() < 0.5:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        segment = new_solution[a:b+1]\n        segment = segment[::-1]\n        new_solution[a:b+1] = segment\n\n    if random.random() < 0.3:\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8320280658839582,
            0.19129258394241333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    if random.random() < 0.5:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        segment = new_solution[a:b+1]\n        segment = segment[::-1]\n        new_solution[a:b+1] = segment\n\n    if random.random() < 0.3:\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{The new algorithm prioritizes solutions with high potential for improvement by scoring them based on their objective values and diversity, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = []\n    for sol, obj in archive:\n        score = (obj[0] + obj[1]) * (1 + random.uniform(-0.2, 0.2))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8503929630818082,
            0.20050692558288574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = []\n    for sol, obj in archive:\n        score = (obj[0] + obj[1]) * (1 + random.uniform(-0.2, 0.2))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n",
        "score": [
            -0.898815676902424,
            0.09545725584030151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{The new algorithm prioritizes solutions with high diversity in their objective values, applies a hybrid local search combining segment reversal with a probabilistic insertion strategy to explore non-standard neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        selected_idx = np.argmax([(obj1 - obj2)**2 for obj1, obj2 in objectives])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        node = new_solution[d]\n        new_solution = np.concatenate([new_solution[:c], [node], new_solution[c:d], new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9321202960117749,
            0.4441852569580078
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        selected_idx = np.argmax([(obj1 - obj2)**2 for obj1, obj2 in objectives])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        node = new_solution[d]\n        new_solution = np.concatenate([new_solution[:c], [node], new_solution[c:d], new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal with objective-aware edge swapping and insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n        # Calculate cost changes\n        cost1_change = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] -\n                        distance_matrix_1[new_solution[a-1], segment[0]] - distance_matrix_1[segment[-1], new_solution[(b+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] -\n                        distance_matrix_2[new_solution[a-1], segment[0]] - distance_matrix_2[segment[-1], new_solution[(b+1)%n]])\n\n        # Revert if it worsens both objectives\n        if cost1_change > 0 and cost2_change > 0:\n            new_solution[a:b+1] = segment  # Undo the reversal\n\n    # Objective-aware edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]))\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]))\n\n        # Apply swapping if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Objective-aware insertion\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        if i == j:\n            j = (j + 1) % n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Calculate cost changes\n        cost1_change = (distance_matrix_1[new_solution[j-1], node] + distance_matrix_1[node, new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], node] - distance_matrix_1[node, new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[j-1], node] + distance_matrix_2[node, new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], node] - distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        # Revert if it worsens both objectives\n        if cost1_change > 0 and cost2_change > 0:\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8547316834578247,
            0.26517218351364136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n        # Calculate cost changes\n        cost1_change = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] -\n                        distance_matrix_1[new_solution[a-1], segment[0]] - distance_matrix_1[segment[-1], new_solution[(b+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] -\n                        distance_matrix_2[new_solution[a-1], segment[0]] - distance_matrix_2[segment[-1], new_solution[(b+1)%n]])\n\n        # Revert if it worsens both objectives\n        if cost1_change > 0 and cost2_change > 0:\n            new_solution[a:b+1] = segment  # Undo the reversal\n\n    # Objective-aware edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]))\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]))\n\n        # Apply swapping if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Objective-aware insertion\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        if i == j:\n            j = (j + 1) % n\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Calculate cost changes\n        cost1_change = (distance_matrix_1[new_solution[j-1], node] + distance_matrix_1[node, new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], node] - distance_matrix_1[node, new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[j-1], node] + distance_matrix_2[node, new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], node] - distance_matrix_2[node, new_solution[(i+1)%n]])\n\n        # Revert if it worsens both objectives\n        if cost1_change > 0 and cost2_change > 0:\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a novel \"adaptive segment inversion\" combined with a \"distance-aware node insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objective values and diversity\n    weights = np.random.uniform(0.3, 0.7)\n    archive_scores = [(weights * obj[0] + (1 - weights) * obj[1], idx) for idx, (sol, obj) in enumerate(archive)]\n    sorted_scores = sorted(archive_scores, key=lambda x: x[0])\n    candidate_indices = [idx for (score, idx) in sorted_scores[:min(5, len(archive))]]\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion: Invert a segment based on distance characteristics\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Check if segment should be inverted based on distance in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(segment_length-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(segment_length-1))\n        if segment_cost1 + segment_cost2 > np.random.uniform(0.7, 1.3) * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n    # Distance-aware node insertion: Move a node to a position that improves both objectives\n    if n > 5:\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        best_pos = 0\n        best_improvement = 0\n        for i in range(n-1):\n            # Calculate potential improvement in both objectives\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i]\n            current_cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                           distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            original_cost = distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]\n\n            improvement = original_cost - current_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.897813349980876,
            0.273406982421875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objective values and diversity\n    weights = np.random.uniform(0.3, 0.7)\n    archive_scores = [(weights * obj[0] + (1 - weights) * obj[1], idx) for idx, (sol, obj) in enumerate(archive)]\n    sorted_scores = sorted(archive_scores, key=lambda x: x[0])\n    candidate_indices = [idx for (score, idx) in sorted_scores[:min(5, len(archive))]]\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion: Invert a segment based on distance characteristics\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Check if segment should be inverted based on distance in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(segment_length-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(segment_length-1))\n        if segment_cost1 + segment_cost2 > np.random.uniform(0.7, 1.3) * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n    # Distance-aware node insertion: Move a node to a position that improves both objectives\n    if n > 5:\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        best_pos = 0\n        best_improvement = 0\n        for i in range(n-1):\n            # Calculate potential improvement in both objectives\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i]\n            current_cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                           distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            original_cost = distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]\n\n            improvement = original_cost - current_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel \"node chain inversion\" with a \"multi-segment crossover\" to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high potential for improvement\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node chain inversion + multi-segment crossover\n    if n >= 4:\n        # Node chain inversion: Invert a chain of nodes between two randomly selected points\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Multi-segment crossover: Select two non-overlapping segments and swap them\n        if n >= 8:\n            first_start = random.randint(0, n//2 - 2)\n            first_length = random.randint(2, min(5, n//2 - first_start))\n            second_start = random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8606261978397238,
            0.5033385157585144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high potential for improvement\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Node chain inversion + multi-segment crossover\n    if n >= 4:\n        # Node chain inversion: Invert a chain of nodes between two randomly selected points\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Multi-segment crossover: Select two non-overlapping segments and swap them\n        if n >= 8:\n            first_start = random.randint(0, n//2 - 2)\n            first_length = random.randint(2, min(5, n//2 - first_start))\n            second_start = random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9227092135739206,
            0.18014776706695557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.roll(new_solution, shift=random.randint(1, n-1))\n        new_solution[:len(segment)] = segment\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9344956458072664,
            0.2711772918701172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.roll(new_solution, shift=random.randint(1, n-1))\n        new_solution[:len(segment)] = segment\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment inversion with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.7:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.7:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.8616292411628926,
            0.23517775535583496
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.7:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([new_solution[:c], new_solution[d:d+1], new_solution[c:d], new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8670194226616625,
            0.21952831745147705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([new_solution[:c], new_solution[d:d+1], new_solution[c:d], new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search strategy that combines adaptive segment reversal with objective-aware edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score (0.7 for first objective, 0.3 for second)\n    selected_idx = np.argmin([0.7*obj[0] + 0.3*obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with length based on objective balance\n    if n >= 4:\n        obj_balance = archive[selected_idx][1][0] / (archive[selected_idx][1][0] + archive[selected_idx][1][1])\n        segment_length = max(2, int(n * obj_balance))\n        a = np.random.randint(0, n - segment_length + 1)\n        b = a + segment_length - 1\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Objective-aware edge swapping\n    if n >= 4:\n        for _ in range(2):\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                            distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7739290396056692,
            0.30922091007232666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best weighted objective score (0.7 for first objective, 0.3 for second)\n    selected_idx = np.argmin([0.7*obj[0] + 0.3*obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with length based on objective balance\n    if n >= 4:\n        obj_balance = archive[selected_idx][1][0] / (archive[selected_idx][1][0] + archive[selected_idx][1][1])\n        segment_length = max(2, int(n * obj_balance))\n        a = np.random.randint(0, n - segment_length + 1)\n        b = a + segment_length - 1\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Objective-aware edge swapping\n    if n >= 4:\n        for _ in range(2):\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                            distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"adaptive segment inversion and reinsertion\" local search that dynamically adjusts segment lengths and insertion points to explore the solution space more effectively while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion and reinsertion\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Remove the segment and reinsert it at a new position\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, inverted_segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8259588408123305,
            0.258918821811676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion and reinsertion\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Remove the segment and reinsert it at a new position\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, inverted_segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy that combines adaptive segment reversal with probabilistic edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with best combined score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_obj[:, 0] * 0.7 + normalized_obj[:, 1] * 0.3\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if n >= 4:\n        segment_length = min(4, n // 2)\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length - 1\n        segment = new_solution[a:b+1]\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                        distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[a], new_solution[(a+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[a], new_solution[(a+1)%n]])\n        # Apply reversal if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[a:b+1] = segment[::-1]\n\n    # Probabilistic edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]))\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]))\n        # Apply swap with probability based on cost improvement\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif np.random.random() < 0.1:  # Small probability for non-improving moves\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8365311119545054,
            0.6271719932556152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and select solution with best combined score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = normalized_obj[:, 0] * 0.7 + normalized_obj[:, 1] * 0.3\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware selection\n    if n >= 4:\n        segment_length = min(4, n // 2)\n        a = np.random.randint(0, n - segment_length)\n        b = a + segment_length - 1\n        segment = new_solution[a:b+1]\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                        distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[a], new_solution[(a+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[a], new_solution[(a+1)%n]])\n        # Apply reversal if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[a:b+1] = segment[::-1]\n\n    # Probabilistic edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]))\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]))\n        # Apply swap with probability based on cost improvement\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif np.random.random() < 0.1:  # Small probability for non-improving moves\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n",
        "score": [
            -0.8700230190622537,
            0.09801578521728516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel hybrid local search strategy that combines a dynamic node clustering with an adaptive segment rotation to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Dynamic node clustering\n    cluster_size = max(2, n // 4)\n    clusters = [new_solution[i:i+cluster_size] for i in range(0, n, cluster_size)]\n\n    # Adaptive segment rotation\n    if len(clusters) > 1:\n        k = np.random.randint(1, len(clusters))\n        rotated_segment = clusters[k][-1:] + clusters[k][:-1]\n        new_solution = np.concatenate([new_solution[:k*cluster_size], rotated_segment, new_solution[(k+1)*cluster_size:]])\n\n    # Feasibility check\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9667891052661839,
            4.435021460056305
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Dynamic node clustering\n    cluster_size = max(2, n // 4)\n    clusters = [new_solution[i:i+cluster_size] for i in range(0, n, cluster_size)]\n\n    # Adaptive segment rotation\n    if len(clusters) > 1:\n        k = np.random.randint(1, len(clusters))\n        rotated_segment = clusters[k][-1:] + clusters[k][:-1]\n        new_solution = np.concatenate([new_solution[:k*cluster_size], rotated_segment, new_solution[(k+1)*cluster_size:]])\n\n    # Feasibility check\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8069421419308951,
            0.19320589303970337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"node cluster relocation\" with an \"objective-aware edge swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node cluster relocation + objective-aware edge swap\n    if n > 4:\n        # Node cluster relocation: Select a cluster of 2-4 consecutive nodes and relocate them to a different position\n        cluster_length = np.random.randint(2, min(5, n))\n        cluster_start = np.random.randint(0, n - cluster_length)\n        cluster = new_solution[cluster_start:cluster_start+cluster_length]\n\n        # Remove cluster from current position\n        new_solution = np.concatenate([new_solution[:cluster_start], new_solution[cluster_start+cluster_length:]])\n\n        # Insert cluster at new position\n        insert_pos = np.random.randint(0, n - cluster_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], cluster, new_solution[insert_pos:]])\n\n        # Objective-aware edge swap: Swap edges based on which objective space they improve\n        if n > 6:\n            # Select two edges to swap\n            edge1 = np.random.randint(0, n-1)\n            edge2 = np.random.randint(0, n-1)\n\n            # Calculate cost before swap\n            cost1_before = distance_matrix_1[new_solution[edge1], new_solution[edge1+1]] + distance_matrix_2[new_solution[edge1], new_solution[edge1+1]]\n            cost2_before = distance_matrix_1[new_solution[edge2], new_solution[edge2+1]] + distance_matrix_2[new_solution[edge2], new_solution[edge2+1]]\n\n            # Swap edges\n            new_solution[edge1+1], new_solution[edge2+1] = new_solution[edge2+1], new_solution[edge1+1]\n\n            # Calculate cost after swap\n            cost1_after = distance_matrix_1[new_solution[edge1], new_solution[edge1+1]] + distance_matrix_2[new_solution[edge1], new_solution[edge1+1]]\n            cost2_after = distance_matrix_1[new_solution[edge2], new_solution[edge2+1]] + distance_matrix_2[new_solution[edge2], new_solution[edge2+1]]\n\n            # Revert swap if it worsens both objectives\n            if cost1_after + cost2_after > cost1_before + cost2_before:\n                new_solution[edge1+1], new_solution[edge2+1] = new_solution[edge2+1], new_solution[edge1+1]\n\n    return new_solution\n\n",
        "score": [
            -0.9151725004956505,
            0.22164767980575562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node cluster relocation + objective-aware edge swap\n    if n > 4:\n        # Node cluster relocation: Select a cluster of 2-4 consecutive nodes and relocate them to a different position\n        cluster_length = np.random.randint(2, min(5, n))\n        cluster_start = np.random.randint(0, n - cluster_length)\n        cluster = new_solution[cluster_start:cluster_start+cluster_length]\n\n        # Remove cluster from current position\n        new_solution = np.concatenate([new_solution[:cluster_start], new_solution[cluster_start+cluster_length:]])\n\n        # Insert cluster at new position\n        insert_pos = np.random.randint(0, n - cluster_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], cluster, new_solution[insert_pos:]])\n\n        # Objective-aware edge swap: Swap edges based on which objective space they improve\n        if n > 6:\n            # Select two edges to swap\n            edge1 = np.random.randint(0, n-1)\n            edge2 = np.random.randint(0, n-1)\n\n            # Calculate cost before swap\n            cost1_before = distance_matrix_1[new_solution[edge1], new_solution[edge1+1]] + distance_matrix_2[new_solution[edge1], new_solution[edge1+1]]\n            cost2_before = distance_matrix_1[new_solution[edge2], new_solution[edge2+1]] + distance_matrix_2[new_solution[edge2], new_solution[edge2+1]]\n\n            # Swap edges\n            new_solution[edge1+1], new_solution[edge2+1] = new_solution[edge2+1], new_solution[edge1+1]\n\n            # Calculate cost after swap\n            cost1_after = distance_matrix_1[new_solution[edge1], new_solution[edge1+1]] + distance_matrix_2[new_solution[edge1], new_solution[edge1+1]]\n            cost2_after = distance_matrix_1[new_solution[edge2], new_solution[edge2+1]] + distance_matrix_2[new_solution[edge2], new_solution[edge2+1]]\n\n            # Revert swap if it worsens both objectives\n            if cost1_after + cost2_after > cost1_before + cost2_before:\n                new_solution[edge1+1], new_solution[edge2+1] = new_solution[edge2+1], new_solution[edge1+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding distance-based selection strategy, then applies a hybrid local search combining adaptive node relocation with objective-aware edge reversal to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Objective-aware edge reversal\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n            if (cost1_change < 0 and cost2_change < 0) or np.random.random() < 0.3:\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6445357220613117,
            0.5634241700172424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            if objectives[sorted_indices[-1], i] == objectives[sorted_indices[0], i]:\n                crowding_distances[sorted_indices[j]] += 0\n            else:\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Objective-aware edge reversal\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n            if (cost1_change < 0 and cost2_change < 0) or np.random.random() < 0.3:\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric, then applies a hybrid local search strategy combining path relinking with adaptive 2.5-opt moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_obj1 = np.sort(objectives[:, 0])\n    sorted_obj2 = np.sort(objectives[:, 1])\n\n    crowding = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding[i] = np.inf\n        else:\n            crowding[i] = (sorted_obj1[i+1] - sorted_obj1[i-1]) / (sorted_obj1[-1] - sorted_obj1[0]) + \\\n                          (sorted_obj2[i+1] - sorted_obj2[i-1]) / (sorted_obj2[-1] - sorted_obj2[0])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path relinking with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            segment = new_solution[i:j+1]\n            np.random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n    # Adaptive 2.5-opt move\n    if n >= 5:\n        i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n        if abs(i-j) > 1 and abs(j-k) > 1 and abs(i-k) > 1:\n            # Try different permutations of the segment\n            segments = [\n                np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n                np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]])\n            ]\n\n            best_segment = None\n            min_cost = np.inf\n            for seg in segments:\n                cost1 = sum(distance_matrix_1[seg[l], seg[l+1]] for l in range(n-1)) + distance_matrix_1[seg[-1], seg[0]]\n                cost2 = sum(distance_matrix_2[seg[l], seg[l+1]] for l in range(n-1)) + distance_matrix_2[seg[-1], seg[0]]\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_segment = seg.copy()\n\n            if best_segment is not None:\n                new_solution = best_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8653198639551104,
            0.27776408195495605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    sorted_obj1 = np.sort(objectives[:, 0])\n    sorted_obj2 = np.sort(objectives[:, 1])\n\n    crowding = np.zeros(len(archive))\n    for i in range(len(archive)):\n        if i == 0 or i == len(archive) - 1:\n            crowding[i] = np.inf\n        else:\n            crowding[i] = (sorted_obj1[i+1] - sorted_obj1[i-1]) / (sorted_obj1[-1] - sorted_obj1[0]) + \\\n                          (sorted_obj2[i+1] - sorted_obj2[i-1]) / (sorted_obj2[-1] - sorted_obj2[0])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Path relinking with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            segment = new_solution[i:j+1]\n            np.random.shuffle(segment)\n            new_solution[i:j+1] = segment\n\n    # Adaptive 2.5-opt move\n    if n >= 5:\n        i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n        if abs(i-j) > 1 and abs(j-k) > 1 and abs(i-k) > 1:\n            # Try different permutations of the segment\n            segments = [\n                np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n                np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]])\n            ]\n\n            best_segment = None\n            min_cost = np.inf\n            for seg in segments:\n                cost1 = sum(distance_matrix_1[seg[l], seg[l+1]] for l in range(n-1)) + distance_matrix_1[seg[-1], seg[0]]\n                cost2 = sum(distance_matrix_2[seg[l], seg[l+1]] for l in range(n-1)) + distance_matrix_2[seg[-1], seg[0]]\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_segment = seg.copy()\n\n            if best_segment is not None:\n                new_solution = best_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"node cluster inversion\" local search that reverses segments of nodes based on their spatial proximity in both objective spaces, ensuring feasibility through careful segment selection and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Node cluster inversion: Find segments of nodes that are close in both spaces\n    for _ in range(3):  # Try up to 3 segment inversions\n        # Randomly select a starting point\n        start = np.random.randint(0, n)\n        segment_length = min(3, n - start)\n\n        # Check if nodes are close in both spaces\n        close_in_both = True\n        for i in range(start, start + segment_length - 1):\n            node1 = new_solution[i]\n            node2 = new_solution[i+1]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n\n            if dist1 > np.mean(distance_matrix_1) or dist2 > np.mean(distance_matrix_2):\n                close_in_both = False\n                break\n\n        if close_in_both and segment_length > 1:\n            # Reverse the segment if it's close in both spaces\n            segment = new_solution[start:start+segment_length]\n            reversed_segment = segment[::-1]\n            new_solution[start:start+segment_length] = reversed_segment\n\n    # Validate the solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8484223789131942,
            0.286406934261322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Node cluster inversion: Find segments of nodes that are close in both spaces\n    for _ in range(3):  # Try up to 3 segment inversions\n        # Randomly select a starting point\n        start = np.random.randint(0, n)\n        segment_length = min(3, n - start)\n\n        # Check if nodes are close in both spaces\n        close_in_both = True\n        for i in range(start, start + segment_length - 1):\n            node1 = new_solution[i]\n            node2 = new_solution[i+1]\n            dist1 = distance_matrix_1[node1, node2]\n            dist2 = distance_matrix_2[node1, node2]\n\n            if dist1 > np.mean(distance_matrix_1) or dist2 > np.mean(distance_matrix_2):\n                close_in_both = False\n                break\n\n        if close_in_both and segment_length > 1:\n            # Reverse the segment if it's close in both spaces\n            segment = new_solution[start:start+segment_length]\n            reversed_segment = segment[::-1]\n            new_solution[start:start+segment_length] = reversed_segment\n\n    # Validate the solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment reversal\" with a \"multi-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))  # Top 5 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment reversal + multi-segment rotation\n    if n > 4:\n        # Node segment reversal: Select a segment of 2-5 nodes and reverse it\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Multi-segment rotation: Select 2-3 segments and rotate them in the tour\n        if n > 6:\n            num_segments = np.random.randint(2, min(4, n//3))\n            segment_starts = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n            segment_starts = [0] + segment_starts + [n]\n            segments = [new_solution[segment_starts[i]:segment_starts[i+1]] for i in range(len(segment_starts)-1)]\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n    return new_solution\n\n",
        "score": [
            -0.9588545110482705,
            0.21939986944198608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))  # Top 5 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment reversal + multi-segment rotation\n    if n > 4:\n        # Node segment reversal: Select a segment of 2-5 nodes and reverse it\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Multi-segment rotation: Select 2-3 segments and rotate them in the tour\n        if n > 6:\n            num_segments = np.random.randint(2, min(4, n//3))\n            segment_starts = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n            segment_starts = [0] + segment_starts + [n]\n            segments = [new_solution[segment_starts[i]:segment_starts[i+1]] for i in range(len(segment_starts)-1)]\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment inversion with a dynamic reordering strategy based on the relative improvement potential in both objective spaces to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.8:\n        improvement_potential = []\n        for i in range(n):\n            if i == 0:\n                prev = n - 1\n            else:\n                prev = i - 1\n            next_node = (i + 1) % n\n            current_cost = (distance_matrix_1[prev, i] + distance_matrix_1[i, next_node] +\n                            distance_matrix_2[prev, i] + distance_matrix_2[i, next_node])\n            swapped_cost = (distance_matrix_1[prev, next_node] + distance_matrix_1[next_node, i] +\n                            distance_matrix_2[prev, next_node] + distance_matrix_2[next_node, i])\n            improvement_potential.append(current_cost - swapped_cost)\n\n        if improvement_potential:\n            best_node = np.argmax(improvement_potential)\n            if best_node != 0 and best_node < n - 1:\n                new_solution[best_node], new_solution[best_node + 1] = new_solution[best_node + 1], new_solution[best_node]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9364854193280494,
            0.2195870280265808
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.8:\n        improvement_potential = []\n        for i in range(n):\n            if i == 0:\n                prev = n - 1\n            else:\n                prev = i - 1\n            next_node = (i + 1) % n\n            current_cost = (distance_matrix_1[prev, i] + distance_matrix_1[i, next_node] +\n                            distance_matrix_2[prev, i] + distance_matrix_2[i, next_node])\n            swapped_cost = (distance_matrix_1[prev, next_node] + distance_matrix_1[next_node, i] +\n                            distance_matrix_2[prev, next_node] + distance_matrix_2[next_node, i])\n            improvement_potential.append(current_cost - swapped_cost)\n\n        if improvement_potential:\n            best_node = np.argmax(improvement_potential)\n            if best_node != 0 and best_node < n - 1:\n                new_solution[best_node], new_solution[best_node + 1] = new_solution[best_node + 1], new_solution[best_node]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of Pareto dominance and crowding distance, then applies a hybrid local search combining a novel \"segment-wise perturbation\" with a \"directional swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine Pareto dominance and crowding distance\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n        distances = [0.0] * len(solutions)\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for _, obj in solutions])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(solutions)-1):\n                distances[sorted_idx[i]] += (solutions[sorted_idx[i+1]][1][m] - solutions[sorted_idx[i-1]][1][m])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment-wise perturbation + directional swap\n    if n > 4:\n        # Segment-wise perturbation: Select a segment and apply a random transformation\n        segment_start = np.random.randint(0, n-3)\n        segment_length = np.random.randint(2, min(5, n-segment_start))\n        segment = new_solution[segment_start:segment_start+segment_length]\n\n        if np.random.random() < 0.5:\n            # Reverse segment\n            new_solution[segment_start:segment_start+segment_length] = segment[::-1]\n        else:\n            # Rotate segment\n            rotation = np.random.randint(1, segment_length)\n            new_solution[segment_start:segment_start+segment_length] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Directional swap: Swap nodes based on their relative positions in the two spaces\n        if n > 6:\n            i = np.random.randint(0, n-2)\n            j = np.random.randint(i+1, n)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate position differences in both spaces\n            pos_i = instance[node_i]\n            pos_j = instance[node_j]\n            diff_1 = np.linalg.norm(pos_i[:2] - pos_j[:2])\n            diff_2 = np.linalg.norm(pos_i[2:] - pos_j[2:])\n\n            if diff_1 > diff_2:\n                # Swap if first space is more different\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6505030637715534,
            0.2723642587661743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine Pareto dominance and crowding distance\n    def crowding_distance(solutions):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n        distances = [0.0] * len(solutions)\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for _, obj in solutions])\n            distances[sorted_idx[0]] = float('inf')\n            distances[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(solutions)-1):\n                distances[sorted_idx[i]] += (solutions[sorted_idx[i+1]][1][m] - solutions[sorted_idx[i-1]][1][m])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment-wise perturbation + directional swap\n    if n > 4:\n        # Segment-wise perturbation: Select a segment and apply a random transformation\n        segment_start = np.random.randint(0, n-3)\n        segment_length = np.random.randint(2, min(5, n-segment_start))\n        segment = new_solution[segment_start:segment_start+segment_length]\n\n        if np.random.random() < 0.5:\n            # Reverse segment\n            new_solution[segment_start:segment_start+segment_length] = segment[::-1]\n        else:\n            # Rotate segment\n            rotation = np.random.randint(1, segment_length)\n            new_solution[segment_start:segment_start+segment_length] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        # Directional swap: Swap nodes based on their relative positions in the two spaces\n        if n > 6:\n            i = np.random.randint(0, n-2)\n            j = np.random.randint(i+1, n)\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate position differences in both spaces\n            pos_i = instance[node_i]\n            pos_j = instance[node_j]\n            diff_1 = np.linalg.norm(pos_i[:2] - pos_j[:2])\n            diff_2 = np.linalg.norm(pos_i[2:] - pos_j[2:])\n\n            if diff_1 > diff_2:\n                # Swap if first space is more different\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{The new algorithm selects a solution from the archive based on a score combining both objectives and their improvement potential, then applies a hybrid local search combining a novel segment insertion with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        n = len(sol)\n        total_cost = cost1 + cost2\n        improvement_potential = (np.sum(distance_matrix_1[sol, sol]) + np.sum(distance_matrix_2[sol, sol])) / (2 * n)\n        scores.append(total_cost / improvement_potential)\n\n    selected_idx = np.argmin(scores) if random.random() < 0.8 else random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n    else:\n        c = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:c+len(segment)], new_solution[c+len(segment):]])\n\n    if random.random() < 0.6:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8265693060628023,
            0.44477272033691406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        n = len(sol)\n        total_cost = cost1 + cost2\n        improvement_potential = (np.sum(distance_matrix_1[sol, sol]) + np.sum(distance_matrix_2[sol, sol])) / (2 * n)\n        scores.append(total_cost / improvement_potential)\n\n    selected_idx = np.argmin(scores) if random.random() < 0.8 else random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:a], segment[::-1], new_solution[b+1:]])\n    else:\n        c = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:c+len(segment)], new_solution[c+len(segment):]])\n\n    if random.random() < 0.6:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment rotation with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    rotation_amount = random.randint(1, b - a)\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, rotation_amount)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9601362894719456,
            0.18925809860229492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel \"node swapping\" with a \"multi-segment reordering\" strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 4 and random.random() < 0.6:\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[d+1:c+1] if c < d else new_solution[d+1:c]\n        new_solution = np.concatenate([new_solution[:c], segment2, segment1, new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9108755755114819,
            0.18737345933914185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 4 and random.random() < 0.6:\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[d+1:c+1] if c < d else new_solution[d+1:c]\n        new_solution = np.concatenate([new_solution[:c], segment2, segment1, new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This algorithm selects a non-dominated solution from the archive based on Pareto dominance, then applies a hybrid local search combining adaptive segment rotation and objective-aware edge swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution\n    selected_idx = np.random.choice([i for i, (sol, obj) in enumerate(archive)\n                                    if not any(obj[0] > o[0] and obj[1] >= o[1] or obj[0] >= o[0] and obj[1] > o[1]\n                                               for _, o in archive)])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Objective-aware edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9144701833173761,
            0.3069930076599121
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution\n    selected_idx = np.random.choice([i for i, (sol, obj) in enumerate(archive)\n                                    if not any(obj[0] > o[0] and obj[1] >= o[1] or obj[0] >= o[0] and obj[1] > o[1]\n                                               for _, o in archive)])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        k = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Objective-aware edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective score that prioritizes solutions with better performance in both objectives, then applies a novel local search strategy combining segment reversal with adaptive node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] * objectives[:, 1]  # Product of objectives as combined score\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    if n >= 4:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n        # Check if reversal improves both objectives\n        cost1_change = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] -\n                        distance_matrix_1[new_solution[a-1], new_solution[b]] - distance_matrix_1[segment[0], segment[-1]])\n\n        cost2_change = (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] -\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] - distance_matrix_2[segment[0], segment[-1]])\n\n        if cost1_change > 0 or cost2_change > 0:  # If reversal doesn't improve both, undo\n            new_solution[a:b+1] = segment\n\n    # Adaptive node reinsertion\n    if n >= 4:\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for j in range(1, n):\n            temp_solution = np.insert(new_solution, j, node)\n            cost1 = (distance_matrix_1[temp_solution[j-1], node] + distance_matrix_1[node, temp_solution[(j+1)%n]] -\n                     distance_matrix_1[temp_solution[j-1], temp_solution[j]] - distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]])\n\n            cost2 = (distance_matrix_2[temp_solution[j-1], node] + distance_matrix_2[node, temp_solution[(j+1)%n]] -\n                     distance_matrix_2[temp_solution[j-1], temp_solution[j]] - distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]])\n\n            combined_cost = cost1 + cost2\n            if combined_cost < best_score:\n                best_score = combined_cost\n                best_pos = j\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7029947189867021,
            0.4874558448791504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] * objectives[:, 1]  # Product of objectives as combined score\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with objective-aware selection\n    if n >= 4:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n        # Check if reversal improves both objectives\n        cost1_change = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] -\n                        distance_matrix_1[new_solution[a-1], new_solution[b]] - distance_matrix_1[segment[0], segment[-1]])\n\n        cost2_change = (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] -\n                        distance_matrix_2[new_solution[a-1], new_solution[b]] - distance_matrix_2[segment[0], segment[-1]])\n\n        if cost1_change > 0 or cost2_change > 0:  # If reversal doesn't improve both, undo\n            new_solution[a:b+1] = segment\n\n    # Adaptive node reinsertion\n    if n >= 4:\n        i = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for j in range(1, n):\n            temp_solution = np.insert(new_solution, j, node)\n            cost1 = (distance_matrix_1[temp_solution[j-1], node] + distance_matrix_1[node, temp_solution[(j+1)%n]] -\n                     distance_matrix_1[temp_solution[j-1], temp_solution[j]] - distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]])\n\n            cost2 = (distance_matrix_2[temp_solution[j-1], node] + distance_matrix_2[node, temp_solution[(j+1)%n]] -\n                     distance_matrix_2[temp_solution[j-1], temp_solution[j]] - distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]])\n\n            combined_cost = cost1 + cost2\n            if combined_cost < best_score:\n                best_score = combined_cost\n                best_pos = j\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{The algorithm selects a solution from the archive based on a dynamic score combining objective values and diversity, then applies a hybrid local search operator that combines a novel segment rotation with a probabilistic edge insertion strategy to generate diverse and high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        diversity = len(np.unique(sol)) / len(sol)\n        score = (cost1 + cost2) * (1 - diversity)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, k)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        if d - c > 1:\n            new_solution[c:d] = np.random.permutation(new_solution[c:d])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], k)\n\n    return new_solution\n\n",
        "score": [
            -0.8292007106873651,
            0.3207404613494873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        diversity = len(np.unique(sol)) / len(sol)\n        score = (cost1 + cost2) * (1 - diversity)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    k = random.randint(2, min(5, n//2))\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, k)\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        if d - c > 1:\n            new_solution[c:d] = np.random.permutation(new_solution[c:d])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], k)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection, then applies a hybrid local search combining adaptive 2-opt with node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding-distance based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = [archive[i] for i in range(len(archive))]  # Simplified for this example\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[i+1], m] == objectives[sorted_indices[i-1], m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 2-opt with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n        if i != j and abs(i-j) > 1:\n            # Calculate cost changes for both objectives\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i+1]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[j]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(i+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[j]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(i+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node relocation with objective-aware selection\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n\n        node = new_solution[i]\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.634630594835481,
            0.5027788281440735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding-distance based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = [archive[i] for i in range(len(archive))]  # Simplified for this example\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if objectives[sorted_indices[i+1], m] == objectives[sorted_indices[i-1], m]:\n                continue\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 2-opt with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n        if i != j and abs(i-j) > 1:\n            # Calculate cost changes for both objectives\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i+1]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[j]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(i+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[j]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(i+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node relocation with objective-aware selection\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n\n        node = new_solution[i]\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This new algorithm prioritizes solutions with high objective values by selecting the top 30% of solutions in the archive, then applies a hybrid local search that combines segment inversion with dynamic segment reordering and probabilistic edge swaps to explore diverse neighborhoods while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]), reverse=True)\n    top_30 = int(0.3 * len(archive_sorted))\n    selected_idx = random.randint(0, min(top_30, len(archive_sorted)) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    if random.random() < 0.7:\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5928692095430202,
            0.2668601870536804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]), reverse=True)\n    top_30 = int(0.3 * len(archive_sorted))\n    selected_idx = random.randint(0, min(top_30, len(archive_sorted)) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    if random.random() < 0.7:\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and spatial clustering, then applies a hybrid local search combining a novel \"multi-objective path inversion\" with an \"adaptive segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and spatial clustering\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))  # Top 5 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path inversion: Invert a segment based on combined cost improvement\n    if n > 3:\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+1, n)\n\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = new_solution[start:end+1][::-1]\n        temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    # Adaptive segment rotation: Rotate a segment based on spatial proximity\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n\n        # Calculate spatial center of the segment\n        segment_nodes = new_solution[start:start+segment_length]\n        center1 = np.mean(instance[segment_nodes, :2], axis=0)\n        center2 = np.mean(instance[segment_nodes, 2:], axis=0)\n\n        # Find closest node in the tour to the segment center\n        all_nodes = np.arange(n)\n        other_nodes = np.setdiff1d(all_nodes, segment_nodes)\n        distances1 = np.linalg.norm(instance[other_nodes, :2] - center1, axis=1)\n        distances2 = np.linalg.norm(instance[other_nodes, 2:] - center2, axis=1)\n        combined_distances = distances1 + distances2\n        closest_idx = np.argmin(combined_distances)\n        closest_node = other_nodes[closest_idx]\n\n        # Insert segment after the closest node\n        closest_pos = np.where(new_solution == closest_node)[0][0]\n        if closest_pos < n - 1:\n            temp_solution = np.concatenate([\n                new_solution[:closest_pos+1],\n                new_solution[start:start+segment_length],\n                new_solution[closest_pos+1:start],\n                new_solution[start+segment_length:]\n            ])\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7365485853084106,
            0.4368489980697632
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and spatial clustering\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))  # Top 5 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path inversion: Invert a segment based on combined cost improvement\n    if n > 3:\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+1, n)\n\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = new_solution[start:end+1][::-1]\n        temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    # Adaptive segment rotation: Rotate a segment based on spatial proximity\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n\n        # Calculate spatial center of the segment\n        segment_nodes = new_solution[start:start+segment_length]\n        center1 = np.mean(instance[segment_nodes, :2], axis=0)\n        center2 = np.mean(instance[segment_nodes, 2:], axis=0)\n\n        # Find closest node in the tour to the segment center\n        all_nodes = np.arange(n)\n        other_nodes = np.setdiff1d(all_nodes, segment_nodes)\n        distances1 = np.linalg.norm(instance[other_nodes, :2] - center1, axis=1)\n        distances2 = np.linalg.norm(instance[other_nodes, 2:] - center2, axis=1)\n        combined_distances = distances1 + distances2\n        closest_idx = np.argmin(combined_distances)\n        closest_node = other_nodes[closest_idx]\n\n        # Insert segment after the closest node\n        closest_pos = np.where(new_solution == closest_node)[0][0]\n        if closest_pos < n - 1:\n            temp_solution = np.concatenate([\n                new_solution[:closest_pos+1],\n                new_solution[start:start+segment_length],\n                new_solution[closest_pos+1:start],\n                new_solution[start+segment_length:]\n            ])\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel \"node swapping\" with a \"multi-segment reordering\" strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 4 and random.random() < 0.6:\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[d+1:c+1] if c < d else new_solution[d+1:c]\n        new_solution = np.concatenate([new_solution[:c], segment2, segment1, new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware criterion, then applies a novel \"multi-objective segment insertion\" strategy that intelligently reinserts segments of the tour while considering both objectives, ensuring feasibility through careful validation of the generated neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (largest difference between objectives)\n    diversity_scores = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment insertion\n    if n >= 4:\n        # Select two random segments\n        a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:]\n\n        # Calculate potential cost changes\n        # Remove segment1 and segment2\n        cost1_remove = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[n-1], new_solution[0]])\n        cost1_original = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[n-1], new_solution[0]])\n\n        cost2_remove = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[n-1], new_solution[0]])\n        cost2_original = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[n-1], new_solution[0]])\n\n        # Insert segment2 before segment1\n        cost1_insert = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                       distance_matrix_1[new_solution[n-1], new_solution[0]])\n        cost2_insert = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                       distance_matrix_2[new_solution[n-1], new_solution[0]])\n\n        # Apply if at least one objective improves\n        if (cost1_insert < cost1_original or cost2_insert < cost2_original):\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9102974345068886,
            2.876756191253662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest diversity (largest difference between objectives)\n    diversity_scores = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment insertion\n    if n >= 4:\n        # Select two random segments\n        a, b = sorted(np.random.choice(range(1, n-2), size=2, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:]\n\n        # Calculate potential cost changes\n        # Remove segment1 and segment2\n        cost1_remove = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[n-1], new_solution[0]])\n        cost1_original = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[n-1], new_solution[0]])\n\n        cost2_remove = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[n-1], new_solution[0]])\n        cost2_original = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[n-1], new_solution[0]])\n\n        # Insert segment2 before segment1\n        cost1_insert = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                       distance_matrix_1[new_solution[n-1], new_solution[0]])\n        cost2_insert = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                       distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                       distance_matrix_2[new_solution[n-1], new_solution[0]])\n\n        # Apply if at least one objective improves\n        if (cost1_insert < cost1_original or cost2_insert < cost2_original):\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[b:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel \"node swapping\" with a \"multi-segment reordering\" strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 4 and random.random() < 0.6:\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[d+1:c+1] if c < d else new_solution[d+1:c]\n        new_solution = np.concatenate([new_solution[:c], segment2, segment1, new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if n > 4 and random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[d+1:c+1] if c < d else new_solution[d+1:c]\n        new_solution = np.concatenate([new_solution[:c], segment2, segment1, new_solution[d+1:]])\n\n        if random.random() < 0.5:\n            e = np.random.randint(1, n)\n            new_solution = np.roll(new_solution, e)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9385522978136468,
            0.2957383990287781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if n > 4 and random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[d+1:c+1] if c < d else new_solution[d+1:c]\n        new_solution = np.concatenate([new_solution[:c], segment2, segment1, new_solution[d+1:]])\n\n        if random.random() < 0.5:\n            e = np.random.randint(1, n)\n            new_solution = np.roll(new_solution, e)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining adaptive segment reversal and objective-aware edge insertion to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 3:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if n >= 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        if cost1_change >= 0 and cost2_change >= 0:\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j+1], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8154070991681677,
            0.11828166246414185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 3:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if n >= 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        if cost1_change >= 0 and cost2_change >= 0:\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j+1], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel \"node swapping\" with a \"multi-segment reordering\" strategy to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 4 and random.random() < 0.6:\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[d+1:c+1] if c < d else new_solution[d+1:c]\n        new_solution = np.concatenate([new_solution[:c], segment2, segment1, new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel \"multi-segment rotation\" strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    k = random.randint(2, min(4, n-1))\n    points = sorted(random.sample(range(n), k))\n    segments = []\n\n    for i in range(len(points)-1):\n        segments.append(new_solution[points[i]:points[i+1]])\n    segments.append(new_solution[points[-1]:])\n\n    rotated_segments = segments[1:] + [segments[0]]\n    new_solution = np.concatenate(rotated_segments)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.629640665012447,
            1.9515913128852844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    k = random.randint(2, min(4, n-1))\n    points = sorted(random.sample(range(n), k))\n    segments = []\n\n    for i in range(len(points)-1):\n        segments.append(new_solution[points[i]:points[i+1]])\n    segments.append(new_solution[points[-1]:])\n\n    rotated_segments = segments[1:] + [segments[0]]\n    new_solution = np.concatenate(rotated_segments)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted objective score that prioritizes the objective with the highest variance, then applies a hybrid local search operator combining adaptive segment reversal and probabilistic edge insertion to generate a feasible neighbor solution while balancing improvements in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances)\n    weighted_scores = weights[0] * objectives[:, 0] + weights[1] * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if np.random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7674616779132165,
            0.3698393702507019
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    variances = np.var(objectives, axis=0)\n    weights = variances / np.sum(variances)\n    weighted_scores = weights[0] * objectives[:, 0] + weights[1] * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if np.random.random() < 0.5:\n            new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel adaptive segment relocation and dynamic edge swapping strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    if random.random() < 0.7:\n        swap_pos1, swap_pos2 = sorted(random.sample(range(n), 2))\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8639053123050692,
            0.2525298595428467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    if random.random() < 0.7:\n        swap_pos1, swap_pos2 = sorted(random.sample(range(n), 2))\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment relinking and dynamic segment merging strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    if random.random() < 0.3:\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8482107592967914,
            0.24165719747543335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n    new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    if random.random() < 0.3:\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"cross-segment crossover\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + cross-segment crossover\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and invert it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment crossover: Select two non-overlapping segments and perform crossover\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            # Perform crossover between segments\n            crossover_point = np.random.randint(1, min(first_length, second_length))\n            new_first_segment = np.concatenate([first_segment[:crossover_point], second_segment[crossover_point:]])\n            new_second_segment = np.concatenate([second_segment[:crossover_point], first_segment[crossover_point:]])\n\n            new_solution[first_start:first_start+first_length] = new_first_segment\n            new_solution[second_start:second_start+second_length] = new_second_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8609738176800874,
            0.3188120126724243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + cross-segment crossover\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and invert it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment crossover: Select two non-overlapping segments and perform crossover\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            # Perform crossover between segments\n            crossover_point = np.random.randint(1, min(first_length, second_length))\n            new_first_segment = np.concatenate([first_segment[:crossover_point], second_segment[crossover_point:]])\n            new_second_segment = np.concatenate([second_segment[:crossover_point], first_segment[crossover_point:]])\n\n            new_solution[first_start:first_start+first_length] = new_first_segment\n            new_solution[second_start:second_start+second_length] = new_second_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9120682848191466,
            0.0805547833442688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a hybrid local search combining a \"node insertion\" with an \"inverse segment\" operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and solution quality\n    weights = np.array([0.4, 0.6])  # Weight for first and second objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node insertion + inverse segment\n    if n > 3:\n        # Node insertion: Move a node to a new position\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_pos = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n        # Inverse segment: Reverse a segment of the tour\n        if n > 5:\n            segment_start = np.random.randint(0, n - 2)\n            segment_end = np.random.randint(segment_start + 2, n)\n            new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8590671485214606,
            0.21508890390396118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and solution quality\n    weights = np.array([0.4, 0.6])  # Weight for first and second objective\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node insertion + inverse segment\n    if n > 3:\n        # Node insertion: Move a node to a new position\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_pos = np.random.randint(0, n)\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n        # Inverse segment: Reverse a segment of the tour\n        if n > 5:\n            segment_start = np.random.randint(0, n - 2)\n            segment_end = np.random.randint(segment_start + 2, n)\n            new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel hybrid local search strategy that combines a dynamic node clustering with an adaptive segment rotation to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Dynamic node clustering\n    cluster_size = max(2, n // 4)\n    clusters = [new_solution[i:i+cluster_size] for i in range(0, n, cluster_size)]\n\n    # Adaptive segment rotation\n    if len(clusters) > 1:\n        k = np.random.randint(1, len(clusters))\n        rotated_segment = clusters[k][-1:] + clusters[k][:-1]\n        new_solution = np.concatenate([new_solution[:k*cluster_size], rotated_segment, new_solution[(k+1)*cluster_size:]])\n\n    # Feasibility check\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{This algorithm first selects a solution from the archive using a Pareto-frontier based selection that prioritizes solutions with high potential for multi-objective improvement, then applies a novel \"objective-aware node reinsertion\" operator that dynamically reinserts nodes based on their relative performance in both objectives, ensuring feasibility while exploring diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-frontier based selection\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Objective-aware node reinsertion\n    for _ in range(max(1, n // 5)):\n        node_pos = np.random.randint(1, n-1)\n        node = new_solution[node_pos]\n\n        # Calculate objective improvement potential\n        prev_node = new_solution[node_pos-1]\n        next_node = new_solution[node_pos+1]\n        current_cost = distance_matrix_1[prev_node][node] + distance_matrix_1[node][next_node] + \\\n                       distance_matrix_2[prev_node][node] + distance_matrix_2[node][next_node]\n\n        # Find best reinsertion position\n        best_pos = node_pos\n        best_improvement = 0\n\n        for pos in range(1, n-1):\n            if pos == node_pos or pos == node_pos-1:\n                continue\n\n            prev_candidate = new_solution[pos-1]\n            next_candidate = new_solution[pos]\n            candidate_cost = distance_matrix_1[prev_candidate][node] + distance_matrix_1[node][next_candidate] + \\\n                            distance_matrix_2[prev_candidate][node] + distance_matrix_2[node][next_candidate]\n\n            improvement = current_cost - candidate_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != node_pos:\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9235279491086071,
            0.4775242805480957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-frontier based selection\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Objective-aware node reinsertion\n    for _ in range(max(1, n // 5)):\n        node_pos = np.random.randint(1, n-1)\n        node = new_solution[node_pos]\n\n        # Calculate objective improvement potential\n        prev_node = new_solution[node_pos-1]\n        next_node = new_solution[node_pos+1]\n        current_cost = distance_matrix_1[prev_node][node] + distance_matrix_1[node][next_node] + \\\n                       distance_matrix_2[prev_node][node] + distance_matrix_2[node][next_node]\n\n        # Find best reinsertion position\n        best_pos = node_pos\n        best_improvement = 0\n\n        for pos in range(1, n-1):\n            if pos == node_pos or pos == node_pos-1:\n                continue\n\n            prev_candidate = new_solution[pos-1]\n            next_candidate = new_solution[pos]\n            candidate_cost = distance_matrix_1[prev_candidate][node] + distance_matrix_1[node][next_candidate] + \\\n                            distance_matrix_2[prev_candidate][node] + distance_matrix_2[node][next_candidate]\n\n            improvement = current_cost - candidate_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != node_pos:\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Feasibility check\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This algorithm selects a solution from the archive based on a Pareto-dominance aware selection criterion, then applies a novel hybrid local search operator combining adaptive node relocation and objective-biased edge reversal to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance aware selection\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Objective-biased edge reversal\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            # Accept if at least one objective improves\n            if cost1_change <= 0 or cost2_change <= 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9447018503906377,
            0.3026915192604065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance aware selection\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Objective-biased edge reversal\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            # Accept if at least one objective improves\n            if cost1_change <= 0 or cost2_change <= 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and solution structure, then applies a hybrid local search combining a novel \"adaptive path inversion\" with a \"node cluster relocation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective quality and solution structure\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.mean(axis=1) * (1 + 0.1 * np.random.rand(len(archive)))\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion: Invert a segment with length based on objective improvement potential\n    if n > 3:\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n    # Node cluster relocation: Move a cluster of nodes to a better position\n    if n > 4:\n        cluster_size = np.random.randint(2, min(5, n // 3))\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Find best insertion position considering both objectives\n        best_pos = cluster_start\n        best_score = float('inf')\n\n        for pos in range(n - cluster_size):\n            if pos in range(cluster_start, cluster_start + cluster_size):\n                continue\n\n            # Calculate insertion cost for both objectives\n            cost1 = 0\n            cost2 = 0\n            if pos > 0:\n                cost1 += distance_matrix_1[new_solution[pos-1], cluster[0]]\n                cost2 += distance_matrix_2[new_solution[pos-1], cluster[0]]\n            if pos + cluster_size < n:\n                cost1 += distance_matrix_1[cluster[-1], new_solution[pos+cluster_size]]\n                cost2 += distance_matrix_2[cluster[-1], new_solution[pos+cluster_size]]\n\n            # Calculate removal cost\n            if cluster_start > 0:\n                cost1 -= distance_matrix_1[new_solution[cluster_start-1], new_solution[cluster_start]]\n                cost2 -= distance_matrix_2[new_solution[cluster_start-1], new_solution[cluster_start]]\n            if cluster_start + cluster_size < n:\n                cost1 -= distance_matrix_1[new_solution[cluster_start+cluster_size-1], new_solution[cluster_start+cluster_size]]\n                cost2 -= distance_matrix_2[new_solution[cluster_start+cluster_size-1], new_solution[cluster_start+cluster_size]]\n\n            total_score = cost1 + cost2\n            if total_score < best_score:\n                best_score = total_score\n                best_pos = pos\n\n        # Apply the best move\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            cluster,\n            new_solution[best_pos:cluster_start],\n            new_solution[cluster_start+cluster_size:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8111485817518161,
            0.2647537589073181
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective quality and solution structure\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.mean(axis=1) * (1 + 0.1 * np.random.rand(len(archive)))\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion: Invert a segment with length based on objective improvement potential\n    if n > 3:\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n    # Node cluster relocation: Move a cluster of nodes to a better position\n    if n > 4:\n        cluster_size = np.random.randint(2, min(5, n // 3))\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Find best insertion position considering both objectives\n        best_pos = cluster_start\n        best_score = float('inf')\n\n        for pos in range(n - cluster_size):\n            if pos in range(cluster_start, cluster_start + cluster_size):\n                continue\n\n            # Calculate insertion cost for both objectives\n            cost1 = 0\n            cost2 = 0\n            if pos > 0:\n                cost1 += distance_matrix_1[new_solution[pos-1], cluster[0]]\n                cost2 += distance_matrix_2[new_solution[pos-1], cluster[0]]\n            if pos + cluster_size < n:\n                cost1 += distance_matrix_1[cluster[-1], new_solution[pos+cluster_size]]\n                cost2 += distance_matrix_2[cluster[-1], new_solution[pos+cluster_size]]\n\n            # Calculate removal cost\n            if cluster_start > 0:\n                cost1 -= distance_matrix_1[new_solution[cluster_start-1], new_solution[cluster_start]]\n                cost2 -= distance_matrix_2[new_solution[cluster_start-1], new_solution[cluster_start]]\n            if cluster_start + cluster_size < n:\n                cost1 -= distance_matrix_1[new_solution[cluster_start+cluster_size-1], new_solution[cluster_start+cluster_size]]\n                cost2 -= distance_matrix_2[new_solution[cluster_start+cluster_size-1], new_solution[cluster_start+cluster_size]]\n\n            total_score = cost1 + cost2\n            if total_score < best_score:\n                best_score = total_score\n                best_pos = pos\n\n        # Apply the best move\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            cluster,\n            new_solution[best_pos:cluster_start],\n            new_solution[cluster_start+cluster_size:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection, then applies a hybrid local search combining segment reversal with adaptive k-swap operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n = len(objectives)\n    if n == 1:\n        selected_idx = 0\n    else:\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(n)\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, n-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n\n        sorted_indices = np.argsort(objectives[:, 1])\n        crowding_distances[sorted_indices[0]] += np.inf\n        crowding_distances[sorted_indices[-1]] += np.inf\n\n        for i in range(1, n-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1])\n\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with adaptive k-swap\n    if n >= 4:\n        k = np.random.randint(2, min(4, n//2))\n        segments = []\n        for _ in range(k):\n            start = np.random.randint(1, n-2)\n            end = np.random.randint(start+1, min(start+3, n))\n            segments.append((start, end))\n\n        segments.sort()\n        current_pos = 0\n        new_order = []\n        for start, end in segments:\n            if current_pos < start:\n                new_order.extend(new_solution[current_pos:start])\n            new_order.extend(reversed(new_solution[start:end]))\n            current_pos = end\n        if current_pos < n:\n            new_order.extend(new_solution[current_pos:])\n\n        # Ensure the tour is circular\n        if new_order[0] != new_solution[0]:\n            new_order = [new_order[-1]] + new_order[:-1]\n\n        new_solution = np.array(new_order)\n\n        # Adaptive k-swap\n        k = min(3, n//2)\n        for _ in range(k):\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            if abs(i-j) > 1:\n                cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                               distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                               distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                               distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                               distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                               distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                               distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                if cost1_change < 0 or cost2_change < 0:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7259735086274646,
            0.5364004373550415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    n = len(objectives)\n    if n == 1:\n        selected_idx = 0\n    else:\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_distances = np.zeros(n)\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n\n        for i in range(1, n-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n\n        sorted_indices = np.argsort(objectives[:, 1])\n        crowding_distances[sorted_indices[0]] += np.inf\n        crowding_distances[sorted_indices[-1]] += np.inf\n\n        for i in range(1, n-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1])\n\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with adaptive k-swap\n    if n >= 4:\n        k = np.random.randint(2, min(4, n//2))\n        segments = []\n        for _ in range(k):\n            start = np.random.randint(1, n-2)\n            end = np.random.randint(start+1, min(start+3, n))\n            segments.append((start, end))\n\n        segments.sort()\n        current_pos = 0\n        new_order = []\n        for start, end in segments:\n            if current_pos < start:\n                new_order.extend(new_solution[current_pos:start])\n            new_order.extend(reversed(new_solution[start:end]))\n            current_pos = end\n        if current_pos < n:\n            new_order.extend(new_solution[current_pos:])\n\n        # Ensure the tour is circular\n        if new_order[0] != new_solution[0]:\n            new_order = [new_order[-1]] + new_order[:-1]\n\n        new_solution = np.array(new_order)\n\n        # Adaptive k-swap\n        k = min(3, n//2)\n        for _ in range(k):\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            if abs(i-j) > 1:\n                cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                               distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                               distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                               distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                               distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                               distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                               distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                if cost1_change < 0 or cost2_change < 0:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9955756972706151,
            0.19696515798568726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9955756972706151,
            0.19696515798568726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution structure, then applies a novel \"node chain reversal with objective-aware segment insertion\" to generate a neighbor solution while ensuring feasibility, where segments are selected based on their potential to improve both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with good balance between objectives and structural diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Node chain reversal with objective-aware segment insertion\n        # Select a segment based on potential improvement in both objectives\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate potential improvement if segment is reversed\n        original_cost1 = distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(start+segment_length)%n]]\n        reversed_cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(start+segment_length)%n]]\n        improvement1 = original_cost1 - reversed_cost1\n\n        original_cost2 = distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(start+segment_length)%n]]\n        reversed_cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(start+segment_length)%n]]\n        improvement2 = original_cost2 - reversed_cost2\n\n        # Reverse segment if it improves both objectives\n        if improvement1 > 0 and improvement2 > 0:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Insert segment at a new position to improve both objectives\n        if n > 8:\n            new_pos = np.random.randint(0, n - segment_length)\n            while abs(new_pos - start) < segment_length:  # Ensure non-overlapping\n                new_pos = np.random.randint(0, n - segment_length)\n\n            # Check if insertion improves both objectives\n            original_cost1 = distance_matrix_1[new_solution[new_pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[new_pos]]\n            new_cost1 = distance_matrix_1[new_solution[new_pos-1], new_solution[start]] + distance_matrix_1[new_solution[(start+segment_length-1)%n], new_solution[new_pos]]\n\n            original_cost2 = distance_matrix_2[new_solution[new_pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[new_pos]]\n            new_cost2 = distance_matrix_2[new_solution[new_pos-1], new_solution[start]] + distance_matrix_2[new_solution[(start+segment_length-1)%n], new_solution[new_pos]]\n\n            if original_cost1 > new_cost1 and original_cost2 > new_cost2:\n                # Remove segment from original position\n                new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n                # Insert segment at new position\n                new_solution = np.insert(new_solution, new_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.7806921710340777,
            1.7968626618385315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with good balance between objectives and structural diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Node chain reversal with objective-aware segment insertion\n        # Select a segment based on potential improvement in both objectives\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate potential improvement if segment is reversed\n        original_cost1 = distance_matrix_1[new_solution[start-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[(start+segment_length)%n]]\n        reversed_cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[(start+segment_length)%n]]\n        improvement1 = original_cost1 - reversed_cost1\n\n        original_cost2 = distance_matrix_2[new_solution[start-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[(start+segment_length)%n]]\n        reversed_cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[(start+segment_length)%n]]\n        improvement2 = original_cost2 - reversed_cost2\n\n        # Reverse segment if it improves both objectives\n        if improvement1 > 0 and improvement2 > 0:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Insert segment at a new position to improve both objectives\n        if n > 8:\n            new_pos = np.random.randint(0, n - segment_length)\n            while abs(new_pos - start) < segment_length:  # Ensure non-overlapping\n                new_pos = np.random.randint(0, n - segment_length)\n\n            # Check if insertion improves both objectives\n            original_cost1 = distance_matrix_1[new_solution[new_pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[new_pos]]\n            new_cost1 = distance_matrix_1[new_solution[new_pos-1], new_solution[start]] + distance_matrix_1[new_solution[(start+segment_length-1)%n], new_solution[new_pos]]\n\n            original_cost2 = distance_matrix_2[new_solution[new_pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[new_pos]]\n            new_cost2 = distance_matrix_2[new_solution[new_pos-1], new_solution[start]] + distance_matrix_2[new_solution[(start+segment_length-1)%n], new_solution[new_pos]]\n\n            if original_cost1 > new_cost1 and original_cost2 > new_cost2:\n                # Remove segment from original position\n                new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n                # Insert segment at new position\n                new_solution = np.insert(new_solution, new_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{The algorithm selects a solution from the archive based on a dynamic score combining objective values and solution diversity, then applies a hybrid segment inversion and adaptive reinsertion strategy to generate a neighbor solution with controlled perturbations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        diversity = len(np.unique(sol)) / len(sol)\n        score = (obj1 + obj2) * (1 - diversity)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    if random.random() < 0.7:\n        new_solution[a:b+1] = inverted_segment\n    else:\n        new_solution = np.roll(new_solution, random.randint(1, n-1))\n\n    if random.random() < 0.3:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7453460674334725,
            0.4849563241004944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        diversity = len(np.unique(sol)) / len(sol)\n        score = (obj1 + obj2) * (1 - diversity)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    if random.random() < 0.7:\n        new_solution[a:b+1] = inverted_segment\n    else:\n        new_solution = np.roll(new_solution, random.randint(1, n-1))\n\n    if random.random() < 0.3:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-segment rotation\" combined with \"objective-aware segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment rotation with objective-aware selection\n    if n > 4:\n        num_segments = np.random.randint(2, min(4, n//3))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n        segment_starts = np.random.choice(range(n - sum(segment_lengths)), size=num_segments, replace=False)\n\n        segments = []\n        for start, length in zip(segment_starts, segment_lengths):\n            segments.append(new_solution[start:start+length])\n\n        # Calculate segment costs in both objectives\n        segment_costs = []\n        for segment in segments:\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_costs.append((cost1, cost2))\n\n        # Rotate segments if it improves at least one objective\n        if num_segments > 1:\n            rotated_segments = segments[1:] + [segments[0]]\n            rotated_costs = segment_costs[1:] + [segment_costs[0]]\n\n            original_total = sum(cost[0] + cost[1] for cost in segment_costs)\n            rotated_total = sum(cost[0] + cost[1] for cost in rotated_costs)\n\n            if rotated_total < original_total:\n                segments = rotated_segments\n\n        # Reinsert segments at new positions\n        for i, (start, length) in enumerate(zip(segment_starts, segment_lengths)):\n            new_position = np.random.randint(0, n - length)\n            segment = segments[i]\n            new_solution = np.concatenate([\n                new_solution[:new_position],\n                segment,\n                new_solution[new_position:new_position+length],\n                new_solution[new_position+length:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.9232470030410538,
            0.1193494200706482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment rotation with objective-aware selection\n    if n > 4:\n        num_segments = np.random.randint(2, min(4, n//3))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n        segment_starts = np.random.choice(range(n - sum(segment_lengths)), size=num_segments, replace=False)\n\n        segments = []\n        for start, length in zip(segment_starts, segment_lengths):\n            segments.append(new_solution[start:start+length])\n\n        # Calculate segment costs in both objectives\n        segment_costs = []\n        for segment in segments:\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_costs.append((cost1, cost2))\n\n        # Rotate segments if it improves at least one objective\n        if num_segments > 1:\n            rotated_segments = segments[1:] + [segments[0]]\n            rotated_costs = segment_costs[1:] + [segment_costs[0]]\n\n            original_total = sum(cost[0] + cost[1] for cost in segment_costs)\n            rotated_total = sum(cost[0] + cost[1] for cost in rotated_costs)\n\n            if rotated_total < original_total:\n                segments = rotated_segments\n\n        # Reinsert segments at new positions\n        for i, (start, length) in enumerate(zip(segment_starts, segment_lengths)):\n            new_position = np.random.randint(0, n - length)\n            segment = segments[i]\n            new_solution = np.concatenate([\n                new_solution[:new_position],\n                segment,\n                new_solution[new_position:new_position+length],\n                new_solution[new_position+length:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" and an additional \"node inversion\" step to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n            if np.random.random() < 0.3:\n                invert_start = np.random.randint(0, n - 2)\n                invert_end = np.random.randint(invert_start + 2, n)\n                new_solution[invert_start:invert_end] = new_solution[invert_start:invert_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9659346655023324,
            0.07538694143295288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n            if np.random.random() < 0.3:\n                invert_start = np.random.randint(0, n - 2)\n                invert_end = np.random.randint(invert_start + 2, n)\n                new_solution[invert_start:invert_end] = new_solution[invert_start:invert_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and structural diversity, then applies a novel segment inversion and adaptive edge contraction strategy that combines local refinement with global reordering to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 3:\n        return archive[0][0].copy()\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment inversion with objective-aware selection\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if b - a > 1:\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        new_solution[a:b+1] = inverted_segment\n\n    # Adaptive edge contraction\n    if n >= 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while abs(i-j) <= 1 or abs(i-j) >= n-2:\n            j = np.random.randint(1, n-1)\n\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6323005384559544,
            0.36413657665252686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 3:\n        return archive[0][0].copy()\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Segment inversion with objective-aware selection\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    if b - a > 1:\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        new_solution[a:b+1] = inverted_segment\n\n    # Adaptive edge contraction\n    if n >= 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while abs(i-j) <= 1 or abs(i-j) >= n-2:\n            j = np.random.randint(1, n-1)\n\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9790134761382666,
            0.07310903072357178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of normalized objective values and solution diversity, then applies a hybrid local search combining a \"node block inversion\" with an \"intelligent edge swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of normalized objectives and diversity\n    objectives = np.array([x[1] for x in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    scores = np.dot(normalized_obj, weights)\n    diversity_scores = np.array([np.mean([np.linalg.norm(x[0] - y[0]) for y in archive]) for x in archive])\n    combined_scores = scores * 0.6 + diversity_scores * 0.4\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node block inversion + intelligent edge swap\n    if n > 4:\n        # Node block inversion: Select a segment and reverse it\n        block_size = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - block_size)\n        new_solution[start:start+block_size] = new_solution[start:start+block_size][::-1]\n\n        # Intelligent edge swap: Swap edges that improve both objectives\n        for _ in range(2):\n            i, j = np.random.choice(n, size=2, replace=False)\n            if abs(i - j) > 1:\n                # Calculate potential improvement\n                old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n                new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n                old_cost = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] for e in old_edges)\n                new_cost = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] for e in new_edges)\n                if new_cost < old_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9040754132840911,
            2.8596208095550537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of normalized objectives and diversity\n    objectives = np.array([x[1] for x in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    weights = np.random.uniform(0.3, 0.7, size=2)\n    scores = np.dot(normalized_obj, weights)\n    diversity_scores = np.array([np.mean([np.linalg.norm(x[0] - y[0]) for y in archive]) for x in archive])\n    combined_scores = scores * 0.6 + diversity_scores * 0.4\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node block inversion + intelligent edge swap\n    if n > 4:\n        # Node block inversion: Select a segment and reverse it\n        block_size = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - block_size)\n        new_solution[start:start+block_size] = new_solution[start:start+block_size][::-1]\n\n        # Intelligent edge swap: Swap edges that improve both objectives\n        for _ in range(2):\n            i, j = np.random.choice(n, size=2, replace=False)\n            if abs(i - j) > 1:\n                # Calculate potential improvement\n                old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n                new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n                old_cost = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] for e in old_edges)\n                new_cost = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] for e in new_edges)\n                if new_cost < old_cost:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment insertion\" local search that intelligently reinserts segments of nodes while considering both objectives, ensuring feasibility and potentially improving both costs simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment insertion\n    if n > 4:\n        # Select a random segment of 2-4 nodes\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Calculate insertion positions and their costs\n        best_pos = -1\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert the segment at position pos\n            candidate = np.insert(new_solution, pos, segment)\n\n            # Calculate the cost of the candidate solution\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Update best position if it improves at least one objective\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 1e-6) or (cost2 < best_cost2 and cost1 <= best_cost1 + 1e-6):\n                best_pos = pos\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.7036846207741976,
            2.3363714814186096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment insertion\n    if n > 4:\n        # Select a random segment of 2-4 nodes\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Calculate insertion positions and their costs\n        best_pos = -1\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert the segment at position pos\n            candidate = np.insert(new_solution, pos, segment)\n\n            # Calculate the cost of the candidate solution\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Update best position if it improves at least one objective\n            if (cost1 < best_cost1 and cost2 <= best_cost2 + 1e-6) or (cost2 < best_cost2 and cost1 <= best_cost1 + 1e-6):\n                best_pos = pos\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection criterion that combines objective scores and solution structure similarity, then applies a novel \"node cluster reshuffling\" operator that rearranges nodes in identified clusters while preserving the tour's feasibility, with the goal of improving both objectives through coordinated local improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity-aware score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify node clusters based on spatial proximity in both objectives\n    clusters = []\n    visited = set()\n    for i in range(n):\n        if i not in visited:\n            cluster = [i]\n            visited.add(i)\n            for j in range(n):\n                if j not in visited:\n                    # Check if nodes are close in both spaces\n                    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n                    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n                    if dist1 < 1.5 * np.mean(distance_matrix_1) and dist2 < 1.5 * np.mean(distance_matrix_2):\n                        cluster.append(j)\n                        visited.add(j)\n            clusters.append(cluster)\n\n    # Reshuffle nodes within clusters to improve both objectives\n    for cluster in clusters:\n        if len(cluster) > 2:\n            # Select random segment within cluster\n            a, b = sorted(np.random.choice(cluster, size=2, replace=False))\n            segment = new_solution[a:b+1]\n\n            # Find best insertion point outside cluster\n            best_pos = -1\n            best_cost = float('inf')\n            for pos in range(n):\n                if pos not in cluster:\n                    # Calculate cost change for both objectives\n                    cost1 = (distance_matrix_1[new_solution[pos-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(pos+len(segment))%n]] -\n                            distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n\n                    cost2 = (distance_matrix_2[new_solution[pos-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(pos+len(segment))%n]] -\n                            distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n                    total_cost = cost1 + cost2\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = pos\n\n            if best_pos != -1 and best_cost < 0:\n                # Perform the reshuffling\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[best_pos:best_pos+len(segment)],\n                    new_solution[best_pos+len(segment):]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.7365305321956861,
            0.7335344552993774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best diversity-aware score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify node clusters based on spatial proximity in both objectives\n    clusters = []\n    visited = set()\n    for i in range(n):\n        if i not in visited:\n            cluster = [i]\n            visited.add(i)\n            for j in range(n):\n                if j not in visited:\n                    # Check if nodes are close in both spaces\n                    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n                    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n                    if dist1 < 1.5 * np.mean(distance_matrix_1) and dist2 < 1.5 * np.mean(distance_matrix_2):\n                        cluster.append(j)\n                        visited.add(j)\n            clusters.append(cluster)\n\n    # Reshuffle nodes within clusters to improve both objectives\n    for cluster in clusters:\n        if len(cluster) > 2:\n            # Select random segment within cluster\n            a, b = sorted(np.random.choice(cluster, size=2, replace=False))\n            segment = new_solution[a:b+1]\n\n            # Find best insertion point outside cluster\n            best_pos = -1\n            best_cost = float('inf')\n            for pos in range(n):\n                if pos not in cluster:\n                    # Calculate cost change for both objectives\n                    cost1 = (distance_matrix_1[new_solution[pos-1], segment[0]] +\n                            distance_matrix_1[segment[-1], new_solution[(pos+len(segment))%n]] -\n                            distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n\n                    cost2 = (distance_matrix_2[new_solution[pos-1], segment[0]] +\n                            distance_matrix_2[segment[-1], new_solution[(pos+len(segment))%n]] -\n                            distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n                    total_cost = cost1 + cost2\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = pos\n\n            if best_pos != -1 and best_cost < 0:\n                # Perform the reshuffling\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[best_pos:best_pos+len(segment)],\n                    new_solution[best_pos+len(segment):]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9957873510296426,
            0.3842282295227051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9957873510296426,
            0.3842282295227051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search that combines a novel \"objective-aware node relocation\" with an \"adaptive segment inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node relocation\n    if n > 3:\n        node_pos = np.random.randint(1, n-1)\n        node = new_solution[node_pos]\n\n        # Evaluate potential insertion positions\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(1, n):\n            if pos == node_pos or pos == node_pos + 1 or pos == node_pos - 1:\n                continue\n\n            # Calculate cost for this insertion\n            if pos > node_pos:\n                cost = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                        distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n            else:\n                cost = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                        distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        # Perform the move if beneficial\n        if best_pos != node_pos:\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Adaptive segment inversion\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert if it improves at least one objective\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7919321438937195,
            0.20380628108978271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node relocation\n    if n > 3:\n        node_pos = np.random.randint(1, n-1)\n        node = new_solution[node_pos]\n\n        # Evaluate potential insertion positions\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(1, n):\n            if pos == node_pos or pos == node_pos + 1 or pos == node_pos - 1:\n                continue\n\n            # Calculate cost for this insertion\n            if pos > node_pos:\n                cost = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                        distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n            else:\n                cost = (distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] +\n                        distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]])\n\n            if cost < best_cost:\n                best_cost = cost\n                best_pos = pos\n\n        # Perform the move if beneficial\n        if best_pos != node_pos:\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:best_pos], [node], new_solution[best_pos:]])\n\n    # Adaptive segment inversion\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert if it improves at least one objective\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with an \"intra-segment relocation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and good objective balance\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.std(x[0])))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment shuffle with intra-segment relocation\n    if n > 4:\n        # Select a random segment\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Shuffle the segment\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Intra-segment relocation\n        if segment_length > 2:\n            reloc_pos = np.random.randint(1, segment_length-1)\n            node = new_solution[start+reloc_pos]\n            new_segment = np.delete(new_solution[start:start+segment_length], reloc_pos)\n            insert_pos = np.random.randint(0, segment_length-1)\n            new_segment = np.insert(new_segment, insert_pos, node)\n            new_solution[start:start+segment_length] = new_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8212470427768543,
            1.5737378001213074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and good objective balance\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.std(x[0])))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment shuffle with intra-segment relocation\n    if n > 4:\n        # Select a random segment\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Shuffle the segment\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Intra-segment relocation\n        if segment_length > 2:\n            reloc_pos = np.random.randint(1, segment_length-1)\n            node = new_solution[start+reloc_pos]\n            new_segment = np.delete(new_solution[start:start+segment_length], reloc_pos)\n            insert_pos = np.random.randint(0, segment_length-1)\n            new_segment = np.insert(new_segment, insert_pos, node)\n            new_solution[start:start+segment_length] = new_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a hybrid local search combining a novel \"node segment rotation\" with a \"cross-segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and quality\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment rotation with objective-aware selection\n    if n > 4:\n        segment_length = np.random.randint(2, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment to find better arrangement\n        for i in range(1, len(segment)):\n            rotated_segment = np.roll(segment, i)\n            rotated_cost1 = sum(distance_matrix_1[rotated_segment[j], rotated_segment[j+1]] for j in range(len(rotated_segment)-1))\n            original_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n            if rotated_cost1 < original_cost1:\n                new_solution[start:start+segment_length] = rotated_segment\n                break\n\n        # Cross-segment insertion with quality improvement\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            insert_length = np.random.randint(1, min(4, n//2))\n            segment_to_insert = new_solution[:insert_length]\n\n            if insert_pos + insert_length <= n:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment_to_insert,\n                    new_solution[insert_pos + insert_length:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.8765945446145573,
            0.09272617101669312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and quality\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment rotation with objective-aware selection\n    if n > 4:\n        segment_length = np.random.randint(2, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment to find better arrangement\n        for i in range(1, len(segment)):\n            rotated_segment = np.roll(segment, i)\n            rotated_cost1 = sum(distance_matrix_1[rotated_segment[j], rotated_segment[j+1]] for j in range(len(rotated_segment)-1))\n            original_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n            if rotated_cost1 < original_cost1:\n                new_solution[start:start+segment_length] = rotated_segment\n                break\n\n        # Cross-segment insertion with quality improvement\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            insert_length = np.random.randint(1, min(4, n//2))\n            segment_to_insert = new_solution[:insert_length]\n\n            if insert_pos + insert_length <= n:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment_to_insert,\n                    new_solution[insert_pos + insert_length:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node insertion\" with a \"multi-objective segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node insertion + multi-objective segment rotation\n    if n > 4:\n        # Adaptive node insertion: Remove a random node and insert it in the best position\n        node_to_move = np.random.randint(0, n)\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, i, node)\n            cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(n-1))\n            cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(n-1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Multi-objective segment rotation: Rotate a segment based on objective improvement\n        if n > 6:\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Rotate segment if it improves at least one objective\n            rotated_segment = np.roll(segment, 1)\n            rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n            rotated_cost2 = sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n\n            if rotated_cost1 < segment_cost1 or rotated_cost2 < segment_cost2:\n                new_solution[start:start+segment_length] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8266056852461574,
            1.8081507086753845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node insertion + multi-objective segment rotation\n    if n > 4:\n        # Adaptive node insertion: Remove a random node and insert it in the best position\n        node_to_move = np.random.randint(0, n)\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, i, node)\n            cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(n-1))\n            cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(n-1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Multi-objective segment rotation: Rotate a segment based on objective improvement\n        if n > 6:\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Rotate segment if it improves at least one objective\n            rotated_segment = np.roll(segment, 1)\n            rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n            rotated_cost2 = sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n\n            if rotated_cost1 < segment_cost1 or rotated_cost2 < segment_cost2:\n                new_solution[start:start+segment_length] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"adaptive segment inversion and insertion\" operator that dynamically adjusts segment sizes and insertion points based on the solution's current structure and objective values, ensuring high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    obj1, obj2 = archive[selected_idx][1]\n    total_obj = obj1 + obj2\n\n    segment_size = max(2, min(6, int(n * (0.2 + 0.6 * (obj1 / total_obj)))))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    insert_pos = random.randint(0, n - segment_size)\n    if insert_pos >= start:\n        insert_pos += segment_size\n\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_size:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7882689541187815,
            0.37271881103515625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    obj1, obj2 = archive[selected_idx][1]\n    total_obj = obj1 + obj2\n\n    segment_size = max(2, min(6, int(n * (0.2 + 0.6 * (obj1 / total_obj)))))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    insert_pos = random.randint(0, n - segment_size)\n    if insert_pos >= start:\n        insert_pos += segment_size\n\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_size:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid selection heuristic that balances dominance and diversity, then applies a novel segment inversion and adaptive k-opt strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n\n    # Selection heuristic: choose a solution that is not dominated by others and has good diversity\n    scores = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            # Score based on normalized objective values and diversity\n            norm_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max())\n            diversity = sum(abs(distance_matrix_1[sol[i], sol[i+1]] - distance_matrix_2[sol[i], sol[i+1]]) for i in range(n-1)) / n\n            scores.append((i, norm_obj[0] + norm_obj[1] - diversity))\n\n    if not scores:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = max(scores, key=lambda x: x[1])[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    # Novel segment inversion and adaptive k-opt\n    a, b = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:\n        # Segment inversion\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Adaptive k-opt (k=3)\n        if b - a + 1 >= 3:\n            segment = new_solution[a:b+1]\n            k = min(3, len(segment))\n            if random.random() < 0.5:\n                # Reorder segment\n                new_segment = segment.copy()\n                for _ in range(k-1):\n                    i, j = random.sample(range(len(new_segment)), 2)\n                    new_segment[i], new_segment[j] = new_segment[j], new_segment[i]\n                new_solution[a:b+1] = new_segment\n            else:\n                # Rotate segment\n                new_solution[a:b+1] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7958705050921427,
            0.7142922282218933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n\n    # Selection heuristic: choose a solution that is not dominated by others and has good diversity\n    scores = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            # Score based on normalized objective values and diversity\n            norm_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max())\n            diversity = sum(abs(distance_matrix_1[sol[i], sol[i+1]] - distance_matrix_2[sol[i], sol[i+1]]) for i in range(n-1)) / n\n            scores.append((i, norm_obj[0] + norm_obj[1] - diversity))\n\n    if not scores:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = max(scores, key=lambda x: x[1])[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    # Novel segment inversion and adaptive k-opt\n    a, b = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:\n        # Segment inversion\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Adaptive k-opt (k=3)\n        if b - a + 1 >= 3:\n            segment = new_solution[a:b+1]\n            k = min(3, len(segment))\n            if random.random() < 0.5:\n                # Reorder segment\n                new_segment = segment.copy()\n                for _ in range(k-1):\n                    i, j = random.sample(range(len(new_segment)), 2)\n                    new_segment[i], new_segment[j] = new_segment[j], new_segment[i]\n                new_solution[a:b+1] = new_segment\n            else:\n                # Rotate segment\n                new_solution[a:b+1] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel \"adaptive segment inversion and node reinsertion\" strategy to generate a neighbor solution while ensuring feasibility by carefully maintaining the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion and node reinsertion\n    if n > 4:\n        # Segment inversion: Select a segment and invert its order\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Node reinsertion: Remove a node and reinsert it at a different position\n        if n > 5:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9203979268458252,
            0.27892887592315674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion and node reinsertion\n    if n > 4:\n        # Segment inversion: Select a segment and invert its order\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Node reinsertion: Remove a node and reinsert it at a different position\n        if n > 5:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This algorithm selects a solution from the archive based on a Pareto front dominance criterion, then applies a novel \"cross-segment insertion\" local search combined with a \"node swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution that is on the Pareto front\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        base_solution = pareto_front[np.random.randint(len(pareto_front))].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-segment insertion\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        segment1 = new_solution[start1:start1+segment_length]\n\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start2 - start1) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        # Insert segment1 at start2\n        new_solution = np.concatenate([new_solution[:start2], segment1, new_solution[start2+segment_length:]])\n\n        # Remove duplicates by shifting remaining nodes\n        seen = set()\n        unique_solution = []\n        for node in new_solution:\n            if node not in seen:\n                seen.add(node)\n                unique_solution.append(node)\n\n        # Ensure all nodes are included\n        missing_nodes = [node for node in base_solution if node not in seen]\n        unique_solution.extend(missing_nodes)\n        new_solution = np.array(unique_solution[:n])\n\n    # Node swap for local optimization\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8566981351047389,
            0.22823631763458252
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution that is on the Pareto front\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        base_solution = pareto_front[np.random.randint(len(pareto_front))].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-segment insertion\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        segment1 = new_solution[start1:start1+segment_length]\n\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start2 - start1) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        # Insert segment1 at start2\n        new_solution = np.concatenate([new_solution[:start2], segment1, new_solution[start2+segment_length:]])\n\n        # Remove duplicates by shifting remaining nodes\n        seen = set()\n        unique_solution = []\n        for node in new_solution:\n            if node not in seen:\n                seen.add(node)\n                unique_solution.append(node)\n\n        # Ensure all nodes are included\n        missing_nodes = [node for node in base_solution if node not in seen]\n        unique_solution.extend(missing_nodes)\n        new_solution = np.array(unique_solution[:n])\n\n    # Node swap for local optimization\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid score combining objective dominance and solution quality, then applies a novel \"adaptive segment insertion\" with \"objective-aware node replacement\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Hybrid score combining objective dominance and solution quality\n    scores = []\n    for sol, obj in archive:\n        # Score based on Pareto dominance and objective values\n        dominance_count = sum(1 for s, o in archive if (o[0] < obj[0] and o[1] <= obj[1]) or (o[0] <= obj[0] and o[1] < obj[1]))\n        score = -dominance_count + 0.3 * (obj[0] + obj[1])  # Balance between dominance and objective values\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with objective-aware node replacement\n    if n > 5:\n        # Select a segment to move\n        segment_length = np.random.randint(2, min(7, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos <= start + segment_length:\n                continue\n\n            # Calculate insertion cost\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            insert_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n            insert_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n            # Calculate removal cost\n            if pos > 0 and pos < n:\n                remove_cost1 = distance_matrix_1[prev_node, next_node]\n                remove_cost2 = distance_matrix_2[prev_node, next_node]\n            else:\n                remove_cost1 = 0\n                remove_cost2 = 0\n\n            # Calculate improvement\n            improvement1 = remove_cost1 - insert_cost1\n            improvement2 = remove_cost2 - insert_cost2\n\n            # Track best position\n            if improvement1 > best_improvement or improvement2 > best_improvement:\n                best_pos = pos\n                best_improvement = max(improvement1, improvement2)\n\n        # Apply the best insertion\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[start+segment_length:]\n            ])\n\n    # Objective-aware node replacement\n    if n > 3:\n        # Select a node to replace\n        node_idx = np.random.randint(0, n)\n        current_node = new_solution[node_idx]\n\n        # Find the best replacement node that improves at least one objective\n        best_replacement = None\n        best_improvement = 0\n\n        for candidate in range(n):\n            if candidate == current_node:\n                continue\n\n            # Calculate cost change\n            prev_node = new_solution[node_idx-1] if node_idx > 0 else new_solution[-1]\n            next_node = new_solution[node_idx+1] if node_idx < n-1 else new_solution[0]\n\n            old_cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n\n            old_cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n\n            improvement1 = old_cost1 - new_cost1\n            improvement2 = old_cost2 - new_cost2\n\n            if improvement1 > best_improvement or improvement2 > best_improvement:\n                best_replacement = candidate\n                best_improvement = max(improvement1, improvement2)\n\n        # Apply the best replacement\n        if best_replacement is not None:\n            new_solution[node_idx] = best_replacement\n\n    return new_solution\n\n",
        "score": [
            -0.878788188966469,
            1.8065207600593567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Hybrid score combining objective dominance and solution quality\n    scores = []\n    for sol, obj in archive:\n        # Score based on Pareto dominance and objective values\n        dominance_count = sum(1 for s, o in archive if (o[0] < obj[0] and o[1] <= obj[1]) or (o[0] <= obj[0] and o[1] < obj[1]))\n        score = -dominance_count + 0.3 * (obj[0] + obj[1])  # Balance between dominance and objective values\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with objective-aware node replacement\n    if n > 5:\n        # Select a segment to move\n        segment_length = np.random.randint(2, min(7, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Find insertion point that improves at least one objective\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos <= start + segment_length:\n                continue\n\n            # Calculate insertion cost\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            insert_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n            insert_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n            # Calculate removal cost\n            if pos > 0 and pos < n:\n                remove_cost1 = distance_matrix_1[prev_node, next_node]\n                remove_cost2 = distance_matrix_2[prev_node, next_node]\n            else:\n                remove_cost1 = 0\n                remove_cost2 = 0\n\n            # Calculate improvement\n            improvement1 = remove_cost1 - insert_cost1\n            improvement2 = remove_cost2 - insert_cost2\n\n            # Track best position\n            if improvement1 > best_improvement or improvement2 > best_improvement:\n                best_pos = pos\n                best_improvement = max(improvement1, improvement2)\n\n        # Apply the best insertion\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[start+segment_length:]\n            ])\n\n    # Objective-aware node replacement\n    if n > 3:\n        # Select a node to replace\n        node_idx = np.random.randint(0, n)\n        current_node = new_solution[node_idx]\n\n        # Find the best replacement node that improves at least one objective\n        best_replacement = None\n        best_improvement = 0\n\n        for candidate in range(n):\n            if candidate == current_node:\n                continue\n\n            # Calculate cost change\n            prev_node = new_solution[node_idx-1] if node_idx > 0 else new_solution[-1]\n            next_node = new_solution[node_idx+1] if node_idx < n-1 else new_solution[0]\n\n            old_cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n\n            old_cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n\n            improvement1 = old_cost1 - new_cost1\n            improvement2 = old_cost2 - new_cost2\n\n            if improvement1 > best_improvement or improvement2 > best_improvement:\n                best_replacement = candidate\n                best_improvement = max(improvement1, improvement2)\n\n        # Apply the best replacement\n        if best_replacement is not None:\n            new_solution[node_idx] = best_replacement\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid selection criterion that prioritizes solutions with better objective values while promoting diversity, then applies a novel adaptive segment reversal and insertion strategy that dynamically adjusts the length and position of segments to explore both local and global improvements while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    objective_scores = [sum(obj) for _, obj in archive]\n    diversity_scores = [np.sum(np.abs(np.argsort(sol) - np.arange(n))) for sol, _ in archive]\n\n    combined_scores = [0.7 * obj + 0.3 * div for obj, div in zip(objective_scores, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    segment_length = min(3, n // 4)\n    a = random.randint(0, n - segment_length)\n    b = a + segment_length - 1\n\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        if c != d:\n            new_solution = np.insert(np.delete(new_solution, c), d, new_solution[c])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9252155868259595,
            0.5778867602348328
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    objective_scores = [sum(obj) for _, obj in archive]\n    diversity_scores = [np.sum(np.abs(np.argsort(sol) - np.arange(n))) for sol, _ in archive]\n\n    combined_scores = [0.7 * obj + 0.3 * div for obj, div in zip(objective_scores, diversity_scores)]\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    segment_length = min(3, n // 4)\n    a = random.randint(0, n - segment_length)\n    b = a + segment_length - 1\n\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        if c != d:\n            new_solution = np.insert(np.delete(new_solution, c), d, new_solution[c])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware scoring function that balances objective values and solution uniqueness, then applies a hybrid segment reversal with adaptive perturbation that combines local and global reordering to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        diversity = sum(1 for i in range(n) if sol[i] != archive[0][0][i])\n        score = (obj1 + obj2) / (1 + diversity)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.4:\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[c:d+1] = np.roll(new_solution[c:d+1], random.randint(1, d-c))\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6717986289189886,
            0.3770052194595337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        diversity = sum(1 for i in range(n) if sol[i] != archive[0][0][i])\n        score = (obj1 + obj2) / (1 + diversity)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.4:\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[c:d+1] = np.roll(new_solution[c:d+1], random.randint(1, d-c))\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a dynamic segment relocation and rotation strategy that combines local and global perturbations while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [0.6, 0.4]\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    if random.random() < 0.7:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c:][::-1]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7912711690274037,
            0.2167356014251709
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [0.6, 0.4]\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    if random.random() < 0.7:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], segment])\n    else:\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n        new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c:][::-1]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a novel \"multi-dimensional segment inversion\" and \"adaptive segment swapping\" strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(archive_sorted))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-dimensional segment inversion: Invert a segment in both objectives\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        inverted_segment = segment[::-1]\n        new_solution[start:start+segment_length] = inverted_segment\n\n        # Adaptive segment swapping: Swap segments based on objective improvements\n        if n > 6:\n            segment_length = np.random.randint(2, min(4, n//2))\n            start1 = np.random.randint(0, n - segment_length)\n            start2 = np.random.randint(0, n - segment_length)\n            while abs(start1 - start2) < segment_length:\n                start2 = np.random.randint(0, n - segment_length)\n\n            segment1 = new_solution[start1:start1+segment_length]\n            segment2 = new_solution[start2:start2+segment_length]\n\n            # Calculate cost differences\n            original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n            original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n            temp_solution = new_solution.copy()\n            temp_solution[start1:start1+segment_length] = segment2\n            temp_solution[start2:start2+segment_length] = segment1\n            new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n            if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9271793188774196,
            0.26897674798965454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(archive_sorted))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-dimensional segment inversion: Invert a segment in both objectives\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        inverted_segment = segment[::-1]\n        new_solution[start:start+segment_length] = inverted_segment\n\n        # Adaptive segment swapping: Swap segments based on objective improvements\n        if n > 6:\n            segment_length = np.random.randint(2, min(4, n//2))\n            start1 = np.random.randint(0, n - segment_length)\n            start2 = np.random.randint(0, n - segment_length)\n            while abs(start1 - start2) < segment_length:\n                start2 = np.random.randint(0, n - segment_length)\n\n            segment1 = new_solution[start1:start1+segment_length]\n            segment2 = new_solution[start2:start2+segment_length]\n\n            # Calculate cost differences\n            original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n            original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n            temp_solution = new_solution.copy()\n            temp_solution[start1:start1+segment_length] = segment2\n            temp_solution[start2:start2+segment_length] = segment1\n            new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n            if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and solution quality, then applies a novel \"multi-segment crossover\" strategy that combines segments from different parts of the tour with objective-aware selection criteria to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with objective-aware selection\n    if n > 4:\n        # Select three non-overlapping segments\n        segment_length = max(2, n // 4)\n        seg1_start = np.random.randint(0, n - 2 * segment_length)\n        seg2_start = np.random.randint(seg1_start + segment_length, n - segment_length)\n        seg3_start = np.random.randint(seg2_start + segment_length, n)\n\n        seg1 = new_solution[seg1_start:seg1_start+segment_length]\n        seg2 = new_solution[seg2_start:seg2_start+segment_length]\n        seg3 = new_solution[seg3_start:seg3_start+segment_length]\n\n        # Calculate segment costs\n        def segment_cost(seg, matrix):\n            cost = sum(matrix[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            cost += matrix[seg[-1], seg[0]]  # Add wrap-around cost\n            return cost\n\n        cost1_seg1, cost2_seg1 = segment_cost(seg1, distance_matrix_1), segment_cost(seg1, distance_matrix_2)\n        cost1_seg2, cost2_seg2 = segment_cost(seg2, distance_matrix_1), segment_cost(seg2, distance_matrix_2)\n        cost1_seg3, cost2_seg3 = segment_cost(seg3, distance_matrix_1), segment_cost(seg3, distance_matrix_2)\n\n        # Select the best segment based on combined cost\n        best_seg_idx = np.argmin([cost1_seg1 + cost2_seg1, cost1_seg2 + cost2_seg2, cost1_seg3 + cost2_seg3])\n        best_seg = [seg1, seg2, seg3][best_seg_idx]\n\n        # Create new tour by rotating the segments\n        new_solution = np.concatenate([best_seg, np.setdiff1d(new_solution, best_seg)])\n\n    return new_solution\n\n",
        "score": [
            -0.9197010094945004,
            0.30952078104019165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with objective-aware selection\n    if n > 4:\n        # Select three non-overlapping segments\n        segment_length = max(2, n // 4)\n        seg1_start = np.random.randint(0, n - 2 * segment_length)\n        seg2_start = np.random.randint(seg1_start + segment_length, n - segment_length)\n        seg3_start = np.random.randint(seg2_start + segment_length, n)\n\n        seg1 = new_solution[seg1_start:seg1_start+segment_length]\n        seg2 = new_solution[seg2_start:seg2_start+segment_length]\n        seg3 = new_solution[seg3_start:seg3_start+segment_length]\n\n        # Calculate segment costs\n        def segment_cost(seg, matrix):\n            cost = sum(matrix[seg[i], seg[i+1]] for i in range(len(seg)-1))\n            cost += matrix[seg[-1], seg[0]]  # Add wrap-around cost\n            return cost\n\n        cost1_seg1, cost2_seg1 = segment_cost(seg1, distance_matrix_1), segment_cost(seg1, distance_matrix_2)\n        cost1_seg2, cost2_seg2 = segment_cost(seg2, distance_matrix_1), segment_cost(seg2, distance_matrix_2)\n        cost1_seg3, cost2_seg3 = segment_cost(seg3, distance_matrix_1), segment_cost(seg3, distance_matrix_2)\n\n        # Select the best segment based on combined cost\n        best_seg_idx = np.argmin([cost1_seg1 + cost2_seg1, cost1_seg2 + cost2_seg2, cost1_seg3 + cost2_seg3])\n        best_seg = [seg1, seg2, seg3][best_seg_idx]\n\n        # Create new tour by rotating the segments\n        new_solution = np.concatenate([best_seg, np.setdiff1d(new_solution, best_seg)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{This new algorithm selects a solution from the archive based on a diversity-aware selection criterion that combines objective values and solution structure similarity, then applies a hybrid local search operator that combines adaptive node insertion with multi-objective edge flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    # Diversity-aware selection\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n\n    # Calculate solution similarity\n    similarity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(i+1, len(archive)):\n            common = len(set(archive[i][0]) & set(archive[j][0]))\n            similarity[i] += common\n            similarity[j] += common\n\n    combined_score = normalized_scores + 0.5 * (similarity / np.max(similarity + 1e-6))\n    selected_idx = np.argmin(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive node insertion\n    a, b = sorted(random.sample(range(n), 2))\n    node = new_solution[a]\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b+1], [node], new_solution[b+1:]])\n\n    # Multi-objective edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if (cost1_change < 0 and cost2_change < 0) or (random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7066565480311744,
            2.998502016067505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    # Diversity-aware selection\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n\n    # Calculate solution similarity\n    similarity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(i+1, len(archive)):\n            common = len(set(archive[i][0]) & set(archive[j][0]))\n            similarity[i] += common\n            similarity[j] += common\n\n    combined_score = normalized_scores + 0.5 * (similarity / np.max(similarity + 1e-6))\n    selected_idx = np.argmin(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive node insertion\n    a, b = sorted(random.sample(range(n), 2))\n    node = new_solution[a]\n    new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b+1], [node], new_solution[b+1:]])\n\n    # Multi-objective edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if (cost1_change < 0 and cost2_change < 0) or (random.random() < 0.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a novel \"adaptive segment reversal and distance-aware insertion\" strategy that dynamically balances local and global reordering to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(2, len(sorted_archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    segment_length = np.random.randint(2, min(5, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start + segment_length] = reversed_segment\n\n    if n > 6 and np.random.random() < 0.5:\n        insertion_point = np.random.randint(0, n - segment_length)\n        segment = new_solution[insertion_point:insertion_point + segment_length]\n        new_solution = np.concatenate([new_solution[:insertion_point], new_solution[insertion_point + segment_length:]])\n\n        best_cost = float('inf')\n        best_pos = 0\n        for pos in range(len(new_solution) - segment_length + 1):\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7999542090826022,
            0.3977828621864319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(2, len(sorted_archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    segment_length = np.random.randint(2, min(5, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n    reversed_segment = segment[::-1]\n    new_solution[start:start + segment_length] = reversed_segment\n\n    if n > 6 and np.random.random() < 0.5:\n        insertion_point = np.random.randint(0, n - segment_length)\n        segment = new_solution[insertion_point:insertion_point + segment_length]\n        new_solution = np.concatenate([new_solution[:insertion_point], new_solution[insertion_point + segment_length:]])\n\n        best_cost = float('inf')\n        best_pos = 0\n        for pos in range(len(new_solution) - segment_length + 1):\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid crowding distance and objective improvement potential, then applies a novel \"multi-segment inversion and relocation\" strategy to generate a neighbor solution while ensuring feasibility by carefully maintaining the tour structure through systematic segment operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Hybrid crowding distance and objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = max(0, i - 1)\n        right = min(len(archive) - 1, i + 1)\n        crowding_dist[i] = sum(abs(objectives[i][j] - objectives[left][j]) + abs(objectives[i][j] - objectives[right][j])\n                              for j in range(2))\n\n    # Combine crowding distance and objective improvement potential\n    improvement_scores = (objectives[:, 0] + objectives[:, 1]) / (1 + crowding_dist)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and relocation\n    if n >= 6:\n        # Determine segment boundaries\n        points = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n        a, b, c = points\n\n        # Invert segments\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n        # Relocate middle segment\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:b+1], new_solution[c+1:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.8107775657035754,
            0.4015640616416931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Hybrid crowding distance and objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        left = max(0, i - 1)\n        right = min(len(archive) - 1, i + 1)\n        crowding_dist[i] = sum(abs(objectives[i][j] - objectives[left][j]) + abs(objectives[i][j] - objectives[right][j])\n                              for j in range(2))\n\n    # Combine crowding distance and objective improvement potential\n    improvement_scores = (objectives[:, 0] + objectives[:, 1]) / (1 + crowding_dist)\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and relocation\n    if n >= 6:\n        # Determine segment boundaries\n        points = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n        a, b, c = points\n\n        # Invert segments\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n        # Relocate middle segment\n        segment = new_solution[b+1:c+1]\n        new_solution = np.concatenate([new_solution[:b+1], new_solution[c+1:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-segment inversion and adaptive crossover\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and adaptive crossover\n    if n > 4:\n        # Invert multiple non-overlapping segments\n        num_segments = np.random.randint(1, min(4, n//4))\n        segment_starts = sorted(random.sample(range(n-3), num_segments))\n        segment_lengths = [random.randint(2, min(4, n//num_segments)) for _ in range(num_segments)]\n\n        for start, length in zip(segment_starts, segment_lengths):\n            if start + length < n:\n                new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        # Adaptive crossover with another solution from archive\n        if random.random() < 0.5 and len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n\n            # Select a random segment from other solution\n            seg_start = random.randint(0, n-3)\n            seg_length = random.randint(2, min(5, n-seg_start))\n            segment = other_solution[seg_start:seg_start+seg_length]\n\n            # Insert into current solution\n            insert_pos = random.randint(0, n-seg_length)\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos+seg_length:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8912267366835658,
            0.30753183364868164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion and adaptive crossover\n    if n > 4:\n        # Invert multiple non-overlapping segments\n        num_segments = np.random.randint(1, min(4, n//4))\n        segment_starts = sorted(random.sample(range(n-3), num_segments))\n        segment_lengths = [random.randint(2, min(4, n//num_segments)) for _ in range(num_segments)]\n\n        for start, length in zip(segment_starts, segment_lengths):\n            if start + length < n:\n                new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        # Adaptive crossover with another solution from archive\n        if random.random() < 0.5 and len(archive) > 1:\n            other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n            other_solution = archive[other_idx][0]\n\n            # Select a random segment from other solution\n            seg_start = random.randint(0, n-3)\n            seg_length = random.randint(2, min(5, n-seg_start))\n            segment = other_solution[seg_start:seg_start+seg_length]\n\n            # Insert into current solution\n            insert_pos = random.randint(0, n-seg_length)\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos+seg_length:]\n            ])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{The algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a novel segment inversion and adaptive edge insertion strategy that combines local and global reordering to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    weights = np.array([(obj[0] + obj[1]) / (sum(obj) + 1e-8) for _, obj in archive])\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.4:\n        c, d = sorted(random.sample(range(n), 2))\n        if c != a and d != b:\n            edge = new_solution[c]\n            new_solution = np.concatenate([new_solution[:d], [edge], new_solution[d:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9731562947111221,
            0.4266197085380554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    weights = np.array([(obj[0] + obj[1]) / (sum(obj) + 1e-8) for _, obj in archive])\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.4:\n        c, d = sorted(random.sample(range(n), 2))\n        if c != a and d != b:\n            edge = new_solution[c]\n            new_solution = np.concatenate([new_solution[:d], [edge], new_solution[d:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and structural diversity, then applies a novel \"adaptive multi-segment crossover\" with \"objective-aware segment reinsertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high potential for improvement\n    archive_with_potential = []\n    for sol, obj in archive:\n        obj1, obj2 = obj\n        potential = obj1 * obj2 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0\n        archive_with_potential.append((sol, potential))\n    archive_with_potential.sort(key=lambda x: -x[1])\n    selected_idx = min(int(len(archive_with_potential)*0.3), len(archive_with_potential)-1)\n    base_solution = archive_with_potential[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive multi-segment crossover\n    num_segments = np.random.randint(2, min(4, n//3))\n    segment_lengths = sorted(np.random.choice(range(2, min(6, n//2)), num_segments, replace=False))\n    segments = []\n\n    # Extract segments\n    for length in segment_lengths:\n        start = np.random.randint(0, n - length)\n        segments.append(new_solution[start:start+length])\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+length:]])\n\n    # Objective-aware segment reinsertion\n    insertion_points = sorted(np.random.choice(range(len(new_solution)+1), num_segments, replace=False))\n    for i, segment in enumerate(segments):\n        # Calculate segment costs in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        seg_cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Insert segment that would improve at least one objective\n        if i < len(insertion_points):\n            new_solution = np.concatenate([new_solution[:insertion_points[i]], segment, new_solution[insertion_points[i]:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9824870239657149,
            0.28884828090667725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high potential for improvement\n    archive_with_potential = []\n    for sol, obj in archive:\n        obj1, obj2 = obj\n        potential = obj1 * obj2 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0\n        archive_with_potential.append((sol, potential))\n    archive_with_potential.sort(key=lambda x: -x[1])\n    selected_idx = min(int(len(archive_with_potential)*0.3), len(archive_with_potential)-1)\n    base_solution = archive_with_potential[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive multi-segment crossover\n    num_segments = np.random.randint(2, min(4, n//3))\n    segment_lengths = sorted(np.random.choice(range(2, min(6, n//2)), num_segments, replace=False))\n    segments = []\n\n    # Extract segments\n    for length in segment_lengths:\n        start = np.random.randint(0, n - length)\n        segments.append(new_solution[start:start+length])\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+length:]])\n\n    # Objective-aware segment reinsertion\n    insertion_points = sorted(np.random.choice(range(len(new_solution)+1), num_segments, replace=False))\n    for i, segment in enumerate(segments):\n        # Calculate segment costs in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        seg_cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Insert segment that would improve at least one objective\n        if i < len(insertion_points):\n            new_solution = np.concatenate([new_solution[:insertion_points[i]], segment, new_solution[insertion_points[i]:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{The algorithm selects a solution from the archive based on a combined metric of objective improvement potential and structural diversity, then applies a novel \"multi-objective segment fusion\" strategy that intelligently merges and reorders node segments to create balanced improvements in both objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high combined objective improvement potential\n    archive_with_potential = []\n    for sol, obj in archive:\n        obj1, obj2 = obj\n        potential = (obj1 + obj2) / (distance_matrix_1.sum() + distance_matrix_2.sum())\n        archive_with_potential.append((sol, obj, potential))\n\n    archive_with_potential.sort(key=lambda x: x[2], reverse=True)\n    top_candidates = min(3, len(archive_with_potential))\n    selected_idx = random.randint(0, top_candidates - 1)\n    base_solution = archive_with_potential[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment fusion strategy\n    k = min(4, n // 2)\n    break_points = sorted(random.sample(range(1, n), k-1))\n    segments = []\n    prev = 0\n    for bp in break_points + [n]:\n        segments.append(new_solution[prev:bp])\n        prev = bp\n\n    # Reorder segments based on combined objective improvement\n    segment_scores = []\n    for seg in segments:\n        seg_cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        seg_cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        segment_scores.append((seg_cost1 + seg_cost2) / (seg_cost1 * seg_cost2 + 1e-6))\n\n    # Sort segments by their combined score\n    sorted_indices = sorted(range(len(segments)), key=lambda i: segment_scores[i])\n    new_order = [segments[i] for i in sorted_indices]\n\n    # Reconstruct with improved segment ordering\n    new_solution = np.concatenate(new_order)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9809301168765076,
            0.7684799432754517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high combined objective improvement potential\n    archive_with_potential = []\n    for sol, obj in archive:\n        obj1, obj2 = obj\n        potential = (obj1 + obj2) / (distance_matrix_1.sum() + distance_matrix_2.sum())\n        archive_with_potential.append((sol, obj, potential))\n\n    archive_with_potential.sort(key=lambda x: x[2], reverse=True)\n    top_candidates = min(3, len(archive_with_potential))\n    selected_idx = random.randint(0, top_candidates - 1)\n    base_solution = archive_with_potential[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Multi-objective segment fusion strategy\n    k = min(4, n // 2)\n    break_points = sorted(random.sample(range(1, n), k-1))\n    segments = []\n    prev = 0\n    for bp in break_points + [n]:\n        segments.append(new_solution[prev:bp])\n        prev = bp\n\n    # Reorder segments based on combined objective improvement\n    segment_scores = []\n    for seg in segments:\n        seg_cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        seg_cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n        segment_scores.append((seg_cost1 + seg_cost2) / (seg_cost1 * seg_cost2 + 1e-6))\n\n    # Sort segments by their combined score\n    sorted_indices = sorted(range(len(segments)), key=lambda i: segment_scores[i])\n    new_order = [segments[i] for i in sorted_indices]\n\n    # Reconstruct with improved segment ordering\n    new_solution = np.concatenate(new_order)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.009750535007263,
            0.3081088066101074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment insertion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion with objective-aware rotation\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert segment elsewhere if it improves at least one objective\n        insert_pos = np.random.randint(0, n - segment_length)\n        while insert_pos == start:\n            insert_pos = np.random.randint(0, n - segment_length)\n\n        # Calculate potential insertion costs\n        before_node = new_solution[insert_pos - 1] if insert_pos > 0 else new_solution[-1]\n        after_node = new_solution[insert_pos] if insert_pos < n - 1 else new_solution[0]\n\n        new_cost1 = distance_matrix_1[before_node, segment[0]] + distance_matrix_1[segment[-1], after_node]\n        old_cost1 = distance_matrix_1[before_node, after_node]\n\n        new_cost2 = distance_matrix_2[before_node, segment[0]] + distance_matrix_2[segment[-1], after_node]\n        old_cost2 = distance_matrix_2[before_node, after_node]\n\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            # Perform insertion\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:-segment_length]\n            ])\n\n            # Cross-segment rotation for diversity\n            if n > 8:\n                rotate_start = np.random.randint(0, n - 3)\n                rotate_length = np.random.randint(2, min(5, n - rotate_start))\n                rotate_amount = np.random.randint(1, rotate_length)\n\n                rotated_segment = np.roll(new_solution[rotate_start:rotate_start+rotate_length], rotate_amount)\n                new_solution[rotate_start:rotate_start+rotate_length] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8665293881467181,
            0.2540434002876282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion with objective-aware rotation\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert segment elsewhere if it improves at least one objective\n        insert_pos = np.random.randint(0, n - segment_length)\n        while insert_pos == start:\n            insert_pos = np.random.randint(0, n - segment_length)\n\n        # Calculate potential insertion costs\n        before_node = new_solution[insert_pos - 1] if insert_pos > 0 else new_solution[-1]\n        after_node = new_solution[insert_pos] if insert_pos < n - 1 else new_solution[0]\n\n        new_cost1 = distance_matrix_1[before_node, segment[0]] + distance_matrix_1[segment[-1], after_node]\n        old_cost1 = distance_matrix_1[before_node, after_node]\n\n        new_cost2 = distance_matrix_2[before_node, segment[0]] + distance_matrix_2[segment[-1], after_node]\n        old_cost2 = distance_matrix_2[before_node, after_node]\n\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            # Perform insertion\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:-segment_length]\n            ])\n\n            # Cross-segment rotation for diversity\n            if n > 8:\n                rotate_start = np.random.randint(0, n - 3)\n                rotate_length = np.random.randint(2, min(5, n - rotate_start))\n                rotate_amount = np.random.randint(1, rotate_length)\n\n                rotated_segment = np.roll(new_solution[rotate_start:rotate_start+rotate_length], rotate_amount)\n                new_solution[rotate_start:rotate_start+rotate_length] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment inversion\" and \"distance-aware segment relocation\" strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion: Invert segments of varying lengths\n        num_segments = np.random.randint(1, min(3, n//2))\n        for _ in range(num_segments):\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware segment relocation: Relocate segments to positions that minimize distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best relocation point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9681604383436115,
            0.6400465369224548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion: Invert segments of varying lengths\n        num_segments = np.random.randint(1, min(3, n//2))\n        for _ in range(num_segments):\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware segment relocation: Relocate segments to positions that minimize distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best relocation point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and diversity, then applies a hybrid local search combining segment reversal with adaptive insertion based on both distance matrices, ensuring feasibility through validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    diversity = np.linalg.norm(normalized[:, None] - normalized, axis=2).sum(axis=1)\n    scores = 0.7 * normalized[:, 0] + 0.3 * normalized[:, 1] + 0.2 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        node = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8182237939543863,
            0.34500652551651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    diversity = np.linalg.norm(normalized[:, None] - normalized, axis=2).sum(axis=1)\n    scores = 0.7 * normalized[:, 0] + 0.3 * normalized[:, 1] + 0.2 * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        node = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a \"node chain inversion\" with a \"multi-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and diversity\n    weights = np.array([0.6, 0.4])  # More weight on first objective\n    scores = np.array([sum(weights * obj) for _, obj in archive])\n    selected_idx = np.argmin(scores)  # Select solution with lowest weighted score\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion + multi-segment rotation\n    if n > 4:\n        # Node chain inversion: Reverse a contiguous segment of nodes\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, min(start + 5, n))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Multi-segment rotation: Rotate two non-overlapping segments\n        if n > 8:\n            segment1_start = np.random.randint(0, n//2 - 2)\n            segment1_length = np.random.randint(2, min(5, n//2 - segment1_start))\n            segment2_start = np.random.randint(n//2, n - segment1_length)\n            segment2_length = segment1_length\n\n            segment1 = new_solution[segment1_start:segment1_start+segment1_length]\n            segment2 = new_solution[segment2_start:segment2_start+segment2_length]\n\n            new_solution[segment1_start:segment1_start+segment1_length] = np.roll(segment2, 1)\n            new_solution[segment2_start:segment2_start+segment2_length] = np.roll(segment1, -1)\n\n    return new_solution\n\n",
        "score": [
            -0.9473757888365725,
            0.4441797733306885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and diversity\n    weights = np.array([0.6, 0.4])  # More weight on first objective\n    scores = np.array([sum(weights * obj) for _, obj in archive])\n    selected_idx = np.argmin(scores)  # Select solution with lowest weighted score\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion + multi-segment rotation\n    if n > 4:\n        # Node chain inversion: Reverse a contiguous segment of nodes\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, min(start + 5, n))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Multi-segment rotation: Rotate two non-overlapping segments\n        if n > 8:\n            segment1_start = np.random.randint(0, n//2 - 2)\n            segment1_length = np.random.randint(2, min(5, n//2 - segment1_start))\n            segment2_start = np.random.randint(n//2, n - segment1_length)\n            segment2_length = segment1_length\n\n            segment1 = new_solution[segment1_start:segment1_start+segment1_length]\n            segment2 = new_solution[segment2_start:segment2_start+segment2_length]\n\n            new_solution[segment1_start:segment1_start+segment1_length] = np.roll(segment2, 1)\n            new_solution[segment2_start:segment2_start+segment2_length] = np.roll(segment1, -1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{The algorithm selects a solution from the archive based on a heuristic that prioritizes solutions with high diversity and poor objective values, then applies a novel segment inversion and adaptive node swapping strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8682893357612533,
            0.18817204236984253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        c, d = sorted(random.sample(range(n), 2))\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-node swap with objective-aware selection\" and \"adaptive segment rotation\" strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-node swap with objective-aware selection\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[d], new_solution[(c+1)%n]] -\n                        distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] -\n                        distance_matrix_1[new_solution[c-1], new_solution[c]] - distance_matrix_1[new_solution[c], new_solution[(c+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d], new_solution[(c+1)%n]] -\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] -\n                        distance_matrix_2[new_solution[c-1], new_solution[c]] - distance_matrix_2[new_solution[c], new_solution[(c+1)%n]])\n\n        # Apply swap if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        # Adaptive segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate the segment by a random amount\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_length] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7896663288012946,
            0.2833653688430786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-node swap with objective-aware selection\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[d], new_solution[(c+1)%n]] -\n                        distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] -\n                        distance_matrix_1[new_solution[c-1], new_solution[c]] - distance_matrix_1[new_solution[c], new_solution[(c+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] +\n                        distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d], new_solution[(c+1)%n]] -\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] -\n                        distance_matrix_2[new_solution[c-1], new_solution[c]] - distance_matrix_2[new_solution[c], new_solution[(c+1)%n]])\n\n        # Apply swap if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        # Adaptive segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate the segment by a random amount\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_length] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + cross-segment rotation\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and invert it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate one into the other\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, first_length)\n            rotated_segment = np.roll(first_segment, rotation_point)\n            new_solution[second_start:second_start+second_length] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.902627234963127,
            0.09137380123138428
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + cross-segment rotation\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and invert it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate one into the other\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, first_length)\n            rotated_segment = np.roll(first_segment, rotation_point)\n            new_solution[second_start:second_start+second_length] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and spatial proximity, then applies a novel \"coordinate-aware segment swapping\" strategy that exchanges segments of the tour while preserving spatial relationships in both objective spaces to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and spatial proximity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Coordinate-aware segment swapping\n        segment_length = np.random.randint(2, min(5, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        segment1 = new_solution[start1:start1+segment_length]\n\n        # Find best matching segment in the other space based on spatial proximity\n        min_distance = float('inf')\n        best_start2 = start1\n        for start2 in range(n - segment_length):\n            if start2 != start1:\n                segment2 = new_solution[start2:start2+segment_length]\n                # Calculate spatial distance between corresponding nodes in both spaces\n                dist1 = np.mean([np.linalg.norm(instance[segment1[i], :2] - instance[segment2[i], :2]) for i in range(segment_length)])\n                dist2 = np.mean([np.linalg.norm(instance[segment1[i], 2:] - instance[segment2[i], 2:]) for i in range(segment_length)])\n                total_dist = dist1 + dist2\n                if total_dist < min_distance:\n                    min_distance = total_dist\n                    best_start2 = start2\n\n        segment2 = new_solution[best_start2:best_start2+segment_length]\n\n        # Swap the segments\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[best_start2:best_start2+segment_length] = segment1\n\n    return new_solution\n\n",
        "score": [
            -0.9678975476387961,
            0.7102917432785034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and spatial proximity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Coordinate-aware segment swapping\n        segment_length = np.random.randint(2, min(5, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        segment1 = new_solution[start1:start1+segment_length]\n\n        # Find best matching segment in the other space based on spatial proximity\n        min_distance = float('inf')\n        best_start2 = start1\n        for start2 in range(n - segment_length):\n            if start2 != start1:\n                segment2 = new_solution[start2:start2+segment_length]\n                # Calculate spatial distance between corresponding nodes in both spaces\n                dist1 = np.mean([np.linalg.norm(instance[segment1[i], :2] - instance[segment2[i], :2]) for i in range(segment_length)])\n                dist2 = np.mean([np.linalg.norm(instance[segment1[i], 2:] - instance[segment2[i], 2:]) for i in range(segment_length)])\n                total_dist = dist1 + dist2\n                if total_dist < min_distance:\n                    min_distance = total_dist\n                    best_start2 = start2\n\n        segment2 = new_solution[best_start2:best_start2+segment_length]\n\n        # Swap the segments\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[best_start2:best_start2+segment_length] = segment1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective dominance and crowding distance, then applies a hybrid local search combining segment reversal with adaptive node insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    # Select two random segments and reverse one of them\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Adaptive node insertion\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.array([x for x in new_solution if x != node])\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9433106675232906,
            0.29970550537109375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    # Select two random segments and reverse one of them\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Adaptive node insertion\n    if random.random() < 0.5:\n        node = random.choice(new_solution)\n        new_solution = np.array([x for x in new_solution if x != node])\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel \"adaptive segment crossover\" operator that intelligently combines segments from the selected solution with segments from a randomly generated solution, while ensuring feasibility through careful segment alignment and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objectives and diversity for selection\n    weights = np.random.uniform(0.2, 0.8)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = np.zeros_like(base_solution)\n    visited = set()\n\n    # Generate a random solution for segment crossover\n    random_solution = np.random.permutation(n)\n\n    # Adaptive segment crossover\n    segment_length = np.random.randint(2, min(6, n))\n    start = np.random.randint(0, n - segment_length)\n\n    # Copy segment from base solution\n    new_solution[start:start+segment_length] = base_solution[start:start+segment_length]\n    visited.update(base_solution[start:start+segment_length])\n\n    # Fill remaining positions with segments from random solution\n    remaining_indices = [i for i in range(n) if i < start or i >= start+segment_length]\n    random_indices = [i for i in range(n) if random_solution[i] not in visited]\n\n    for i, pos in enumerate(remaining_indices):\n        if i < len(random_indices):\n            new_solution[pos] = random_solution[random_indices[i]]\n            visited.add(random_solution[random_indices[i]])\n\n    # Ensure all nodes are included\n    missing_nodes = [node for node in range(n) if node not in visited]\n    for i, node in enumerate(missing_nodes):\n        empty_pos = np.where(new_solution == 0)[0][0]\n        new_solution[empty_pos] = node\n\n    return new_solution\n\n",
        "score": [
            -0.8018999315194761,
            0.22989130020141602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objectives and diversity for selection\n    weights = np.random.uniform(0.2, 0.8)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = np.zeros_like(base_solution)\n    visited = set()\n\n    # Generate a random solution for segment crossover\n    random_solution = np.random.permutation(n)\n\n    # Adaptive segment crossover\n    segment_length = np.random.randint(2, min(6, n))\n    start = np.random.randint(0, n - segment_length)\n\n    # Copy segment from base solution\n    new_solution[start:start+segment_length] = base_solution[start:start+segment_length]\n    visited.update(base_solution[start:start+segment_length])\n\n    # Fill remaining positions with segments from random solution\n    remaining_indices = [i for i in range(n) if i < start or i >= start+segment_length]\n    random_indices = [i for i in range(n) if random_solution[i] not in visited]\n\n    for i, pos in enumerate(remaining_indices):\n        if i < len(random_indices):\n            new_solution[pos] = random_solution[random_indices[i]]\n            visited.add(random_solution[random_indices[i]])\n\n    # Ensure all nodes are included\n    missing_nodes = [node for node in range(n) if node not in visited]\n    for i, node in enumerate(missing_nodes):\n        empty_pos = np.where(new_solution == 0)[0][0]\n        new_solution[empty_pos] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" and an additional \"node inversion\" step to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n            if np.random.random() < 0.3:\n                invert_start = np.random.randint(0, n - 2)\n                invert_end = np.random.randint(invert_start + 2, n)\n                new_solution[invert_start:invert_end] = new_solution[invert_start:invert_end][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment rotation\" with \"objective-aware node insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.roll(segment, rotation)\n\n        if segment_cost1 > sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1)):\n            new_solution[start:start+segment_length] = rotated_segment\n        elif segment_cost2 > sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1)):\n            new_solution[start:start+segment_length] = rotated_segment\n\n        if n > 8 and np.random.random() < 0.5:\n            node_to_insert = np.random.randint(0, n)\n            insert_pos = np.random.randint(0, n)\n            if insert_pos != node_to_insert and insert_pos != (node_to_insert + 1) % n:\n                node = new_solution[node_to_insert]\n                new_solution = np.delete(new_solution, node_to_insert)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8803765988019552,
            0.29874151945114136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        rotation = np.random.randint(1, len(segment))\n        rotated_segment = np.roll(segment, rotation)\n\n        if segment_cost1 > sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1)):\n            new_solution[start:start+segment_length] = rotated_segment\n        elif segment_cost2 > sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1)):\n            new_solution[start:start+segment_length] = rotated_segment\n\n        if n > 8 and np.random.random() < 0.5:\n            node_to_insert = np.random.randint(0, n)\n            insert_pos = np.random.randint(0, n)\n            if insert_pos != node_to_insert and insert_pos != (node_to_insert + 1) % n:\n                node = new_solution[node_to_insert]\n                new_solution = np.delete(new_solution, node_to_insert)\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining a novel \"multi-node rotation\" with an \"objective-aware insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Normalized objective score with randomness\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-node rotation + objective-aware insertion\n    if n > 4:\n        # Multi-node rotation: Rotate a segment of 2-4 nodes\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated = np.roll(segment, np.random.randint(1, segment_length))\n        new_solution[start:start+segment_length] = rotated\n\n        # Objective-aware insertion: Insert a node from a distant position\n        if n > 8:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) < n // 3:\n                j = np.random.randint(0, n)\n            if i > j:\n                i, j = j, i\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8808857307970526,
            0.12743699550628662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Normalized objective score with randomness\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-node rotation + objective-aware insertion\n    if n > 4:\n        # Multi-node rotation: Rotate a segment of 2-4 nodes\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated = np.roll(segment, np.random.randint(1, segment_length))\n        new_solution[start:start+segment_length] = rotated\n\n        # Objective-aware insertion: Insert a node from a distant position\n        if n > 8:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(i - j) < n // 3:\n                j = np.random.randint(0, n)\n            if i > j:\n                i, j = j, i\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective improvement potential and structural diversity, then applies a novel \"adaptive multi-segment crossover\" with \"objective-aware segment reinsertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high potential for improvement\n    archive_with_potential = []\n    for sol, obj in archive:\n        obj1, obj2 = obj\n        potential = obj1 * obj2 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0\n        archive_with_potential.append((sol, potential))\n    archive_with_potential.sort(key=lambda x: -x[1])\n    selected_idx = min(int(len(archive_with_potential)*0.3), len(archive_with_potential)-1)\n    base_solution = archive_with_potential[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Adaptive multi-segment crossover\n    num_segments = np.random.randint(2, min(4, n//3))\n    segment_lengths = sorted(np.random.choice(range(2, min(6, n//2)), num_segments, replace=False))\n    segments = []\n\n    # Extract segments\n    for length in segment_lengths:\n        start = np.random.randint(0, n - length)\n        segments.append(new_solution[start:start+length])\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+length:]])\n\n    # Objective-aware segment reinsertion\n    insertion_points = sorted(np.random.choice(range(len(new_solution)+1), num_segments, replace=False))\n    for i, segment in enumerate(segments):\n        # Calculate segment costs in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        seg_cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Insert segment that would improve at least one objective\n        if i < len(insertion_points):\n            new_solution = np.concatenate([new_solution[:insertion_points[i]], segment, new_solution[insertion_points[i]:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        return base_solution\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and structural diversity, then applies a novel \"adaptive multi-segment crossover\" with \"objective-aware segment reinsertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high potential for improvement\n    archive_with_potential = []\n    for sol, obj in archive:\n        obj1, obj2 = obj\n        potential = obj1 * obj2 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0\n        archive_with_potential.append((sol, potential))\n    archive_with_potential.sort(key=lambda x: -x[1])\n    selected_idx = min(int(len(archive_with_potential)*0.3), len(archive_with_potential)-1)\n    base_solution = archive_with_potential[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Novel \"objective-balanced segment inversion\" with \"distance-aware reordering\"\n    num_segments = np.random.randint(2, min(4, n//3))\n    segment_lengths = sorted(np.random.choice(range(2, min(6, n//2)), num_segments, replace=False))\n    segments = []\n\n    # Extract segments and calculate their balanced costs\n    for length in segment_lengths:\n        start = np.random.randint(0, n - length)\n        segments.append(new_solution[start:start+length])\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+length:]])\n\n    # Reorder segments based on balanced objective improvement potential\n    segment_scores = []\n    for segment in segments:\n        seg_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        seg_cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        balanced_score = (seg_cost1 + seg_cost2) / (seg_cost1 * seg_cost2) if (seg_cost1 * seg_cost2) > 0 else 0\n        segment_scores.append(balanced_score)\n\n    # Sort segments by score (descending) and reinsert\n    sorted_segments = [x for _, x in sorted(zip(segment_scores, segments), reverse=True)]\n    insertion_points = sorted(np.random.choice(range(len(new_solution)+1), num_segments, replace=False))\n    for i, segment in enumerate(sorted_segments):\n        if i < len(insertion_points):\n            new_solution = np.concatenate([new_solution[:insertion_points[i]], segment, new_solution[insertion_points[i]:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8270159675092483,
            0.29381632804870605
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high potential for improvement\n    archive_with_potential = []\n    for sol, obj in archive:\n        obj1, obj2 = obj\n        potential = obj1 * obj2 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0\n        archive_with_potential.append((sol, potential))\n    archive_with_potential.sort(key=lambda x: -x[1])\n    selected_idx = min(int(len(archive_with_potential)*0.3), len(archive_with_potential)-1)\n    base_solution = archive_with_potential[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Novel \"objective-balanced segment inversion\" with \"distance-aware reordering\"\n    num_segments = np.random.randint(2, min(4, n//3))\n    segment_lengths = sorted(np.random.choice(range(2, min(6, n//2)), num_segments, replace=False))\n    segments = []\n\n    # Extract segments and calculate their balanced costs\n    for length in segment_lengths:\n        start = np.random.randint(0, n - length)\n        segments.append(new_solution[start:start+length])\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+length:]])\n\n    # Reorder segments based on balanced objective improvement potential\n    segment_scores = []\n    for segment in segments:\n        seg_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        seg_cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        balanced_score = (seg_cost1 + seg_cost2) / (seg_cost1 * seg_cost2) if (seg_cost1 * seg_cost2) > 0 else 0\n        segment_scores.append(balanced_score)\n\n    # Sort segments by score (descending) and reinsert\n    sorted_segments = [x for _, x in sorted(zip(segment_scores, segments), reverse=True)]\n    insertion_points = sorted(np.random.choice(range(len(new_solution)+1), num_segments, replace=False))\n    for i, segment in enumerate(sorted_segments):\n        if i < len(insertion_points):\n            new_solution = np.concatenate([new_solution[:insertion_points[i]], segment, new_solution[insertion_points[i]:]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"cross-segment relocation\" with an \"objective-aware node insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Cross-segment relocation with objective-aware node insertion\n    if n > 4:\n        # Cross-segment relocation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Relocate segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            insert_pos = np.random.randint(0, n - segment_length)\n            if insert_pos != start:\n                new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Objective-aware node insertion\n        if n > 6:\n            node_to_insert = np.random.choice(new_solution)\n            new_solution = new_solution[new_solution != node_to_insert]\n            insert_pos = np.random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.7029432130078842,
            0.17667341232299805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Cross-segment relocation with objective-aware node insertion\n    if n > 4:\n        # Cross-segment relocation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Relocate segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            insert_pos = np.random.randint(0, n - segment_length)\n            if insert_pos != start:\n                new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Objective-aware node insertion\n        if n > 6:\n            node_to_insert = np.random.choice(new_solution)\n            new_solution = new_solution[new_solution != node_to_insert]\n            insert_pos = np.random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8696542665626716,
            0.07769054174423218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"node insertion\" with a \"reverse segment\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node insertion + reverse segment\n    if n > 4:\n        # Node insertion: Remove a random node and insert it at a different position\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse segment: Reverse a segment of 2-5 nodes\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9059837537067033,
            0.22075027227401733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node insertion + reverse segment\n    if n > 4:\n        # Node insertion: Remove a random node and insert it at a different position\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse segment: Reverse a segment of 2-5 nodes\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length + 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8925259502193565,
            0.07236272096633911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and spatial locality, then applies a hybrid local search combining a novel \"adaptive segment rotation\" with a \"multi-objective segment replacement\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with good balance in objectives and spatial locality\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(archive_sorted))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment rotation + multi-objective segment replacement\n    if n > 6:\n        # Adaptive segment rotation\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment based on objective dominance\n        cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        if cost1 > cost2:\n            new_solution[start:start+segment_length] = np.roll(segment, 1)\n        else:\n            new_solution[start:start+segment_length] = np.roll(segment, -1)\n\n        # Multi-objective segment replacement\n        if n > 8:\n            candidate_pos = np.random.randint(0, n - 4)\n            candidate_segment = new_solution[candidate_pos:candidate_pos+4]\n\n            # Find replacement segment with better balance in objectives\n            best_replacement = None\n            best_balance = float('inf')\n\n            for i in range(n - 4):\n                test_segment = new_solution[i:i+4]\n                test_cost1 = sum(distance_matrix_1[test_segment[j], test_segment[j+1]] for j in range(3))\n                test_cost2 = sum(distance_matrix_2[test_segment[j], test_segment[j+1]] for j in range(3))\n                balance = abs(test_cost1 - test_cost2)\n\n                if balance < best_balance and not np.array_equal(test_segment, candidate_segment):\n                    best_balance = balance\n                    best_replacement = test_segment\n\n            if best_replacement is not None:\n                new_solution[candidate_pos:candidate_pos+4] = best_replacement\n\n    return new_solution\n\n",
        "score": [
            -0.861802535447787,
            0.1508270502090454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with good balance in objectives and spatial locality\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(archive_sorted))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment rotation + multi-objective segment replacement\n    if n > 6:\n        # Adaptive segment rotation\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment based on objective dominance\n        cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        if cost1 > cost2:\n            new_solution[start:start+segment_length] = np.roll(segment, 1)\n        else:\n            new_solution[start:start+segment_length] = np.roll(segment, -1)\n\n        # Multi-objective segment replacement\n        if n > 8:\n            candidate_pos = np.random.randint(0, n - 4)\n            candidate_segment = new_solution[candidate_pos:candidate_pos+4]\n\n            # Find replacement segment with better balance in objectives\n            best_replacement = None\n            best_balance = float('inf')\n\n            for i in range(n - 4):\n                test_segment = new_solution[i:i+4]\n                test_cost1 = sum(distance_matrix_1[test_segment[j], test_segment[j+1]] for j in range(3))\n                test_cost2 = sum(distance_matrix_2[test_segment[j], test_segment[j+1]] for j in range(3))\n                balance = abs(test_cost1 - test_cost2)\n\n                if balance < best_balance and not np.array_equal(test_segment, candidate_segment):\n                    best_balance = balance\n                    best_replacement = test_segment\n\n            if best_replacement is not None:\n                new_solution[candidate_pos:candidate_pos+4] = best_replacement\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This algorithm selects a solution from the archive with the best combined objective score, then applies a hybrid local search combining segment inversion and adaptive node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = np.argmin([(obj[0] + obj[1]) / (1 + np.random.uniform(0.1, 0.3)) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        node = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7465964864153343,
            0.2543707489967346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = np.argmin([(obj[0] + obj[1]) / (1 + np.random.uniform(0.1, 0.3)) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        node = new_solution[c]\n        new_solution = np.delete(new_solution, c)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node chain inversion\" with an \"objective-aware segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node chain inversion with objective-aware segment rotation\n    if n > 4:\n        # Adaptive node chain inversion\n        chain_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n\n        # Calculate chain costs in both objectives\n        chain_cost1 = sum(distance_matrix_1[chain[i], chain[i+1]] for i in range(len(chain)-1))\n        chain_cost2 = sum(distance_matrix_2[chain[i], chain[i+1]] for i in range(len(chain)-1))\n\n        # Invert chain if it improves at least one objective\n        if chain_cost1 > distance_matrix_1[chain[-1], chain[0]] or chain_cost2 > distance_matrix_2[chain[-1], chain[0]]:\n            new_solution[start:start+chain_length] = chain[::-1]\n\n        # Objective-aware segment rotation\n        if n > 8:\n            segment_length = np.random.randint(2, min(6, n))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Rotate segment if it improves the weaker objective\n            if segment_cost1 < segment_cost2 and segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n                new_solution[start:start+segment_length] = np.roll(segment, 1)\n            elif segment_cost2 < segment_cost1 and segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n                new_solution[start:start+segment_length] = np.roll(segment, -1)\n\n    return new_solution\n\n",
        "score": [
            -0.9173432239309893,
            0.3577035069465637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node chain inversion with objective-aware segment rotation\n    if n > 4:\n        # Adaptive node chain inversion\n        chain_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n\n        # Calculate chain costs in both objectives\n        chain_cost1 = sum(distance_matrix_1[chain[i], chain[i+1]] for i in range(len(chain)-1))\n        chain_cost2 = sum(distance_matrix_2[chain[i], chain[i+1]] for i in range(len(chain)-1))\n\n        # Invert chain if it improves at least one objective\n        if chain_cost1 > distance_matrix_1[chain[-1], chain[0]] or chain_cost2 > distance_matrix_2[chain[-1], chain[0]]:\n            new_solution[start:start+chain_length] = chain[::-1]\n\n        # Objective-aware segment rotation\n        if n > 8:\n            segment_length = np.random.randint(2, min(6, n))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Rotate segment if it improves the weaker objective\n            if segment_cost1 < segment_cost2 and segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n                new_solution[start:start+segment_length] = np.roll(segment, 1)\n            elif segment_cost2 < segment_cost1 and segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n                new_solution[start:start+segment_length] = np.roll(segment, -1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility, but with a different approach by introducing a \"localized multi-segment inversion\" strategy that adaptively selects and inverts multiple non-overlapping segments based on their combined objective improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and moderate objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Localized multi-segment inversion\n    if n > 8:\n        # Determine number of segments to invert\n        num_segments = np.random.randint(2, min(4, n//4))\n\n        # Generate non-overlapping segments\n        segment_starts = sorted(np.random.choice(range(n-4), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(6, (n-4)//num_segments), size=num_segments)\n\n        # Process each segment\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n\n            # Calculate segment costs\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert if it improves both objectives\n            if (cost1 > distance_matrix_1[segment[-1], segment[0]] and\n                cost2 > distance_matrix_2[segment[-1], segment[0]]):\n                new_solution[start:start+length] = segment[::-1]\n\n        # Additional segment merge for diversity\n        if num_segments > 1 and n > 12:\n            merge_start = np.random.randint(0, n//2 - 3)\n            merge_length = np.random.randint(3, min(6, n//2 - merge_start))\n\n            # Select two non-adjacent segments\n            seg1 = new_solution[merge_start:merge_start+merge_length]\n            seg2 = new_solution[merge_start+merge_length:merge_start+2*merge_length]\n\n            # Merge if it improves diversity\n            if len(set(seg1)) > len(set(seg2)):\n                new_solution[merge_start:merge_start+2*merge_length] = np.concatenate([seg2, seg1])\n\n    return new_solution\n\n",
        "score": [
            -0.8496430032893019,
            0.32113927602767944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and moderate objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Localized multi-segment inversion\n    if n > 8:\n        # Determine number of segments to invert\n        num_segments = np.random.randint(2, min(4, n//4))\n\n        # Generate non-overlapping segments\n        segment_starts = sorted(np.random.choice(range(n-4), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(6, (n-4)//num_segments), size=num_segments)\n\n        # Process each segment\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n\n            # Calculate segment costs\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert if it improves both objectives\n            if (cost1 > distance_matrix_1[segment[-1], segment[0]] and\n                cost2 > distance_matrix_2[segment[-1], segment[0]]):\n                new_solution[start:start+length] = segment[::-1]\n\n        # Additional segment merge for diversity\n        if num_segments > 1 and n > 12:\n            merge_start = np.random.randint(0, n//2 - 3)\n            merge_length = np.random.randint(3, min(6, n//2 - merge_start))\n\n            # Select two non-adjacent segments\n            seg1 = new_solution[merge_start:merge_start+merge_length]\n            seg2 = new_solution[merge_start+merge_length:merge_start+2*merge_length]\n\n            # Merge if it improves diversity\n            if len(set(seg1)) > len(set(seg2)):\n                new_solution[merge_start:merge_start+2*merge_length] = np.concatenate([seg2, seg1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{The new algorithm selects a solution from the archive based on a heuristic that prioritizes solutions with lower combined objective values while maintaining diversity, then applies a hybrid segment inversion and adaptive reinsertion strategy that combines local refinement with global perturbation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        c = random.randint(0, n-1)\n        node = new_solution[c]\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [node]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8683279820866128,
            0.2314739227294922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        c = random.randint(0, n-1)\n        node = new_solution[c]\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [node]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and spatial diversity, then applies a hybrid local search combining a novel \"polarity-based node relocation\" with \"objective-aware edge contraction\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective values with spatial diversity\n    weighted_scores = []\n    for sol, obj in archive:\n        diversity = np.sum(np.abs(instance[sol, :2] - instance[sol, 2:]))  # Spatial diversity\n        weighted_score = 0.6 * (obj[0] + obj[1]) + 0.4 * diversity\n        weighted_scores.append(weighted_score)\n\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Polarity-based node relocation + objective-aware edge contraction\n    if n > 3:\n        # Polarity-based node relocation\n        relocate_pos = np.random.randint(1, n-1)\n        node = new_solution[relocate_pos]\n\n        # Calculate polarity (difference in objective distances)\n        left_node = new_solution[relocate_pos-1]\n        right_node = new_solution[(relocate_pos+1)%n]\n        polarity = (distance_matrix_1[node, left_node] - distance_matrix_1[node, right_node] +\n                    distance_matrix_2[node, left_node] - distance_matrix_2[node, right_node])\n\n        if polarity > 0:  # Positive polarity: prefer left insertion\n            new_pos = np.random.randint(0, relocate_pos)\n        else:  # Negative polarity: prefer right insertion\n            new_pos = np.random.randint(relocate_pos+1, n)\n\n        new_solution = np.delete(new_solution, relocate_pos)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n        # Objective-aware edge contraction\n        if n > 6:\n            i = np.random.randint(0, n-2)\n            j = np.random.randint(i+1, n-1)\n            node_i, node_j = new_solution[i], new_solution[j]\n\n            # Calculate potential improvement in both objectives\n            old_cost = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] +\n                         distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]])\n            new_cost = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] +\n                         distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]])\n\n            if new_cost < 1.1 * old_cost:  # Accept if improvement is reasonable\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8020475555185098,
            0.5448947548866272
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective values with spatial diversity\n    weighted_scores = []\n    for sol, obj in archive:\n        diversity = np.sum(np.abs(instance[sol, :2] - instance[sol, 2:]))  # Spatial diversity\n        weighted_score = 0.6 * (obj[0] + obj[1]) + 0.4 * diversity\n        weighted_scores.append(weighted_score)\n\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Polarity-based node relocation + objective-aware edge contraction\n    if n > 3:\n        # Polarity-based node relocation\n        relocate_pos = np.random.randint(1, n-1)\n        node = new_solution[relocate_pos]\n\n        # Calculate polarity (difference in objective distances)\n        left_node = new_solution[relocate_pos-1]\n        right_node = new_solution[(relocate_pos+1)%n]\n        polarity = (distance_matrix_1[node, left_node] - distance_matrix_1[node, right_node] +\n                    distance_matrix_2[node, left_node] - distance_matrix_2[node, right_node])\n\n        if polarity > 0:  # Positive polarity: prefer left insertion\n            new_pos = np.random.randint(0, relocate_pos)\n        else:  # Negative polarity: prefer right insertion\n            new_pos = np.random.randint(relocate_pos+1, n)\n\n        new_solution = np.delete(new_solution, relocate_pos)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n        # Objective-aware edge contraction\n        if n > 6:\n            i = np.random.randint(0, n-2)\n            j = np.random.randint(i+1, n-1)\n            node_i, node_j = new_solution[i], new_solution[j]\n\n            # Calculate potential improvement in both objectives\n            old_cost = (distance_matrix_1[new_solution[i-1], node_i] + distance_matrix_1[node_i, new_solution[i+1]] +\n                         distance_matrix_2[new_solution[i-1], node_i] + distance_matrix_2[node_i, new_solution[i+1]])\n            new_cost = (distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[i+1]] +\n                         distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[i+1]])\n\n            if new_cost < 1.1 * old_cost:  # Accept if improvement is reasonable\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment inversion and adaptive reinsertion strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        if c != d:\n            new_solution = np.concatenate([new_solution[:c], [new_solution[d]], new_solution[c+1:d], new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8802266807245068,
            0.28375256061553955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        if c != d:\n            new_solution = np.concatenate([new_solution[:c], [new_solution[d]], new_solution[c+1:d], new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{The algorithm selects a solution from the archive based on a combined objective score and diversity metric, then applies an adaptive segment inversion and reinsertion strategy that dynamically balances local and global perturbations to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sum(normalized_obj, axis=1)\n    probabilities = combined_scores / combined_scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        if c != d:\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    if random.random() < 0.2:\n        e = random.randint(0, n-3)\n        f = random.randint(e+1, n-1)\n        new_solution = np.concatenate([new_solution[:e], new_solution[e+1:f+1], [new_solution[e]], new_solution[f+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8919394778894225,
            0.2684847116470337
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = np.sum(normalized_obj, axis=1)\n    probabilities = combined_scores / combined_scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        if c != d:\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    if random.random() < 0.2:\n        e = random.randint(0, n-3)\n        f = random.randint(e+1, n-1)\n        new_solution = np.concatenate([new_solution[:e], new_solution[e+1:f+1], [new_solution[e]], new_solution[f+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment insertion\" with \"objective-biased segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion with objective-biased segment rotation\n    if n > 4:\n        # Objective-biased segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            rotated_segment = np.roll(segment, 1)\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Adaptive segment insertion with diversity consideration\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            source_start = np.random.randint(0, n - segment_length)\n            target_pos = np.random.randint(0, n - segment_length)\n\n            segment = new_solution[source_start:source_start+segment_length]\n\n            # Insert segment if it improves diversity\n            if len(set(segment)) > len(set(new_solution[target_pos:target_pos+segment_length])):\n                new_solution = np.concatenate([\n                    new_solution[:target_pos],\n                    segment,\n                    new_solution[target_pos+segment_length:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.7702441012410753,
            0.5839078426361084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion with objective-biased segment rotation\n    if n > 4:\n        # Objective-biased segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            rotated_segment = np.roll(segment, 1)\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Adaptive segment insertion with diversity consideration\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            source_start = np.random.randint(0, n - segment_length)\n            target_pos = np.random.randint(0, n - segment_length)\n\n            segment = new_solution[source_start:source_start+segment_length]\n\n            # Insert segment if it improves diversity\n            if len(set(segment)) > len(set(new_solution[target_pos:target_pos+segment_length])):\n                new_solution = np.concatenate([\n                    new_solution[:target_pos],\n                    segment,\n                    new_solution[target_pos+segment_length:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9808051598457965,
            0.11789566278457642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"adaptive segment inversion with objective-aware merging\" strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    # Selection: Prioritize solutions with good balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] * x[1][1]))\n    selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment inversion with objective-aware merging\n    segment_length = random.randint(2, min(5, n // 2))\n    start_pos = random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Calculate segment costs\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    # Invert segment if it improves at least one objective\n    if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n        new_solution[start_pos:start_pos + segment_length] = segment[::-1]\n\n    # Objective-aware merging\n    if n > 6:\n        merge_pos = random.randint(0, n - segment_length - 1)\n        merge_segment = new_solution[merge_pos:merge_pos + segment_length]\n\n        # Calculate merge segment costs\n        merge_cost1 = sum(distance_matrix_1[merge_segment[i], merge_segment[i+1]] for i in range(len(merge_segment)-1))\n        merge_cost2 = sum(distance_matrix_2[merge_segment[i], merge_segment[i+1]] for i in range(len(merge_segment)-1))\n\n        # Merge segments if it improves both objectives\n        if merge_cost1 > distance_matrix_1[merge_segment[-1], merge_segment[0]] and merge_cost2 > distance_matrix_2[merge_segment[-1], merge_segment[0]]:\n            new_solution[merge_pos:merge_pos + segment_length] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6111538979135867,
            1.3130751848220825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    # Selection: Prioritize solutions with good balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] * x[1][1]))\n    selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment inversion with objective-aware merging\n    segment_length = random.randint(2, min(5, n // 2))\n    start_pos = random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Calculate segment costs\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    # Invert segment if it improves at least one objective\n    if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n        new_solution[start_pos:start_pos + segment_length] = segment[::-1]\n\n    # Objective-aware merging\n    if n > 6:\n        merge_pos = random.randint(0, n - segment_length - 1)\n        merge_segment = new_solution[merge_pos:merge_pos + segment_length]\n\n        # Calculate merge segment costs\n        merge_cost1 = sum(distance_matrix_1[merge_segment[i], merge_segment[i+1]] for i in range(len(merge_segment)-1))\n        merge_cost2 = sum(distance_matrix_2[merge_segment[i], merge_segment[i+1]] for i in range(len(merge_segment)-1))\n\n        # Merge segments if it improves both objectives\n        if merge_cost1 > distance_matrix_1[merge_segment[-1], merge_segment[0]] and merge_cost2 > distance_matrix_2[merge_segment[-1], merge_segment[0]]:\n            new_solution[merge_pos:merge_pos + segment_length] = segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{The new algorithm selects a solution from the archive based on a diversity-aware heuristic, then applies a hybrid segment inversion and adaptive displacement strategy that combines local reordering with global perturbation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 3:\n        return archive[0][0].copy()\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        while d == c:\n            d = random.randint(0, n-1)\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8813835591451131,
            0.18651443719863892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 3:\n        return archive[0][0].copy()\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.4:\n        c = random.randint(0, n-1)\n        d = random.randint(0, n-1)\n        while d == c:\n            d = random.randint(0, n-1)\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a hybrid local search combining a novel \"multi-segment rotation\" with \"objective-aware segment inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment rotation with objective-aware segment inversion\n    if n > 4:\n        # Multi-segment rotation\n        k = np.random.randint(2, min(4, n//2))\n        segment_length = n // k\n        segments = [new_solution[i*segment_length:(i+1)*segment_length] for i in range(k)]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Objective-aware segment inversion\n        for _ in range(2):\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or \\\n               segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n                new_solution[start:start+segment_length] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8270801867877036,
            0.18629801273345947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment rotation with objective-aware segment inversion\n    if n > 4:\n        # Multi-segment rotation\n        k = np.random.randint(2, min(4, n//2))\n        segment_length = n // k\n        segments = [new_solution[i*segment_length:(i+1)*segment_length] for i in range(k)]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Objective-aware segment inversion\n        for _ in range(2):\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or \\\n               segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n                new_solution[start:start+segment_length] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9893647956588854,
            0.07638520002365112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This algorithm selects the best solution from the archive based on a weighted combination of objectives, then applies a novel \"objective-aware node insertion\" strategy that intelligently reinserts nodes to improve both objectives while ensuring feasibility through a feasibility-preserving mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose the best solution based on weighted objectives\n    weighted_scores = [0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive]\n    best_idx = np.argmin(weighted_scores)\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node insertion\n    if n > 3:\n        # Select a random node to reinsert\n        node_pos = np.random.randint(1, n-1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node_pos or pos == node_pos - 1:\n                continue\n\n            # Calculate potential improvement in both objectives\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            new_prev_node = new_solution[node_pos-1] if node_pos > 0 else new_solution[-1]\n            new_next_node = new_solution[node_pos] if node_pos < n else new_solution[0]\n\n            original_cost1 = distance_matrix_1[new_prev_node, node] + distance_matrix_1[node, new_next_node]\n            original_cost2 = distance_matrix_2[new_prev_node, node] + distance_matrix_2[node, new_next_node]\n\n            improvement1 = original_cost1 - current_cost1\n            improvement2 = original_cost2 - current_cost2\n\n            # Weighted improvement score\n            improvement_score = 0.6 * improvement1 + 0.4 * improvement2\n\n            if improvement_score > best_improvement:\n                best_improvement = improvement_score\n                best_pos = pos\n\n        # Perform the insertion if it improves at least one objective\n        if best_improvement > 0:\n            # Remove the node from its current position\n            new_solution = np.delete(new_solution, node_pos)\n            # Insert it at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6094269167125249,
            1.91767418384552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose the best solution based on weighted objectives\n    weighted_scores = [0.6 * obj[0] + 0.4 * obj[1] for _, obj in archive]\n    best_idx = np.argmin(weighted_scores)\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node insertion\n    if n > 3:\n        # Select a random node to reinsert\n        node_pos = np.random.randint(1, n-1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node_pos or pos == node_pos - 1:\n                continue\n\n            # Calculate potential improvement in both objectives\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            new_prev_node = new_solution[node_pos-1] if node_pos > 0 else new_solution[-1]\n            new_next_node = new_solution[node_pos] if node_pos < n else new_solution[0]\n\n            original_cost1 = distance_matrix_1[new_prev_node, node] + distance_matrix_1[node, new_next_node]\n            original_cost2 = distance_matrix_2[new_prev_node, node] + distance_matrix_2[node, new_next_node]\n\n            improvement1 = original_cost1 - current_cost1\n            improvement2 = original_cost2 - current_cost2\n\n            # Weighted improvement score\n            improvement_score = 0.6 * improvement1 + 0.4 * improvement2\n\n            if improvement_score > best_improvement:\n                best_improvement = improvement_score\n                best_pos = pos\n\n        # Perform the insertion if it improves at least one objective\n        if best_improvement > 0:\n            # Remove the node from its current position\n            new_solution = np.delete(new_solution, node_pos)\n            # Insert it at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and structural diversity, then applies a novel \"objective-aware segment inversion and cross-segment fusion\" strategy to generate neighbors by intelligently merging segments from different parts of the solution while ensuring feasibility through careful validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and structural diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Objective-aware segment inversion\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment fusion with structural validation\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments with structural validation\n            temp_solution = new_solution.copy()\n            temp_solution[first_start:first_start+first_length] = second_segment\n            temp_solution[second_start:second_start+first_length] = first_segment\n\n            # Check feasibility\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6855524190321862,
            0.2851804494857788
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and structural diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Objective-aware segment inversion\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment fusion with structural validation\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments with structural validation\n            temp_solution = new_solution.copy()\n            temp_solution[first_start:first_start+first_length] = second_segment\n            temp_solution[second_start:second_start+first_length] = first_segment\n\n            # Check feasibility\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a novel \"segment inversion and distance-aware relocation\" strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion: Invert a random segment of the solution\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Distance-aware relocation: Relocate a random segment to minimize distance in both objectives\n        if n > 6:\n            segment_length = np.random.randint(2, min(5, n//3))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8204652648707291,
            0.633945107460022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion: Invert a random segment of the solution\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Distance-aware relocation: Relocate a random segment to minimize distance in both objectives\n        if n > 6:\n            segment_length = np.random.randint(2, min(5, n//3))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9429680374792616,
            0.09284764528274536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.820586606300105,
            0.14769256114959717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(8, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(8, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8901715616882876,
            0.07543081045150757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(8, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(8, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node insertion\" with \"objective-biased segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node insertion with objective-biased segment rotation\n    if n > 4:\n        # Objective-biased segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            rotation = np.random.randint(1, len(segment))\n            new_solution[start:start+segment_length] = np.roll(segment, rotation)\n\n        # Adaptive node insertion\n        if n > 6:\n            node_to_insert = np.random.choice(new_solution)\n            position = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, position, node_to_insert)\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.8266891732357945,
            0.29996782541275024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node insertion with objective-biased segment rotation\n    if n > 4:\n        # Objective-biased segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            rotation = np.random.randint(1, len(segment))\n            new_solution[start:start+segment_length] = np.roll(segment, rotation)\n\n        # Adaptive node insertion\n        if n > 6:\n            node_to_insert = np.random.choice(new_solution)\n            position = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, position, node_to_insert)\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel \"adaptive segment insertion\" with \"objective-aware node relocation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with objective-aware node relocation\n    if n > 3:\n        # Select a random segment to remove\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Remove the segment\n        new_solution = np.delete(new_solution, np.arange(start, start+segment_length))\n\n        # Find the best insertion point for the segment\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n        best_pos = 0\n\n        for i in range(len(new_solution)):\n            # Insert the segment at position i\n            temp_solution = np.insert(new_solution, i, segment)\n            # Calculate the cost of the inserted segment\n            cost1 = sum(distance_matrix_1[temp_solution[i+j], temp_solution[i+j+1]] for j in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[temp_solution[i+j], temp_solution[i+j+1]] for j in range(len(segment)-1))\n            # Calculate the total cost of the new solution\n            total_cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(len(temp_solution)-1))\n            total_cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(len(temp_solution)-1))\n\n            # Objective-aware selection\n            if (total_cost1 < best_cost1 and total_cost2 <= best_cost2) or (total_cost2 < best_cost2 and total_cost1 <= best_cost1):\n                best_cost1 = total_cost1\n                best_cost2 = total_cost2\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n        # Objective-aware node relocation\n        if n > 6:\n            # Select a random node to relocate\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n\n            # Remove the node\n            new_solution = np.delete(new_solution, node_pos)\n\n            # Find the best position to insert the node\n            best_cost = float('inf')\n            best_pos = 0\n\n            for i in range(len(new_solution)):\n                # Insert the node at position i\n                temp_solution = np.insert(new_solution, i, node)\n                # Calculate the cost of the inserted node\n                cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]]\n                cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]]\n\n                # Objective-aware selection\n                if (cost1 + cost2) < best_cost:\n                    best_cost = cost1 + cost2\n                    best_pos = i\n\n            # Insert the node at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8909369923584991,
            1.5047884583473206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with objective-aware node relocation\n    if n > 3:\n        # Select a random segment to remove\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Remove the segment\n        new_solution = np.delete(new_solution, np.arange(start, start+segment_length))\n\n        # Find the best insertion point for the segment\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n        best_pos = 0\n\n        for i in range(len(new_solution)):\n            # Insert the segment at position i\n            temp_solution = np.insert(new_solution, i, segment)\n            # Calculate the cost of the inserted segment\n            cost1 = sum(distance_matrix_1[temp_solution[i+j], temp_solution[i+j+1]] for j in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[temp_solution[i+j], temp_solution[i+j+1]] for j in range(len(segment)-1))\n            # Calculate the total cost of the new solution\n            total_cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(len(temp_solution)-1))\n            total_cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(len(temp_solution)-1))\n\n            # Objective-aware selection\n            if (total_cost1 < best_cost1 and total_cost2 <= best_cost2) or (total_cost2 < best_cost2 and total_cost1 <= best_cost1):\n                best_cost1 = total_cost1\n                best_cost2 = total_cost2\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n        # Objective-aware node relocation\n        if n > 6:\n            # Select a random node to relocate\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n\n            # Remove the node\n            new_solution = np.delete(new_solution, node_pos)\n\n            # Find the best position to insert the node\n            best_cost = float('inf')\n            best_pos = 0\n\n            for i in range(len(new_solution)):\n                # Insert the node at position i\n                temp_solution = np.insert(new_solution, i, node)\n                # Calculate the cost of the inserted node\n                cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]]\n                cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]]\n\n                # Objective-aware selection\n                if (cost1 + cost2) < best_cost:\n                    best_cost = cost1 + cost2\n                    best_pos = i\n\n            # Insert the node at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment rotation and insertion\n    if n > 4:\n        # Segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment based on objective improvement\n        rotated_segment = np.roll(segment, 1)\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n\n        if rotated_cost1 < original_cost1:\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Segment insertion\n        if n > 8:\n            insert_pos = np.random.randint(0, n - segment_length)\n            removed_segment = new_solution[insert_pos:insert_pos+segment_length]\n\n            # Insert at a new position if it improves the other objective\n            new_pos = np.random.randint(0, n - segment_length)\n            while new_pos == insert_pos:\n                new_pos = np.random.randint(0, n - segment_length)\n\n            original_cost2 = sum(distance_matrix_2[removed_segment[i], removed_segment[i+1]] for i in range(len(removed_segment)-1))\n            new_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            if new_cost2 < original_cost2:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    new_solution[insert_pos+segment_length:new_pos],\n                    segment,\n                    new_solution[new_pos:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.9654912686404502,
            0.26360321044921875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment rotation and insertion\n    if n > 4:\n        # Segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment based on objective improvement\n        rotated_segment = np.roll(segment, 1)\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n\n        if rotated_cost1 < original_cost1:\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Segment insertion\n        if n > 8:\n            insert_pos = np.random.randint(0, n - segment_length)\n            removed_segment = new_solution[insert_pos:insert_pos+segment_length]\n\n            # Insert at a new position if it improves the other objective\n            new_pos = np.random.randint(0, n - segment_length)\n            while new_pos == insert_pos:\n                new_pos = np.random.randint(0, n - segment_length)\n\n            original_cost2 = sum(distance_matrix_2[removed_segment[i], removed_segment[i+1]] for i in range(len(removed_segment)-1))\n            new_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            if new_cost2 < original_cost2:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    new_solution[insert_pos+segment_length:new_pos],\n                    segment,\n                    new_solution[new_pos:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a hybrid local search combining a novel \"node insertion\" with an \"inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and solution quality\n    weighted_scores = []\n    for sol, obj in archive:\n        total_cost = 0.7 * obj[0] + 0.3 * obj[1]  # Weighted sum of objectives\n        weighted_scores.append(total_cost)\n\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node insertion + inversion\n    if n > 3:\n        # Node insertion: Remove a random node and insert it in a new position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Inversion: Reverse a random segment of the tour\n        if n > 4:\n            start = np.random.randint(0, n - 2)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7897568353556756,
            0.20678633451461792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and solution quality\n    weighted_scores = []\n    for sol, obj in archive:\n        total_cost = 0.7 * obj[0] + 0.3 * obj[1]  # Weighted sum of objectives\n        weighted_scores.append(total_cost)\n\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node insertion + inversion\n    if n > 3:\n        # Node insertion: Remove a random node and insert it in a new position\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = np.random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Inversion: Reverse a random segment of the tour\n        if n > 4:\n            start = np.random.randint(0, n - 2)\n            end = np.random.randint(start + 2, n)\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion with cross-segment rotation\n    if n > 4:\n        # Node segment inversion: Select a segment and invert it if it improves at least one objective\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs before inversion\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n        inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n        inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n\n        # Apply inversion if it improves at least one objective\n        if (inverted_cost1 < original_cost1) or (inverted_cost2 < original_cost2):\n            new_solution[start:start+segment_length] = inverted_segment\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate one into the other\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Rotate the first segment into the second segment\n            rotation_point = np.random.randint(0, first_length)\n            rotated_segment = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n            # Apply rotation if it improves diversity\n            if len(set(rotated_segment)) > len(set(first_segment)):\n                new_solution[first_start:first_start+first_length] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9562228588513187,
            0.2501096725463867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion with cross-segment rotation\n    if n > 4:\n        # Node segment inversion: Select a segment and invert it if it improves at least one objective\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs before inversion\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n        inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n        inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n\n        # Apply inversion if it improves at least one objective\n        if (inverted_cost1 < original_cost1) or (inverted_cost2 < original_cost2):\n            new_solution[start:start+segment_length] = inverted_segment\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate one into the other\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Rotate the first segment into the second segment\n            rotation_point = np.random.randint(0, first_length)\n            rotated_segment = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n            # Apply rotation if it improves diversity\n            if len(set(rotated_segment)) > len(set(first_segment)):\n                new_solution[first_start:first_start+first_length] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel \"multi-segment crossover\" with adaptive segment selection and \"distance-guided insertion\" to generate a neighbor solution while maintaining feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    weights = np.random.uniform(0.4, 0.6)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    if n < 6:\n        return new_solution\n\n    num_segments = np.random.randint(2, min(4, n//3))\n    segment_lengths = np.random.choice(range(2, min(5, n//2)), num_segments, replace=False)\n    segment_starts = sorted(np.random.choice(range(n - sum(segment_lengths)), num_segments, replace=False))\n\n    segments = []\n    for i in range(num_segments):\n        start = segment_starts[i]\n        length = segment_lengths[i]\n        segments.append(new_solution[start:start+length])\n\n    np.random.shuffle(segments)\n\n    new_solution = []\n    current_pos = 0\n    for i in range(num_segments):\n        if i > 0:\n            remaining_length = segment_starts[i] - segment_starts[i-1] - segment_lengths[i-1]\n            if remaining_length > 0:\n                new_solution.extend(base_solution[current_pos:current_pos+remaining_length])\n                current_pos += remaining_length\n        new_solution.extend(segments[i])\n        current_pos = segment_starts[i] + segment_lengths[i]\n\n    if current_pos < n:\n        new_solution.extend(base_solution[current_pos:])\n\n    if len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    if np.random.random() < 0.4 and n > 8:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        avg_dist1 = np.mean(distance_matrix_1)\n        avg_dist2 = np.mean(distance_matrix_2)\n\n        if (dist1 > 1.3 * avg_dist1 and dist2 > 1.3 * avg_dist2) or np.random.random() < 0.2:\n            inserted_node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [inserted_node], new_solution[i+1:j], new_solution[j+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8171273126330684,
            0.43660926818847656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    weights = np.random.uniform(0.4, 0.6)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    if n < 6:\n        return new_solution\n\n    num_segments = np.random.randint(2, min(4, n//3))\n    segment_lengths = np.random.choice(range(2, min(5, n//2)), num_segments, replace=False)\n    segment_starts = sorted(np.random.choice(range(n - sum(segment_lengths)), num_segments, replace=False))\n\n    segments = []\n    for i in range(num_segments):\n        start = segment_starts[i]\n        length = segment_lengths[i]\n        segments.append(new_solution[start:start+length])\n\n    np.random.shuffle(segments)\n\n    new_solution = []\n    current_pos = 0\n    for i in range(num_segments):\n        if i > 0:\n            remaining_length = segment_starts[i] - segment_starts[i-1] - segment_lengths[i-1]\n            if remaining_length > 0:\n                new_solution.extend(base_solution[current_pos:current_pos+remaining_length])\n                current_pos += remaining_length\n        new_solution.extend(segments[i])\n        current_pos = segment_starts[i] + segment_lengths[i]\n\n    if current_pos < n:\n        new_solution.extend(base_solution[current_pos:])\n\n    if len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    if np.random.random() < 0.4 and n > 8:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        avg_dist1 = np.mean(distance_matrix_1)\n        avg_dist2 = np.mean(distance_matrix_2)\n\n        if (dist1 > 1.3 * avg_dist1 and dist2 > 1.3 * avg_dist2) or np.random.random() < 0.2:\n            inserted_node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [inserted_node], new_solution[i+1:j], new_solution[j+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9207415450203174,
            0.1361514925956726
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment swap\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment swap with objective-biased segment insertion\n    if n > 4:\n        # Objective-biased segment insertion\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert segment elsewhere if it improves one objective significantly\n        if (segment_cost1 > 1.1 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.1 * distance_matrix_2[segment[-1], segment[0]]):\n            insert_pos = np.random.randint(0, n - segment_length)\n            if insert_pos != start:\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos+segment_length:]])\n\n        # Adaptive segment swap with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Swap segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8680851477950147,
            0.200888991355896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment swap with objective-biased segment insertion\n    if n > 4:\n        # Objective-biased segment insertion\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert segment elsewhere if it improves one objective significantly\n        if (segment_cost1 > 1.1 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.1 * distance_matrix_2[segment[-1], segment[0]]):\n            insert_pos = np.random.randint(0, n - segment_length)\n            if insert_pos != start:\n                new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos+segment_length:]])\n\n        # Adaptive segment swap with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Swap segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This algorithm selects a non-dominated solution from the archive based on a crowding distance metric to promote diversity, then applies a novel \"objective-biased edge insertion\" local search that selectively inserts nodes based on their contribution to minimizing one or both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with highest crowding distance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Calculate crowding distance\n    def crowding_distance(solutions):\n        distances = [0] * len(solutions)\n        for m in range(2):\n            sorted_solutions = sorted(solutions, key=lambda x: x[1][m])\n            distances[0] = distances[-1] = float('inf')\n            for i in range(1, len(solutions)-1):\n                distances[i] += (sorted_solutions[i+1][1][m] - sorted_solutions[i-1][1][m]) / (sorted_solutions[-1][1][m] - sorted_solutions[0][1][m])\n        return distances\n\n    distances = crowding_distance(non_dominated)\n    selected_idx = np.argmax(distances)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-biased edge insertion\n    if n > 3:\n        # Select a random node to remove\n        remove_pos = np.random.randint(1, n-1)\n        removed_node = new_solution[remove_pos]\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(1, n):\n            if pos == remove_pos:\n                continue\n\n            # Calculate insertion cost for both objectives\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert the node at best position\n        new_solution = np.delete(new_solution, remove_pos)\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    return new_solution\n\n",
        "score": [
            -0.7065568205592782,
            8.699155509471893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with highest crowding distance\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Calculate crowding distance\n    def crowding_distance(solutions):\n        distances = [0] * len(solutions)\n        for m in range(2):\n            sorted_solutions = sorted(solutions, key=lambda x: x[1][m])\n            distances[0] = distances[-1] = float('inf')\n            for i in range(1, len(solutions)-1):\n                distances[i] += (sorted_solutions[i+1][1][m] - sorted_solutions[i-1][1][m]) / (sorted_solutions[-1][1][m] - sorted_solutions[0][1][m])\n        return distances\n\n    distances = crowding_distance(non_dominated)\n    selected_idx = np.argmax(distances)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-biased edge insertion\n    if n > 3:\n        # Select a random node to remove\n        remove_pos = np.random.randint(1, n-1)\n        removed_node = new_solution[remove_pos]\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(1, n):\n            if pos == remove_pos:\n                continue\n\n            # Calculate insertion cost for both objectives\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert the node at best position\n        new_solution = np.delete(new_solution, remove_pos)\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel \"adaptive segment shuffling\" strategy that intelligently reorders nodes within segments while maintaining feasibility, balancing local and global improvements through dynamic segment selection and perturbation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    segment_size = min(max(3, n // 4), n - 1)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    if np.random.random() < 0.5:\n        segment = np.random.permutation(segment)\n    else:\n        segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n    new_solution[start:end] = segment\n\n    if np.random.random() < 0.4 and n > 5:\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        if dist1 > 1.2 * np.mean(distance_matrix_1) or dist2 > 1.2 * np.mean(distance_matrix_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9203045860692005,
            0.24843871593475342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    segment_size = min(max(3, n // 4), n - 1)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    if np.random.random() < 0.5:\n        segment = np.random.permutation(segment)\n    else:\n        segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n    new_solution[start:end] = segment\n\n    if np.random.random() < 0.4 and n > 5:\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        if dist1 > 1.2 * np.mean(distance_matrix_1) or dist2 > 1.2 * np.mean(distance_matrix_2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9325936800455114,
            0.07282602787017822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility, using different parameter settings for selection and segment length.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(10, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 6:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(3, min(8, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 12:\n            insert_length = np.random.randint(3, min(7, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8509176930499482,
            0.07998698949813843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(10, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 6:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(3, min(8, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 12:\n            insert_length = np.random.randint(3, min(7, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9834202800315652,
            0.0740630030632019
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"cross-segment exchange\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment inversion with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(4, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment exchange with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 1)\n            second_start = np.random.randint(n//2, n - 1)\n\n            first_node = new_solution[first_start]\n            second_node = new_solution[second_start]\n\n            # Exchange nodes if it improves diversity\n            if len(set(new_solution[:n//2])) < len(set(new_solution[n//2:])):\n                new_solution[first_start], new_solution[second_start] = second_node, first_node\n            else:\n                new_solution[first_start], new_solution[second_start] = first_node, second_node\n\n    return new_solution\n\n",
        "score": [
            -0.6672402803980919,
            0.9982395172119141
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment inversion with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(4, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment exchange with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 1)\n            second_start = np.random.randint(n//2, n - 1)\n\n            first_node = new_solution[first_start]\n            second_node = new_solution[second_start]\n\n            # Exchange nodes if it improves diversity\n            if len(set(new_solution[:n//2])) < len(set(new_solution[n//2:])):\n                new_solution[first_start], new_solution[second_start] = second_node, first_node\n            else:\n                new_solution[first_start], new_solution[second_start] = first_node, second_node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"objective-aware node relocation\" approach that dynamically adjusts the relocation strategy based on the relative improvement potential in each objective space, ensuring feasibility through careful position validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node relocation\n    if n > 3:\n        # Select a node to relocate\n        node_idx = np.random.randint(1, n-1)\n        node = new_solution[node_idx]\n\n        # Calculate potential insertion positions\n        possible_positions = [i for i in range(n) if i != node_idx and i != node_idx-1 and i != node_idx+1]\n\n        if possible_positions:\n            # Evaluate each position based on both objectives\n            position_scores = []\n            for pos in possible_positions:\n                prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n                # Calculate cost change in both objectives\n                old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                new_cost1 = distance_matrix_1[prev_node, next_node]\n                delta1 = new_cost1 - old_cost1\n\n                old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                new_cost2 = distance_matrix_2[prev_node, next_node]\n                delta2 = new_cost2 - old_cost2\n\n                # Combine scores with objective weights based on current solution's performance\n                weight1 = archive[selected_idx][1][0] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n                weight2 = archive[selected_idx][1][1] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n                combined_score = weight1 * delta1 + weight2 * delta2\n                position_scores.append((combined_score, pos))\n\n            # Select the position with the best improvement\n            best_score, best_pos = min(position_scores, key=lambda x: x[0])\n\n            # Perform the relocation\n            if best_score < 0:  # Only relocate if it improves at least one objective\n                new_solution = np.delete(new_solution, node_idx)\n                if node_idx < best_pos:\n                    best_pos -= 1\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9011925409316048,
            0.2700551152229309
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node relocation\n    if n > 3:\n        # Select a node to relocate\n        node_idx = np.random.randint(1, n-1)\n        node = new_solution[node_idx]\n\n        # Calculate potential insertion positions\n        possible_positions = [i for i in range(n) if i != node_idx and i != node_idx-1 and i != node_idx+1]\n\n        if possible_positions:\n            # Evaluate each position based on both objectives\n            position_scores = []\n            for pos in possible_positions:\n                prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n                # Calculate cost change in both objectives\n                old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                new_cost1 = distance_matrix_1[prev_node, next_node]\n                delta1 = new_cost1 - old_cost1\n\n                old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                new_cost2 = distance_matrix_2[prev_node, next_node]\n                delta2 = new_cost2 - old_cost2\n\n                # Combine scores with objective weights based on current solution's performance\n                weight1 = archive[selected_idx][1][0] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n                weight2 = archive[selected_idx][1][1] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n                combined_score = weight1 * delta1 + weight2 * delta2\n                position_scores.append((combined_score, pos))\n\n            # Select the position with the best improvement\n            best_score, best_pos = min(position_scores, key=lambda x: x[0])\n\n            # Perform the relocation\n            if best_score < 0:  # Only relocate if it improves at least one objective\n                new_solution = np.delete(new_solution, node_idx)\n                if node_idx < best_pos:\n                    best_pos -= 1\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective improvement potential and structural diversity, then applies a novel \"adaptive node chain reconfiguration\" strategy that combines segment inversion with cross-segment merging, guided by both objective improvements and structural balance to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    # Selection: Choose solution with potential for improvement in both objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(2, len(archive_sorted)-1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive node chain reconfiguration\n    segment_size = max(2, min(5, n // 4))\n    start1 = np.random.randint(0, n - segment_size)\n    start2 = np.random.randint(0, n - segment_size)\n\n    segment1 = new_solution[start1:start1+segment_size]\n    segment2 = new_solution[start2:start2+segment_size]\n\n    # Calculate segment costs\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[i+1]] for i in range(segment_size-1))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[i+1]] for i in range(segment_size-1))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[i+1]] for i in range(segment_size-1))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[i+1]] for i in range(segment_size-1))\n\n    # Invert segment if it improves at least one objective\n    if cost1_seg1 > distance_matrix_1[segment1[-1], segment1[0]] or cost2_seg1 > distance_matrix_2[segment1[-1], segment1[0]]:\n        new_solution[start1:start1+segment_size] = segment1[::-1]\n\n    # Merge segments if they show complementary strengths\n    if abs(cost1_seg1 - cost1_seg2) < 0.1 * (cost1_seg1 + cost1_seg2) and abs(cost2_seg1 - cost2_seg2) < 0.1 * (cost2_seg1 + cost2_seg2):\n        new_solution[start1:start1+segment_size] = segment2\n        new_solution[start2:start2+segment_size] = segment1\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6630922048553807,
            0.7247540354728699
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    # Selection: Choose solution with potential for improvement in both objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(2, len(archive_sorted)-1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive node chain reconfiguration\n    segment_size = max(2, min(5, n // 4))\n    start1 = np.random.randint(0, n - segment_size)\n    start2 = np.random.randint(0, n - segment_size)\n\n    segment1 = new_solution[start1:start1+segment_size]\n    segment2 = new_solution[start2:start2+segment_size]\n\n    # Calculate segment costs\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[i+1]] for i in range(segment_size-1))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[i+1]] for i in range(segment_size-1))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[i+1]] for i in range(segment_size-1))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[i+1]] for i in range(segment_size-1))\n\n    # Invert segment if it improves at least one objective\n    if cost1_seg1 > distance_matrix_1[segment1[-1], segment1[0]] or cost2_seg1 > distance_matrix_2[segment1[-1], segment1[0]]:\n        new_solution[start1:start1+segment_size] = segment1[::-1]\n\n    # Merge segments if they show complementary strengths\n    if abs(cost1_seg1 - cost1_seg2) < 0.1 * (cost1_seg1 + cost1_seg2) and abs(cost2_seg1 - cost2_seg2) < 0.1 * (cost2_seg1 + cost2_seg2):\n        new_solution[start1:start1+segment_size] = segment2\n        new_solution[start2:start2+segment_size] = segment1\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8876702053738545,
            0.07296019792556763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility, but uses an adaptive segment reversal strategy that prioritizes improvements in both objectives simultaneously and incorporates a diversity-aware segment merging operation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with balanced objective improvement\n    if n > 4:\n        # Select multiple segments for simultaneous reversal\n        num_segments = np.random.randint(1, min(4, n//4))\n        segment_lengths = np.random.randint(2, min(6, n//num_segments), size=num_segments)\n        starts = np.random.choice(np.arange(0, n - max(segment_lengths)), size=num_segments, replace=False)\n\n        for i in range(num_segments):\n            start = starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n\n            # Calculate segment costs\n            segment_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n            # Reverse if it improves both objectives\n            if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n                segment_cost2 > distance_matrix_2[segment[-1], segment[0]]):\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment merge with balanced diversity\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Calculate segment diversity\n            first_diversity = len(set(first_segment))\n            second_diversity = len(set(second_segment))\n\n            # Merge if it improves diversity and maintains balanced objectives\n            if first_diversity < second_diversity:\n                new_solution[first_start:first_start+first_length] = second_segment\n            elif first_diversity > second_diversity:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.873910720870106,
            0.2713618278503418
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with balanced objective improvement\n    if n > 4:\n        # Select multiple segments for simultaneous reversal\n        num_segments = np.random.randint(1, min(4, n//4))\n        segment_lengths = np.random.randint(2, min(6, n//num_segments), size=num_segments)\n        starts = np.random.choice(np.arange(0, n - max(segment_lengths)), size=num_segments, replace=False)\n\n        for i in range(num_segments):\n            start = starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n\n            # Calculate segment costs\n            segment_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n            # Reverse if it improves both objectives\n            if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n                segment_cost2 > distance_matrix_2[segment[-1], segment[0]]):\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment merge with balanced diversity\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Calculate segment diversity\n            first_diversity = len(set(first_segment))\n            second_diversity = len(set(second_segment))\n\n            # Merge if it improves diversity and maintains balanced objectives\n            if first_diversity < second_diversity:\n                new_solution[first_start:first_start+first_length] = second_segment\n            elif first_diversity > second_diversity:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel \"adaptive node insertion\" strategy that intelligently reinserts nodes while considering both objective improvements and maintaining feasibility, ensuring high-quality neighbors are generated.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive node insertion strategy\n    node_to_move = random.randint(0, n-1)\n    best_pos = node_to_move\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == node_to_move:\n            continue\n\n        # Try inserting the node at position pos\n        temp_solution = new_solution.copy()\n        node = temp_solution[node_to_move]\n        temp_solution = np.concatenate([temp_solution[:node_to_move], temp_solution[node_to_move+1:]])\n        temp_solution = np.insert(temp_solution, pos, node)\n\n        # Calculate improvement in both objectives\n        original_cost1 = distance_matrix_1[new_solution[node_to_move-1], new_solution[node_to_move]] + distance_matrix_1[new_solution[node_to_move], new_solution[(node_to_move+1)%n]]\n        new_cost1 = distance_matrix_1[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_1[temp_solution[pos], temp_solution[(pos+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[node_to_move-1], new_solution[node_to_move]] + distance_matrix_2[new_solution[node_to_move], new_solution[(node_to_move+1)%n]]\n        new_cost2 = distance_matrix_2[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_2[temp_solution[pos], temp_solution[(pos+1)%n]]\n\n        improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != node_to_move:\n        node = new_solution[node_to_move]\n        new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5619162241464627,
            1.7763749361038208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Adaptive node insertion strategy\n    node_to_move = random.randint(0, n-1)\n    best_pos = node_to_move\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == node_to_move:\n            continue\n\n        # Try inserting the node at position pos\n        temp_solution = new_solution.copy()\n        node = temp_solution[node_to_move]\n        temp_solution = np.concatenate([temp_solution[:node_to_move], temp_solution[node_to_move+1:]])\n        temp_solution = np.insert(temp_solution, pos, node)\n\n        # Calculate improvement in both objectives\n        original_cost1 = distance_matrix_1[new_solution[node_to_move-1], new_solution[node_to_move]] + distance_matrix_1[new_solution[node_to_move], new_solution[(node_to_move+1)%n]]\n        new_cost1 = distance_matrix_1[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_1[temp_solution[pos], temp_solution[(pos+1)%n]]\n\n        original_cost2 = distance_matrix_2[new_solution[node_to_move-1], new_solution[node_to_move]] + distance_matrix_2[new_solution[node_to_move], new_solution[(node_to_move+1)%n]]\n        new_cost2 = distance_matrix_2[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_2[temp_solution[pos], temp_solution[(pos+1)%n]]\n\n        improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != node_to_move:\n        node = new_solution[node_to_move]\n        new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective balance and solution quality, then applies a hybrid local search combining a novel \"node chain reordering\" with an \"objective-aware segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high quality\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware chain reordering with segment insertion\n    if n > 4:\n        # Node chain reordering\n        chain_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n\n        # Calculate chain costs in both objectives\n        chain_cost1 = sum(distance_matrix_1[chain[i], chain[i+1]] for i in range(len(chain)-1))\n        chain_cost2 = sum(distance_matrix_2[chain[i], chain[i+1]] for i in range(len(chain)-1))\n\n        # Reorder chain if it improves at least one objective\n        if chain_cost1 > chain_cost2:\n            new_solution[start:start+chain_length] = chain[::-1]\n\n        # Objective-aware segment insertion\n        if n > 8:\n            segment_length = np.random.randint(2, min(4, n//2))\n            segment_start = np.random.randint(0, n - segment_length)\n            segment = new_solution[segment_start:segment_start+segment_length]\n\n            # Calculate segment costs\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Insert segment at a new position if it improves diversity\n            insert_pos = np.random.randint(0, n - segment_length)\n            if insert_pos != segment_start:\n                new_segment = new_solution.copy()\n                new_segment = np.delete(new_segment, slice(segment_start, segment_start+segment_length))\n                new_segment = np.insert(new_segment, insert_pos, segment)\n                new_solution = new_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8289706616486975,
            0.22978776693344116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high quality\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware chain reordering with segment insertion\n    if n > 4:\n        # Node chain reordering\n        chain_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n\n        # Calculate chain costs in both objectives\n        chain_cost1 = sum(distance_matrix_1[chain[i], chain[i+1]] for i in range(len(chain)-1))\n        chain_cost2 = sum(distance_matrix_2[chain[i], chain[i+1]] for i in range(len(chain)-1))\n\n        # Reorder chain if it improves at least one objective\n        if chain_cost1 > chain_cost2:\n            new_solution[start:start+chain_length] = chain[::-1]\n\n        # Objective-aware segment insertion\n        if n > 8:\n            segment_length = np.random.randint(2, min(4, n//2))\n            segment_start = np.random.randint(0, n - segment_length)\n            segment = new_solution[segment_start:segment_start+segment_length]\n\n            # Calculate segment costs\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Insert segment at a new position if it improves diversity\n            insert_pos = np.random.randint(0, n - segment_length)\n            if insert_pos != segment_start:\n                new_segment = new_solution.copy()\n                new_segment = np.delete(new_segment, slice(segment_start, segment_start+segment_length))\n                new_segment = np.insert(new_segment, insert_pos, segment)\n                new_solution = new_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel \"adaptive node relocation\" strategy with \"objective-aware path insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high quality\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation with objective-aware path insertion\n    if n > 3:\n        # Select a node to relocate\n        node_idx = np.random.randint(1, n-1)\n        node = new_solution[node_idx]\n\n        # Find the best insertion position considering both objectives\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(1, n):\n            if i == node_idx or i == node_idx + 1:\n                continue\n\n            # Calculate insertion cost for both objectives\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i] if i < n else new_solution[0]\n\n            cost1 = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] -\n                     distance_matrix_1[prev_node, next_node])\n            cost2 = (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] -\n                     distance_matrix_2[prev_node, next_node])\n\n            # Combine costs with objective weights based on current solution's imbalance\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            weight1 = current_cost2 / (current_cost1 + current_cost2)\n            weight2 = current_cost1 / (current_cost1 + current_cost2)\n\n            combined_cost = weight1 * cost1 + weight2 * cost2\n\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = i\n\n        if best_pos != -1:\n            # Perform the insertion\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9130908099848705,
            0.7631829977035522
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high quality\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation with objective-aware path insertion\n    if n > 3:\n        # Select a node to relocate\n        node_idx = np.random.randint(1, n-1)\n        node = new_solution[node_idx]\n\n        # Find the best insertion position considering both objectives\n        best_pos = -1\n        min_cost = float('inf')\n\n        for i in range(1, n):\n            if i == node_idx or i == node_idx + 1:\n                continue\n\n            # Calculate insertion cost for both objectives\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i] if i < n else new_solution[0]\n\n            cost1 = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] -\n                     distance_matrix_1[prev_node, next_node])\n            cost2 = (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] -\n                     distance_matrix_2[prev_node, next_node])\n\n            # Combine costs with objective weights based on current solution's imbalance\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            weight1 = current_cost2 / (current_cost1 + current_cost2)\n            weight2 = current_cost1 / (current_cost1 + current_cost2)\n\n            combined_cost = weight1 * cost1 + weight2 * cost2\n\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = i\n\n        if best_pos != -1:\n            # Perform the insertion\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"cross-segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective value\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment inversion with objective-aware selection\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment insertion for diversity\n        if n > 6:\n            insert_pos = np.random.randint(0, n)\n            remove_pos = np.random.randint(0, n)\n            if insert_pos != remove_pos:\n                node = new_solution[remove_pos]\n                new_solution = np.insert(new_solution, insert_pos, node)\n                new_solution = np.delete(new_solution, remove_pos + (1 if remove_pos > insert_pos else 0))\n\n    return new_solution\n\n",
        "score": [
            -0.8207260091210672,
            0.22515428066253662
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better combined objective value\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment inversion with objective-aware selection\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment insertion for diversity\n        if n > 6:\n            insert_pos = np.random.randint(0, n)\n            remove_pos = np.random.randint(0, n)\n            if insert_pos != remove_pos:\n                node = new_solution[remove_pos]\n                new_solution = np.insert(new_solution, insert_pos, node)\n                new_solution = np.delete(new_solution, remove_pos + (1 if remove_pos > insert_pos else 0))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility, using different parameter settings for segment selection and improvement criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity with different criteria\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    candidate_indices = min(7, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with different segment selection criteria\n    if n > 8:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        if (segment_cost1 + segment_cost2) > (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        if n > 12:\n            first_start = np.random.randint(0, n//3 - 2)\n            first_length = np.random.randint(2, min(5, n//3 - first_start))\n            second_start = np.random.randint(n//3, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            if (len(set(first_segment)) + len(set(second_segment))) > (first_length + first_length):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8895342318903139,
            0.08639311790466309
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity with different criteria\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    candidate_indices = min(7, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with different segment selection criteria\n    if n > 8:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        if (segment_cost1 + segment_cost2) > (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        if n > 12:\n            first_start = np.random.randint(0, n//3 - 2)\n            first_length = np.random.randint(2, min(5, n//3 - first_start))\n            second_start = np.random.randint(n//3, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            if (len(set(first_segment)) + len(set(second_segment))) > (first_length + first_length):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment rotation\" with \"objective-aware segment inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        if segment_cost1 > segment_cost2:\n            rotation = np.random.randint(1, segment_length)\n            segment = np.roll(segment, rotation)\n        else:\n            segment = segment[::-1]\n\n        new_solution[start:start+segment_length] = segment\n\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            if insert_cost1 < insert_cost2:\n                new_solution = np.concatenate([new_solution[insert_length:], insert_segment])\n            else:\n                new_solution = np.concatenate([insert_segment, new_solution[insert_length:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9368185406599763,
            0.22826159000396729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        if segment_cost1 > segment_cost2:\n            rotation = np.random.randint(1, segment_length)\n            segment = np.roll(segment, rotation)\n        else:\n            segment = segment[::-1]\n\n        new_solution[start:start+segment_length] = segment\n\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            if insert_cost1 < insert_cost2:\n                new_solution = np.concatenate([new_solution[insert_length:], insert_segment])\n            else:\n                new_solution = np.concatenate([insert_segment, new_solution[insert_length:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"objective-balanced node clustering\" with \"cross-space edge optimization\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    weights = np.random.uniform(0.4, 0.6)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]) / (x[1][0] * x[1][1] + 1e-8))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-balanced node clustering with cross-space edge optimization\n    if n > 6:\n        # Objective-balanced node clustering\n        cluster_size = np.random.randint(3, min(7, n))\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Calculate cluster costs in both objectives\n        cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n        cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n\n        # Reorder nodes in cluster based on balanced objective weights\n        if cluster_cost1 > cluster_cost2:\n            cluster = sorted(cluster, key=lambda x: instance[x, 0] * 0.6 + instance[x, 1] * 0.4)\n        else:\n            cluster = sorted(cluster, key=lambda x: instance[x, 2] * 0.6 + instance[x, 3] * 0.4)\n\n        new_solution[cluster_start:cluster_start+cluster_size] = cluster\n\n        # Cross-space edge optimization\n        if n > 10:\n            # Find edges that are suboptimal in either space\n            for i in range(n-1):\n                node1 = new_solution[i]\n                node2 = new_solution[i+1]\n                dist1 = distance_matrix_1[node1, node2]\n                dist2 = distance_matrix_2[node1, node2]\n\n                if (dist1 > 1.3 * np.mean(distance_matrix_1) or dist2 > 1.3 * np.mean(distance_matrix_2)):\n                    # Find a better edge in the opposite space\n                    best_node = None\n                    best_gain = 0\n\n                    for j in range(n):\n                        if j != i and j != i+1:\n                            new_dist1 = distance_matrix_1[node1, new_solution[j]] + distance_matrix_1[new_solution[j], node2]\n                            new_dist2 = distance_matrix_2[node1, new_solution[j]] + distance_matrix_2[new_solution[j], node2]\n\n                            gain = (dist1 - new_dist1) * 0.5 + (dist2 - new_dist2) * 0.5\n\n                            if gain > best_gain:\n                                best_gain = gain\n                                best_node = j\n\n                    if best_node is not None:\n                        # Perform the edge optimization\n                        temp = new_solution[i+1]\n                        new_solution[i+1] = new_solution[best_node]\n                        new_solution[best_node] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.816272524608315,
            1.1770422458648682
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    weights = np.random.uniform(0.4, 0.6)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]) / (x[1][0] * x[1][1] + 1e-8))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-balanced node clustering with cross-space edge optimization\n    if n > 6:\n        # Objective-balanced node clustering\n        cluster_size = np.random.randint(3, min(7, n))\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Calculate cluster costs in both objectives\n        cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n        cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n\n        # Reorder nodes in cluster based on balanced objective weights\n        if cluster_cost1 > cluster_cost2:\n            cluster = sorted(cluster, key=lambda x: instance[x, 0] * 0.6 + instance[x, 1] * 0.4)\n        else:\n            cluster = sorted(cluster, key=lambda x: instance[x, 2] * 0.6 + instance[x, 3] * 0.4)\n\n        new_solution[cluster_start:cluster_start+cluster_size] = cluster\n\n        # Cross-space edge optimization\n        if n > 10:\n            # Find edges that are suboptimal in either space\n            for i in range(n-1):\n                node1 = new_solution[i]\n                node2 = new_solution[i+1]\n                dist1 = distance_matrix_1[node1, node2]\n                dist2 = distance_matrix_2[node1, node2]\n\n                if (dist1 > 1.3 * np.mean(distance_matrix_1) or dist2 > 1.3 * np.mean(distance_matrix_2)):\n                    # Find a better edge in the opposite space\n                    best_node = None\n                    best_gain = 0\n\n                    for j in range(n):\n                        if j != i and j != i+1:\n                            new_dist1 = distance_matrix_1[node1, new_solution[j]] + distance_matrix_1[new_solution[j], node2]\n                            new_dist2 = distance_matrix_2[node1, new_solution[j]] + distance_matrix_2[new_solution[j], node2]\n\n                            gain = (dist1 - new_dist1) * 0.5 + (dist2 - new_dist2) * 0.5\n\n                            if gain > best_gain:\n                                best_gain = gain\n                                best_node = j\n\n                    if best_node is not None:\n                        # Perform the edge optimization\n                        temp = new_solution[i+1]\n                        new_solution[i+1] = new_solution[best_node]\n                        new_solution[best_node] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a hybrid local search combining \"adaptive segment reversal\" with \"objective-biased node swapping\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and solution quality\n    weighted_scores = []\n    for sol, (cost1, cost2) in archive:\n        quality = (cost1 + cost2) / (len(sol) ** 0.5)\n        weighted_scores.append(0.7 * quality + 0.3 * (cost1 + cost2))\n\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-biased node swapping\n    if n > 4:\n        # Adaptive segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Objective-biased node swapping\n        if n > 6:\n            swap_pos1 = np.random.randint(0, n)\n            swap_pos2 = np.random.randint(0, n)\n            if swap_pos1 != swap_pos2:\n                # Calculate cost difference\n                old_cost1 = distance_matrix_1[new_solution[swap_pos1-1], new_solution[swap_pos1]] + \\\n                            distance_matrix_1[new_solution[swap_pos1], new_solution[(swap_pos1+1)%n]] + \\\n                            distance_matrix_1[new_solution[swap_pos2-1], new_solution[swap_pos2]] + \\\n                            distance_matrix_1[new_solution[swap_pos2], new_solution[(swap_pos2+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[swap_pos1-1], new_solution[swap_pos2]] + \\\n                             distance_matrix_1[new_solution[swap_pos2], new_solution[(swap_pos1+1)%n]] + \\\n                             distance_matrix_1[new_solution[swap_pos2-1], new_solution[swap_pos1]] + \\\n                             distance_matrix_1[new_solution[swap_pos1], new_solution[(swap_pos2+1)%n]]\n\n                old_cost2 = distance_matrix_2[new_solution[swap_pos1-1], new_solution[swap_pos1]] + \\\n                            distance_matrix_2[new_solution[swap_pos1], new_solution[(swap_pos1+1)%n]] + \\\n                            distance_matrix_2[new_solution[swap_pos2-1], new_solution[swap_pos2]] + \\\n                            distance_matrix_2[new_solution[swap_pos2], new_solution[(swap_pos2+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[swap_pos1-1], new_solution[swap_pos2]] + \\\n                             distance_matrix_2[new_solution[swap_pos2], new_solution[(swap_pos1+1)%n]] + \\\n                             distance_matrix_2[new_solution[swap_pos2-1], new_solution[swap_pos1]] + \\\n                             distance_matrix_2[new_solution[swap_pos1], new_solution[(swap_pos2+1)%n]]\n\n                # Accept swap if it improves either objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.8668764107593717,
            0.3169742822647095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and solution quality\n    weighted_scores = []\n    for sol, (cost1, cost2) in archive:\n        quality = (cost1 + cost2) / (len(sol) ** 0.5)\n        weighted_scores.append(0.7 * quality + 0.3 * (cost1 + cost2))\n\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-biased node swapping\n    if n > 4:\n        # Adaptive segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Objective-biased node swapping\n        if n > 6:\n            swap_pos1 = np.random.randint(0, n)\n            swap_pos2 = np.random.randint(0, n)\n            if swap_pos1 != swap_pos2:\n                # Calculate cost difference\n                old_cost1 = distance_matrix_1[new_solution[swap_pos1-1], new_solution[swap_pos1]] + \\\n                            distance_matrix_1[new_solution[swap_pos1], new_solution[(swap_pos1+1)%n]] + \\\n                            distance_matrix_1[new_solution[swap_pos2-1], new_solution[swap_pos2]] + \\\n                            distance_matrix_1[new_solution[swap_pos2], new_solution[(swap_pos2+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[swap_pos1-1], new_solution[swap_pos2]] + \\\n                             distance_matrix_1[new_solution[swap_pos2], new_solution[(swap_pos1+1)%n]] + \\\n                             distance_matrix_1[new_solution[swap_pos2-1], new_solution[swap_pos1]] + \\\n                             distance_matrix_1[new_solution[swap_pos1], new_solution[(swap_pos2+1)%n]]\n\n                old_cost2 = distance_matrix_2[new_solution[swap_pos1-1], new_solution[swap_pos1]] + \\\n                            distance_matrix_2[new_solution[swap_pos1], new_solution[(swap_pos1+1)%n]] + \\\n                            distance_matrix_2[new_solution[swap_pos2-1], new_solution[swap_pos2]] + \\\n                            distance_matrix_2[new_solution[swap_pos2], new_solution[(swap_pos2+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[swap_pos1-1], new_solution[swap_pos2]] + \\\n                             distance_matrix_2[new_solution[swap_pos2], new_solution[(swap_pos1+1)%n]] + \\\n                             distance_matrix_2[new_solution[swap_pos2-1], new_solution[swap_pos1]] + \\\n                             distance_matrix_2[new_solution[swap_pos1], new_solution[(swap_pos2+1)%n]]\n\n                # Accept swap if it improves either objective\n                if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                    new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"objective-aware segment insertion\" with a \"multi-segment crossover\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment insertion\n    if n > 5:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert segment at a different position if it improves at least one objective\n        new_pos = np.random.randint(0, n - segment_length)\n        if new_pos != start:\n            new_segment_cost1 = sum(distance_matrix_1[new_solution[new_pos+i], new_solution[new_pos+i+1]] for i in range(segment_length-1))\n            new_segment_cost2 = sum(distance_matrix_2[new_solution[new_pos+i], new_solution[new_pos+i+1]] for i in range(segment_length-1))\n\n            if segment_cost1 < new_segment_cost1 or segment_cost2 < new_segment_cost2:\n                # Remove old segment\n                new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n                # Insert at new position\n                new_solution = np.insert(new_solution, new_pos, segment)\n\n    # Multi-segment crossover for larger instances\n    if n > 10:\n        num_segments = np.random.randint(2, min(4, n//4))\n        segment_indices = sorted(np.random.choice(range(1, n), num_segments, replace=False))\n        segments = np.split(new_solution, segment_indices)\n\n        # Shuffle segments if it improves diversity\n        if len(set(segments[0])) > len(set(segments[-1])):\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n    return new_solution\n\n",
        "score": [
            -0.748864061431632,
            0.2698919177055359
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment insertion\n    if n > 5:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert segment at a different position if it improves at least one objective\n        new_pos = np.random.randint(0, n - segment_length)\n        if new_pos != start:\n            new_segment_cost1 = sum(distance_matrix_1[new_solution[new_pos+i], new_solution[new_pos+i+1]] for i in range(segment_length-1))\n            new_segment_cost2 = sum(distance_matrix_2[new_solution[new_pos+i], new_solution[new_pos+i+1]] for i in range(segment_length-1))\n\n            if segment_cost1 < new_segment_cost1 or segment_cost2 < new_segment_cost2:\n                # Remove old segment\n                new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n                # Insert at new position\n                new_solution = np.insert(new_solution, new_pos, segment)\n\n    # Multi-segment crossover for larger instances\n    if n > 10:\n        num_segments = np.random.randint(2, min(4, n//4))\n        segment_indices = sorted(np.random.choice(range(1, n), num_segments, replace=False))\n        segments = np.split(new_solution, segment_indices)\n\n        # Shuffle segments if it improves diversity\n        if len(set(segments[0])) > len(set(segments[-1])):\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility, using a different approach than the provided one.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Dynamic segment rotation with objective-aware insertion\n    if n > 6:\n        # Select a segment to rotate\n        segment_length = np.random.randint(2, min(6, n-1))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate the segment left or right\n        rotation_direction = np.random.choice([-1, 1])\n        rotated_segment = np.roll(segment, rotation_direction)\n\n        # Calculate costs before and after rotation\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start-1, start+segment_length))\n        new_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(segment_length-1))\n\n        if new_cost1 < original_cost1:\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Objective-aware insertion\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            node_to_insert = new_solution[insert_pos]\n            new_solution = np.delete(new_solution, insert_pos)\n            new_solution = np.insert(new_solution, np.random.randint(0, n-1), node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.8293278981874994,
            0.24486875534057617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Dynamic segment rotation with objective-aware insertion\n    if n > 6:\n        # Select a segment to rotate\n        segment_length = np.random.randint(2, min(6, n-1))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate the segment left or right\n        rotation_direction = np.random.choice([-1, 1])\n        rotated_segment = np.roll(segment, rotation_direction)\n\n        # Calculate costs before and after rotation\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start-1, start+segment_length))\n        new_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(segment_length-1))\n\n        if new_cost1 < original_cost1:\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Objective-aware insertion\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            node_to_insert = new_solution[insert_pos]\n            new_solution = np.delete(new_solution, insert_pos)\n            new_solution = np.insert(new_solution, np.random.randint(0, n-1), node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"node inversion\" with a \"cross-segment inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node inversion + cross-segment inversion\n    if n > 4:\n        # Node inversion: Select a segment of 2-4 nodes and invert their order\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment inversion: Select two non-overlapping segments and invert each\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = first_segment[::-1]\n            new_solution[second_start:second_start+second_length] = second_segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.835462191831736,
            0.22529447078704834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node inversion + cross-segment inversion\n    if n > 4:\n        # Node inversion: Select a segment of 2-4 nodes and invert their order\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment inversion: Select two non-overlapping segments and invert each\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = first_segment[::-1]\n            new_solution[second_start:second_start+second_length] = second_segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"objective-aware node clustering\" with a \"multi-objective segment reinsertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware node clustering with multi-objective segment reinsertion\n    if n > 4:\n        # Objective-aware node clustering\n        cluster_size = np.random.randint(2, min(5, n//2))\n        clusters = []\n        for i in range(0, n, cluster_size):\n            cluster = new_solution[i:i+cluster_size]\n            if len(cluster) > 1:\n                clusters.append(cluster)\n\n        # Reorder clusters based on objective dominance\n        if len(clusters) > 1:\n            cluster_costs = []\n            for cluster in clusters:\n                cost1 = sum(distance_matrix_1[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n                cost2 = sum(distance_matrix_2[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n                cluster_costs.append((cost1, cost2))\n\n            # Sort clusters based on which objective is worse\n            if sum(c[0] for c in cluster_costs) > sum(c[1] for c in cluster_costs):\n                clusters.sort(key=lambda x: x[0] + x[1])\n            else:\n                clusters.sort(key=lambda x: x[0] + x[1], reverse=True)\n\n            # Rebuild solution with reordered clusters\n            new_solution = np.concatenate(clusters)\n\n        # Multi-objective segment reinsertion\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//3))\n            start_pos = np.random.randint(0, n - segment_length)\n            segment = new_solution[start_pos:start_pos+segment_length]\n\n            # Calculate segment costs\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Find insertion position that improves both objectives\n            best_pos = start_pos\n            best_improvement = 0\n            for pos in range(n - segment_length):\n                if pos != start_pos:\n                    # Calculate potential new costs\n                    prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                    next_node = new_solution[pos] if pos < n else new_solution[0]\n                    new_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n                    new_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n                    # Calculate improvement\n                    improvement = (cost1 - new_cost1) + (cost2 - new_cost2)\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = pos\n\n            # Perform the insertion if it improves at least one objective\n            if best_improvement > 0:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.849705714124741,
            0.16035538911819458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware node clustering with multi-objective segment reinsertion\n    if n > 4:\n        # Objective-aware node clustering\n        cluster_size = np.random.randint(2, min(5, n//2))\n        clusters = []\n        for i in range(0, n, cluster_size):\n            cluster = new_solution[i:i+cluster_size]\n            if len(cluster) > 1:\n                clusters.append(cluster)\n\n        # Reorder clusters based on objective dominance\n        if len(clusters) > 1:\n            cluster_costs = []\n            for cluster in clusters:\n                cost1 = sum(distance_matrix_1[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n                cost2 = sum(distance_matrix_2[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n                cluster_costs.append((cost1, cost2))\n\n            # Sort clusters based on which objective is worse\n            if sum(c[0] for c in cluster_costs) > sum(c[1] for c in cluster_costs):\n                clusters.sort(key=lambda x: x[0] + x[1])\n            else:\n                clusters.sort(key=lambda x: x[0] + x[1], reverse=True)\n\n            # Rebuild solution with reordered clusters\n            new_solution = np.concatenate(clusters)\n\n        # Multi-objective segment reinsertion\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//3))\n            start_pos = np.random.randint(0, n - segment_length)\n            segment = new_solution[start_pos:start_pos+segment_length]\n\n            # Calculate segment costs\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Find insertion position that improves both objectives\n            best_pos = start_pos\n            best_improvement = 0\n            for pos in range(n - segment_length):\n                if pos != start_pos:\n                    # Calculate potential new costs\n                    prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                    next_node = new_solution[pos] if pos < n else new_solution[0]\n                    new_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n                    new_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n                    # Calculate improvement\n                    improvement = (cost1 - new_cost1) + (cost2 - new_cost2)\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_pos = pos\n\n            # Perform the insertion if it improves at least one objective\n            if best_improvement > 0:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"adaptive segment inversion with objective-aware merging\" to generate a neighbor solution by intelligently inverting and merging segments while considering the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion with objective-aware merging\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Objective-aware segment merging\n        if n > 8 and np.random.random() < 0.5:\n            merge_length = np.random.randint(2, min(5, n//2))\n            merge_start1 = np.random.randint(0, n//2 - merge_length)\n            merge_start2 = np.random.randint(n//2, n - merge_length)\n\n            segment1 = new_solution[merge_start1:merge_start1+merge_length]\n            segment2 = new_solution[merge_start2:merge_start2+merge_length]\n\n            # Calculate segment costs for both objectives\n            cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[i+1]] for i in range(len(segment1)-1))\n            cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[i+1]] for i in range(len(segment1)-1))\n            cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[i+1]] for i in range(len(segment2)-1))\n            cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[i+1]] for i in range(len(segment2)-1))\n\n            # Merge if it improves the trade-off between objectives\n            if (cost1_seg1 + cost2_seg1) > (cost1_seg2 + cost2_seg2):\n                new_solution[merge_start1:merge_start1+merge_length] = segment2\n            else:\n                new_solution[merge_start2:merge_start2+merge_length] = segment1\n\n    return new_solution\n\n",
        "score": [
            -0.8908379378859602,
            0.19114786386489868
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion with objective-aware merging\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Objective-aware segment merging\n        if n > 8 and np.random.random() < 0.5:\n            merge_length = np.random.randint(2, min(5, n//2))\n            merge_start1 = np.random.randint(0, n//2 - merge_length)\n            merge_start2 = np.random.randint(n//2, n - merge_length)\n\n            segment1 = new_solution[merge_start1:merge_start1+merge_length]\n            segment2 = new_solution[merge_start2:merge_start2+merge_length]\n\n            # Calculate segment costs for both objectives\n            cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[i+1]] for i in range(len(segment1)-1))\n            cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[i+1]] for i in range(len(segment1)-1))\n            cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[i+1]] for i in range(len(segment2)-1))\n            cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[i+1]] for i in range(len(segment2)-1))\n\n            # Merge if it improves the trade-off between objectives\n            if (cost1_seg1 + cost2_seg1) > (cost1_seg2 + cost2_seg2):\n                new_solution[merge_start1:merge_start1+merge_length] = segment2\n            else:\n                new_solution[merge_start2:merge_start2+merge_length] = segment1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment reversal\" with \"objective-biased segment swapping\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-biased segment swapping\n    if n > 4:\n        # Adaptive segment reversal\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse segment if it improves the weaker objective\n        if segment_cost1 > segment_cost2:\n            new_solution[start:start+segment_length] = segment[::-1]\n        else:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Objective-biased segment swapping\n        if n > 8:\n            swap_length = np.random.randint(2, min(5, n//2))\n            swap_pos1 = np.random.randint(0, n - swap_length)\n            swap_pos2 = np.random.randint(0, n - swap_length)\n\n            # Ensure different segments\n            while abs(swap_pos1 - swap_pos2) < swap_length:\n                swap_pos2 = np.random.randint(0, n - swap_length)\n\n            # Calculate swap costs in both objectives\n            seg1_cost1 = sum(distance_matrix_1[new_solution[swap_pos1+i], new_solution[swap_pos1+i+1]] for i in range(swap_length-1))\n            seg1_cost2 = sum(distance_matrix_2[new_solution[swap_pos1+i], new_solution[swap_pos1+i+1]] for i in range(swap_length-1))\n            seg2_cost1 = sum(distance_matrix_1[new_solution[swap_pos2+i], new_solution[swap_pos2+i+1]] for i in range(swap_length-1))\n            seg2_cost2 = sum(distance_matrix_2[new_solution[swap_pos2+i], new_solution[swap_pos2+i+1]] for i in range(swap_length-1))\n\n            # Swap segments if it improves the weaker objective\n            if seg1_cost1 + seg2_cost1 > seg1_cost2 + seg2_cost2:\n                temp = new_solution[swap_pos1:swap_pos1+swap_length].copy()\n                new_solution[swap_pos1:swap_pos1+swap_length] = new_solution[swap_pos2:swap_pos2+swap_length]\n                new_solution[swap_pos2:swap_pos2+swap_length] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8884774069653779,
            0.22331476211547852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-biased segment swapping\n    if n > 4:\n        # Adaptive segment reversal\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse segment if it improves the weaker objective\n        if segment_cost1 > segment_cost2:\n            new_solution[start:start+segment_length] = segment[::-1]\n        else:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Objective-biased segment swapping\n        if n > 8:\n            swap_length = np.random.randint(2, min(5, n//2))\n            swap_pos1 = np.random.randint(0, n - swap_length)\n            swap_pos2 = np.random.randint(0, n - swap_length)\n\n            # Ensure different segments\n            while abs(swap_pos1 - swap_pos2) < swap_length:\n                swap_pos2 = np.random.randint(0, n - swap_length)\n\n            # Calculate swap costs in both objectives\n            seg1_cost1 = sum(distance_matrix_1[new_solution[swap_pos1+i], new_solution[swap_pos1+i+1]] for i in range(swap_length-1))\n            seg1_cost2 = sum(distance_matrix_2[new_solution[swap_pos1+i], new_solution[swap_pos1+i+1]] for i in range(swap_length-1))\n            seg2_cost1 = sum(distance_matrix_1[new_solution[swap_pos2+i], new_solution[swap_pos2+i+1]] for i in range(swap_length-1))\n            seg2_cost2 = sum(distance_matrix_2[new_solution[swap_pos2+i], new_solution[swap_pos2+i+1]] for i in range(swap_length-1))\n\n            # Swap segments if it improves the weaker objective\n            if seg1_cost1 + seg2_cost1 > seg1_cost2 + seg2_cost2:\n                temp = new_solution[swap_pos1:swap_pos1+swap_length].copy()\n                new_solution[swap_pos1:swap_pos1+swap_length] = new_solution[swap_pos2:swap_pos2+swap_length]\n                new_solution[swap_pos2:swap_pos2+swap_length] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment rotation\" with a \"multi-objective-aware swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment rotation + multi-objective-aware swap\n    if n > 5:\n        # Node segment rotation: Rotate a segment of 3-5 nodes by a random amount\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Multi-objective-aware swap: Swap nodes that are far apart in either objective space\n        if n > 8:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.2 * np.mean(distance_matrix_1) or dist2 > 1.2 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8554756353531752,
            0.30124521255493164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment rotation + multi-objective-aware swap\n    if n > 5:\n        # Node segment rotation: Rotate a segment of 3-5 nodes by a random amount\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Multi-objective-aware swap: Swap nodes that are far apart in either objective space\n        if n > 8:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.2 * np.mean(distance_matrix_1) or dist2 > 1.2 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"objective-aware node clustering and reinsertion\" local search that groups nodes by their distance characteristics in each objective space and reinserts them to balance the objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node clustering and reinsertion\n    if n > 4:\n        # Cluster nodes based on distance characteristics\n        cluster1 = []\n        cluster2 = []\n        for i in range(n):\n            node = new_solution[i]\n            neighbors = [new_solution[(i+j)%n] for j in [-1, 1]]\n            dist1 = sum(distance_matrix_1[node, neighbor] for neighbor in neighbors)\n            dist2 = sum(distance_matrix_2[node, neighbor] for neighbor in neighbors)\n            if dist1 > dist2:\n                cluster1.append(node)\n            else:\n                cluster2.append(node)\n\n        # Reinsert clusters to balance objectives\n        if len(cluster1) > 1 and len(cluster2) > 1:\n            # Find insertion points\n            insert_pos1 = np.random.randint(0, n)\n            insert_pos2 = np.random.randint(0, n)\n\n            # Create new solution by interleaving clusters\n            new_solution = np.concatenate([\n                new_solution[:insert_pos1],\n                np.array(cluster1),\n                new_solution[insert_pos1:insert_pos2],\n                np.array(cluster2),\n                new_solution[insert_pos2:]\n            ])\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n",
        "score": [
            -0.8796665842956033,
            0.11441975831985474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware node clustering and reinsertion\n    if n > 4:\n        # Cluster nodes based on distance characteristics\n        cluster1 = []\n        cluster2 = []\n        for i in range(n):\n            node = new_solution[i]\n            neighbors = [new_solution[(i+j)%n] for j in [-1, 1]]\n            dist1 = sum(distance_matrix_1[node, neighbor] for neighbor in neighbors)\n            dist2 = sum(distance_matrix_2[node, neighbor] for neighbor in neighbors)\n            if dist1 > dist2:\n                cluster1.append(node)\n            else:\n                cluster2.append(node)\n\n        # Reinsert clusters to balance objectives\n        if len(cluster1) > 1 and len(cluster2) > 1:\n            # Find insertion points\n            insert_pos1 = np.random.randint(0, n)\n            insert_pos2 = np.random.randint(0, n)\n\n            # Create new solution by interleaving clusters\n            new_solution = np.concatenate([\n                new_solution[:insert_pos1],\n                np.array(cluster1),\n                new_solution[insert_pos1:insert_pos2],\n                np.array(cluster2),\n                new_solution[insert_pos2:]\n            ])\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment rotation\" with a \"cross-segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment rotation and insertion\n    if n > 4:\n        # Segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment if it improves at least one objective\n        rotated_segment = np.roll(segment, 1)\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost2 = sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n\n        if (rotated_cost1 < original_cost1) or (rotated_cost2 < original_cost2):\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion\n        if n > 8:\n            insertion_point = np.random.randint(0, n)\n            segment_start = np.random.randint(0, n - 2)\n            segment_length = np.random.randint(2, min(4, n - segment_start))\n            segment = new_solution[segment_start:segment_start+segment_length]\n\n            # Insert segment if it improves diversity\n            if len(set(new_solution)) < len(new_solution):\n                new_solution = np.concatenate([\n                    new_solution[:insertion_point],\n                    segment,\n                    new_solution[insertion_point:]\n                ])\n                new_solution = np.unique(new_solution, return_index=True)[1]\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7456180246704512,
            0.9396026134490967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment rotation and insertion\n    if n > 4:\n        # Segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment if it improves at least one objective\n        rotated_segment = np.roll(segment, 1)\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost2 = sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n\n        if (rotated_cost1 < original_cost1) or (rotated_cost2 < original_cost2):\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion\n        if n > 8:\n            insertion_point = np.random.randint(0, n)\n            segment_start = np.random.randint(0, n - 2)\n            segment_length = np.random.randint(2, min(4, n - segment_start))\n            segment = new_solution[segment_start:segment_start+segment_length]\n\n            # Insert segment if it improves diversity\n            if len(set(new_solution)) < len(new_solution):\n                new_solution = np.concatenate([\n                    new_solution[:insertion_point],\n                    segment,\n                    new_solution[insertion_point:]\n                ])\n                new_solution = np.unique(new_solution, return_index=True)[1]\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining an \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection and local search steps.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and better balance between objectives\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 3:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(1, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 6:\n            insert_length = np.random.randint(1, min(4, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = new_solution[:n]\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9391322829045109,
            0.12577295303344727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and better balance between objectives\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 3:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(1, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 6:\n            insert_length = np.random.randint(1, min(4, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = new_solution[:n]\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9899725544167229,
            0.129022479057312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and spatial clustering, then applies a hybrid local search combining \"adaptive node clustering\" with \"objective-biased edge reversal\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high spatial clustering in the dominant objective\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node clustering with objective-biased edge reversal\n    if n > 4:\n        # Adaptive node clustering\n        cluster_size = np.random.randint(2, min(5, n//2))\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Calculate cluster costs in both objectives\n        cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n        cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n\n        # Reverse the cluster if it improves the weaker objective\n        if cluster_cost1 > cluster_cost2:\n            new_solution[cluster_start:cluster_start+cluster_size] = cluster[::-1]\n\n        # Objective-biased edge reversal\n        if n > 8:\n            edge_reversal_count = np.random.randint(1, min(3, n//4))\n            for _ in range(edge_reversal_count):\n                i = np.random.randint(0, n-1)\n                j = (i + np.random.randint(2, 6)) % n\n\n                # Calculate edge costs in both objectives\n                edge_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1 if i+1 < n else 0]] + distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]]\n                edge_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1 if i+1 < n else 0]] + distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]]\n\n                # Reverse the edge if it improves the weaker objective\n                if edge_cost1 > edge_cost2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8454331409624716,
            0.3902382254600525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high spatial clustering in the dominant objective\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node clustering with objective-biased edge reversal\n    if n > 4:\n        # Adaptive node clustering\n        cluster_size = np.random.randint(2, min(5, n//2))\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Calculate cluster costs in both objectives\n        cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n        cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n\n        # Reverse the cluster if it improves the weaker objective\n        if cluster_cost1 > cluster_cost2:\n            new_solution[cluster_start:cluster_start+cluster_size] = cluster[::-1]\n\n        # Objective-biased edge reversal\n        if n > 8:\n            edge_reversal_count = np.random.randint(1, min(3, n//4))\n            for _ in range(edge_reversal_count):\n                i = np.random.randint(0, n-1)\n                j = (i + np.random.randint(2, 6)) % n\n\n                # Calculate edge costs in both objectives\n                edge_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1 if i+1 < n else 0]] + distance_matrix_1[new_solution[j], new_solution[j+1 if j+1 < n else 0]]\n                edge_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1 if i+1 < n else 0]] + distance_matrix_2[new_solution[j], new_solution[j+1 if j+1 < n else 0]]\n\n                # Reverse the edge if it improves the weaker objective\n                if edge_cost1 > edge_cost2:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a hybrid strategy combining edge-swapping and adaptive segment reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        diversity = np.sum(np.abs(sol - archive[0][0])) / n\n        score = 0.7 * (obj1 + obj2) + 0.3 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        segment = new_solution[a:b+1]\n        k = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7714480714264502,
            0.30861741304397583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        diversity = np.sum(np.abs(sol - archive[0][0])) / n\n        score = 0.7 * (obj1 + obj2) + 0.3 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        segment = new_solution[a:b+1]\n        k = random.randint(1, len(segment)-1)\n        new_solution[a:b+1] = np.concatenate([segment[k:], segment[:k]])\n\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 5:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9222124590255983,
            0.0730850100517273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 5:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding-distance metric to promote diversity, then applies a hybrid local search combining \"objective-weighted segment insertion\" with \"adaptive segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Use crowding distance to select diverse solutions\n    solutions = [sol[0] for sol in archive]\n    objectives = np.array([sol[1] for sol in archive])\n\n    # Calculate normalized objectives\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Compute crowding distances\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_indices = np.argsort(norm_obj[:, m])\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_indices[i]] += (norm_obj[sorted_indices[i+1], m] - norm_obj[sorted_indices[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-weighted segment insertion with adaptive rotation\n    if n > 4:\n        # Objective-weighted segment insertion\n        segment_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs with weights\n        weight1 = 0.7 if np.random.random() < 0.5 else 0.3\n        weight2 = 1 - weight1\n        segment_cost = (weight1 * sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) +\n                       weight2 * sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)))\n\n        # Insert elsewhere if it improves weighted cost\n        insert_pos = np.random.randint(0, n - segment_length)\n        if insert_pos != start:\n            new_segment_cost = (weight1 * distance_matrix_1[new_solution[insert_pos], segment[0]] +\n                               weight1 * distance_matrix_1[segment[-1], new_solution[(insert_pos + segment_length) % n]] +\n                               weight2 * distance_matrix_2[new_solution[insert_pos], segment[0]] +\n                               weight2 * distance_matrix_2[segment[-1], new_solution[(insert_pos + segment_length) % n]])\n\n            if new_segment_cost < segment_cost:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])[:n]\n\n        # Adaptive segment rotation\n        if n > 8:\n            rotate_pos = np.random.randint(0, n)\n            rotate_amount = np.random.randint(1, min(5, n//2))\n            new_solution[rotate_pos:] = np.roll(new_solution[rotate_pos:], rotate_amount)\n\n    return new_solution\n\n",
        "score": [
            -0.6489641353668955,
            0.3479846119880676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Use crowding distance to select diverse solutions\n    solutions = [sol[0] for sol in archive]\n    objectives = np.array([sol[1] for sol in archive])\n\n    # Calculate normalized objectives\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Compute crowding distances\n    crowding = np.zeros(len(archive))\n    for m in range(2):\n        sorted_indices = np.argsort(norm_obj[:, m])\n        crowding[sorted_indices[0]] = np.inf\n        crowding[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_indices[i]] += (norm_obj[sorted_indices[i+1], m] - norm_obj[sorted_indices[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-weighted segment insertion with adaptive rotation\n    if n > 4:\n        # Objective-weighted segment insertion\n        segment_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs with weights\n        weight1 = 0.7 if np.random.random() < 0.5 else 0.3\n        weight2 = 1 - weight1\n        segment_cost = (weight1 * sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) +\n                       weight2 * sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)))\n\n        # Insert elsewhere if it improves weighted cost\n        insert_pos = np.random.randint(0, n - segment_length)\n        if insert_pos != start:\n            new_segment_cost = (weight1 * distance_matrix_1[new_solution[insert_pos], segment[0]] +\n                               weight1 * distance_matrix_1[segment[-1], new_solution[(insert_pos + segment_length) % n]] +\n                               weight2 * distance_matrix_2[new_solution[insert_pos], segment[0]] +\n                               weight2 * distance_matrix_2[segment[-1], new_solution[(insert_pos + segment_length) % n]])\n\n            if new_segment_cost < segment_cost:\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])[:n]\n\n        # Adaptive segment rotation\n        if n > 8:\n            rotate_pos = np.random.randint(0, n)\n            rotate_amount = np.random.randint(1, min(5, n//2))\n            new_solution[rotate_pos:] = np.roll(new_solution[rotate_pos:], rotate_amount)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted random selection based on both objective values and solution diversity, then applies a novel \"multi-segment inversion\" local search to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted random selection based on objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion: Divide the tour into 3 segments and invert each segment\n    if n > 6:\n        segment_size = n // 3\n        for i in range(3):\n            start = i * segment_size\n            end = (i + 1) * segment_size if i < 2 else n\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7551769151944666,
            1.0363937616348267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted random selection based on objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    weights = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion: Divide the tour into 3 segments and invert each segment\n    if n > 6:\n        segment_size = n // 3\n        for i in range(3):\n            start = i * segment_size\n            end = (i + 1) * segment_size if i < 2 else n\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"adaptive multi-segment inversion\" with \"objective-biased segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive multi-segment inversion\n    if n > 6:\n        num_segments = np.random.randint(2, min(4, n//3))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n        starts = np.random.choice(range(n - sum(segment_lengths) + 1), size=num_segments, replace=False)\n\n        for i in range(num_segments):\n            start = starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n            new_solution[start:start+length] = segment[::-1]\n\n    # Objective-biased segment rotation\n    if n > 4:\n        rotation_length = np.random.randint(2, min(5, n))\n        rotation_start = np.random.randint(0, n - rotation_length)\n\n        # Calculate objective bias\n        obj1_ratio = archive[selected_idx][1][0] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-10)\n        if np.random.random() < obj1_ratio:\n            # Rotate segment left in objective 1 space\n            segment = new_solution[rotation_start:rotation_start+rotation_length]\n            rotated = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[rotation_start:rotation_start+rotation_length] = rotated\n        else:\n            # Rotate segment right in objective 2 space\n            segment = new_solution[rotation_start:rotation_start+rotation_length]\n            rotated = np.concatenate([[segment[-1]], segment[:-1]])\n            new_solution[rotation_start:rotation_start+rotation_length] = rotated\n\n    return new_solution\n\n",
        "score": [
            -0.8639780652847912,
            0.22589081525802612
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive multi-segment inversion\n    if n > 6:\n        num_segments = np.random.randint(2, min(4, n//3))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n        starts = np.random.choice(range(n - sum(segment_lengths) + 1), size=num_segments, replace=False)\n\n        for i in range(num_segments):\n            start = starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n            new_solution[start:start+length] = segment[::-1]\n\n    # Objective-biased segment rotation\n    if n > 4:\n        rotation_length = np.random.randint(2, min(5, n))\n        rotation_start = np.random.randint(0, n - rotation_length)\n\n        # Calculate objective bias\n        obj1_ratio = archive[selected_idx][1][0] / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-10)\n        if np.random.random() < obj1_ratio:\n            # Rotate segment left in objective 1 space\n            segment = new_solution[rotation_start:rotation_start+rotation_length]\n            rotated = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[rotation_start:rotation_start+rotation_length] = rotated\n        else:\n            # Rotate segment right in objective 2 space\n            segment = new_solution[rotation_start:rotation_start+rotation_length]\n            rotated = np.concatenate([[segment[-1]], segment[:-1]])\n            new_solution[rotation_start:rotation_start+rotation_length] = rotated\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a novel \"objective-aware segment insertion\" with \"cross-segment inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Objective-aware segment insertion\n    segment_length = np.random.randint(2, min(5, n))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate segment costs\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    # Insert segment at a new position if it improves at least one objective\n    new_pos = np.random.randint(0, n - segment_length)\n    if new_pos != start:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, np.arange(start, start+segment_length))])\n\n    # Cross-segment inversion\n    if n > 8:\n        first_start = np.random.randint(0, n//2 - 2)\n        first_length = np.random.randint(2, min(5, n//2 - first_start))\n        second_start = np.random.randint(n//2, n - first_length)\n\n        first_segment = new_solution[first_start:first_start+first_length]\n        second_segment = new_solution[second_start:second_start+first_length]\n\n        # Invert segments if it improves diversity\n        if len(set(first_segment)) > len(set(second_segment)):\n            new_solution[first_start:first_start+first_length] = first_segment[::-1]\n        else:\n            new_solution[second_start:second_start+first_length] = second_segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8501184183110336,
            0.08250665664672852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Objective-aware segment insertion\n    segment_length = np.random.randint(2, min(5, n))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate segment costs\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    # Insert segment at a new position if it improves at least one objective\n    new_pos = np.random.randint(0, n - segment_length)\n    if new_pos != start:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, np.arange(start, start+segment_length))])\n\n    # Cross-segment inversion\n    if n > 8:\n        first_start = np.random.randint(0, n//2 - 2)\n        first_length = np.random.randint(2, min(5, n//2 - first_start))\n        second_start = np.random.randint(n//2, n - first_length)\n\n        first_segment = new_solution[first_start:first_start+first_length]\n        second_segment = new_solution[second_start:second_start+first_length]\n\n        # Invert segments if it improves diversity\n        if len(set(first_segment)) > len(set(second_segment)):\n            new_solution[first_start:first_start+first_length] = first_segment[::-1]\n        else:\n            new_solution[second_start:second_start+first_length] = second_segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining an \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9216299636720113,
            0.07789134979248047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution structure, then applies a novel \"adaptive k-opt\" local search that dynamically selects the number of edges to optimize, combining edge swaps with a \"node insertion\" heuristic to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution structure\n    archive_with_structure = []\n    for sol, obj in archive:\n        # Calculate structural diversity (number of unique edge pairs)\n        edges = set(zip(sol, np.roll(sol, -1)))\n        structure_score = len(edges)\n        archive_with_structure.append((sol, obj, structure_score))\n\n    # Sort by combined objective and structure score\n    sorted_archive = sorted(archive_with_structure, key=lambda x: (x[1][0] + x[1][1], -x[2]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive_with_structure[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt local search\n    if n > 4:\n        # Dynamically determine k based on solution quality and size\n        k = min(4, max(2, int(np.log2(n))))\n        if k >= n:\n            k = n - 1\n\n        # Select k random positions to optimize\n        positions = sorted(np.random.choice(n, k, replace=False))\n\n        # For each selected position, consider inserting a node from elsewhere\n        for i in range(k):\n            pos = positions[i]\n            # Find a node to insert that would improve at least one objective\n            best_improvement = 0\n            best_node = -1\n            best_pos = -1\n\n            for node in range(n):\n                if node in new_solution[:pos]:\n                    continue\n                # Try inserting node at position pos\n                temp_sol = np.insert(new_solution, pos, node)\n                temp_sol = np.delete(temp_sol, pos + 1 if pos + 1 < n else pos)\n\n                # Calculate new costs\n                new_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                new_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n                # Calculate improvement\n                old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n                old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n                improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_node = node\n                    best_pos = pos\n\n            if best_node != -1:\n                # Perform the insertion\n                new_solution = np.insert(new_solution, best_pos, best_node)\n                new_solution = np.delete(new_solution, best_pos + 1 if best_pos + 1 < n else best_pos)\n\n    return new_solution\n\n",
        "score": [
            -0.9640455710183222,
            4.449927508831024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution structure\n    archive_with_structure = []\n    for sol, obj in archive:\n        # Calculate structural diversity (number of unique edge pairs)\n        edges = set(zip(sol, np.roll(sol, -1)))\n        structure_score = len(edges)\n        archive_with_structure.append((sol, obj, structure_score))\n\n    # Sort by combined objective and structure score\n    sorted_archive = sorted(archive_with_structure, key=lambda x: (x[1][0] + x[1][1], -x[2]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive_with_structure[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt local search\n    if n > 4:\n        # Dynamically determine k based on solution quality and size\n        k = min(4, max(2, int(np.log2(n))))\n        if k >= n:\n            k = n - 1\n\n        # Select k random positions to optimize\n        positions = sorted(np.random.choice(n, k, replace=False))\n\n        # For each selected position, consider inserting a node from elsewhere\n        for i in range(k):\n            pos = positions[i]\n            # Find a node to insert that would improve at least one objective\n            best_improvement = 0\n            best_node = -1\n            best_pos = -1\n\n            for node in range(n):\n                if node in new_solution[:pos]:\n                    continue\n                # Try inserting node at position pos\n                temp_sol = np.insert(new_solution, pos, node)\n                temp_sol = np.delete(temp_sol, pos + 1 if pos + 1 < n else pos)\n\n                # Calculate new costs\n                new_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                new_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n                # Calculate improvement\n                old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n                old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n                improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_node = node\n                    best_pos = pos\n\n            if best_node != -1:\n                # Perform the insertion\n                new_solution = np.insert(new_solution, best_pos, best_node)\n                new_solution = np.delete(new_solution, best_pos + 1 if best_pos + 1 < n else best_pos)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9366182031389043,
            0.07236099243164062
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node cluster permutation\" with \"objective-balanced segment reversal\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node cluster permutation + objective-balanced segment reversal\n    if n > 4:\n        # Adaptive node cluster permutation\n        cluster_size = np.random.randint(2, min(5, n//2))\n        num_clusters = n // cluster_size\n\n        for i in range(num_clusters):\n            start = i * cluster_size\n            end = start + cluster_size\n            cluster = new_solution[start:end]\n\n            # Calculate cluster costs in both objectives\n            cluster_cost1 = sum(distance_matrix_1[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n            cluster_cost2 = sum(distance_matrix_2[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n\n            # Permute cluster based on objective balance\n            if abs(cluster_cost1 - cluster_cost2) < 0.1 * (cluster_cost1 + cluster_cost2):\n                np.random.shuffle(cluster)\n            else:\n                if cluster_cost1 > cluster_cost2:\n                    cluster = sorted(cluster, key=lambda x: instance[x, 0] + instance[x, 1])\n                else:\n                    cluster = sorted(cluster, key=lambda x: instance[x, 2] + instance[x, 3])\n\n            new_solution[start:end] = cluster\n\n        # Objective-balanced segment reversal\n        if n > 8:\n            segment_length = np.random.randint(3, min(6, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Reverse segment if it improves objective balance\n            if abs(segment_cost1 - segment_cost2) > 0.2 * (segment_cost1 + segment_cost2):\n                new_solution[start:start+segment_length] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8293307869819769,
            0.28600239753723145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node cluster permutation + objective-balanced segment reversal\n    if n > 4:\n        # Adaptive node cluster permutation\n        cluster_size = np.random.randint(2, min(5, n//2))\n        num_clusters = n // cluster_size\n\n        for i in range(num_clusters):\n            start = i * cluster_size\n            end = start + cluster_size\n            cluster = new_solution[start:end]\n\n            # Calculate cluster costs in both objectives\n            cluster_cost1 = sum(distance_matrix_1[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n            cluster_cost2 = sum(distance_matrix_2[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n\n            # Permute cluster based on objective balance\n            if abs(cluster_cost1 - cluster_cost2) < 0.1 * (cluster_cost1 + cluster_cost2):\n                np.random.shuffle(cluster)\n            else:\n                if cluster_cost1 > cluster_cost2:\n                    cluster = sorted(cluster, key=lambda x: instance[x, 0] + instance[x, 1])\n                else:\n                    cluster = sorted(cluster, key=lambda x: instance[x, 2] + instance[x, 3])\n\n            new_solution[start:end] = cluster\n\n        # Objective-balanced segment reversal\n        if n > 8:\n            segment_length = np.random.randint(3, min(6, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Reverse segment if it improves objective balance\n            if abs(segment_cost1 - segment_cost2) > 0.2 * (segment_cost1 + segment_cost2):\n                new_solution[start:start+segment_length] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9025608005179374,
            0.11758369207382202
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"objective-aware node insertion\" with a \"multi-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware node insertion + multi-segment rotation\n    if n > 4:\n        # Objective-aware node insertion\n        insert_pos = np.random.randint(1, n-1)\n        node_to_insert = new_solution[np.random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert))\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Multi-segment rotation\n        if n > 8:\n            num_segments = np.random.randint(2, 4)\n            segment_length = n // num_segments\n            segments = [new_solution[i*segment_length:(i+1)*segment_length] for i in range(num_segments)]\n\n            # Rotate segments based on objective improvement\n            for i in range(num_segments):\n                segment_cost1 = sum(distance_matrix_1[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n                segment_cost2 = sum(distance_matrix_2[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n\n                if segment_cost1 > segment_cost2:\n                    segments[i] = np.roll(segments[i], shift=1)\n\n            new_solution = np.concatenate(segments)\n\n    return new_solution\n\n",
        "score": [
            -0.7211640590377956,
            0.16896623373031616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware node insertion + multi-segment rotation\n    if n > 4:\n        # Objective-aware node insertion\n        insert_pos = np.random.randint(1, n-1)\n        node_to_insert = new_solution[np.random.randint(1, n-1)]\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert))\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Multi-segment rotation\n        if n > 8:\n            num_segments = np.random.randint(2, 4)\n            segment_length = n // num_segments\n            segments = [new_solution[i*segment_length:(i+1)*segment_length] for i in range(num_segments)]\n\n            # Rotate segments based on objective improvement\n            for i in range(num_segments):\n                segment_cost1 = sum(distance_matrix_1[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n                segment_cost2 = sum(distance_matrix_2[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1))\n\n                if segment_cost1 > segment_cost2:\n                    segments[i] = np.roll(segments[i], shift=1)\n\n            new_solution = np.concatenate(segments)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node block rotation\" with a \"direction-aware segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node block rotation + direction-aware segment insertion\n    if n > 4:\n        # Node block rotation: Select a block of 2-4 consecutive nodes and rotate them\n        block_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - block_length)\n        block = new_solution[start:start+block_length]\n\n        # Calculate block costs in both objectives\n        block_cost1 = sum(distance_matrix_1[block[i], block[i+1]] for i in range(len(block)-1))\n        block_cost2 = sum(distance_matrix_2[block[i], block[i+1]] for i in range(len(block)-1))\n\n        # Rotate the block if it improves at least one objective\n        if block_cost1 > distance_matrix_1[block[-1], block[0]]:\n            rotated_block = np.roll(block, 1)\n            new_solution[start:start+block_length] = rotated_block\n        elif block_cost2 > distance_matrix_2[block[-1], block[0]]:\n            rotated_block = np.roll(block, -1)\n            new_solution[start:start+block_length] = rotated_block\n\n        # Direction-aware segment insertion: Insert a segment from another part of the tour\n        if n > 8:\n            insertion_point = np.random.randint(0, n)\n            extract_start = np.random.randint(0, n - 3)\n            extract_length = np.random.randint(2, min(5, n - extract_start))\n\n            segment = new_solution[extract_start:extract_start+extract_length]\n\n            # Calculate direction vectors for the segment\n            x1_dir = instance[segment[-1], 0] - instance[segment[0], 0]\n            y1_dir = instance[segment[-1], 1] - instance[segment[0], 1]\n            x2_dir = instance[segment[-1], 2] - instance[segment[0], 2]\n            y2_dir = instance[segment[-1], 3] - instance[segment[0], 3]\n\n            # Find insertion point that maintains direction consistency\n            for i in range(n):\n                if i != insertion_point and i not in range(extract_start, extract_start+extract_length):\n                    prev_node = new_solution[(i-1) % n]\n                    next_node = new_solution[i % n]\n\n                    prev_x1_dir = instance[prev_node, 0] - instance[new_solution[(i-2) % n], 0]\n                    prev_y1_dir = instance[prev_node, 1] - instance[new_solution[(i-2) % n], 1]\n                    prev_x2_dir = instance[prev_node, 2] - instance[new_solution[(i-2) % n], 2]\n                    prev_y2_dir = instance[prev_node, 3] - instance[new_solution[(i-2) % n], 3]\n\n                    next_x1_dir = instance[next_node, 0] - instance[prev_node, 0]\n                    next_y1_dir = instance[next_node, 1] - instance[prev_node, 1]\n                    next_x2_dir = instance[next_node, 2] - instance[prev_node, 2]\n                    next_y2_dir = instance[next_node, 3] - instance[prev_node, 3]\n\n                    # Check if segment direction aligns with local direction\n                    if (x1_dir * prev_x1_dir + y1_dir * prev_y1_dir > 0 and\n                        x2_dir * prev_x2_dir + y2_dir * prev_y2_dir > 0 and\n                        x1_dir * next_x1_dir + y1_dir * next_y1_dir > 0 and\n                        x2_dir * next_x2_dir + y2_dir * next_y2_dir > 0):\n                        insertion_point = i\n                        break\n\n            # Insert the segment at the chosen point\n            new_solution = np.insert(new_solution, insertion_point, segment)\n            if insertion_point < extract_start:\n                new_solution = np.delete(new_solution, np.s_[extract_start+extract_length:extract_start+2*extract_length])\n            else:\n                new_solution = np.delete(new_solution, np.s_[extract_start:extract_start+extract_length])\n\n    return new_solution\n\n",
        "score": [
            -0.8428043793840196,
            0.28106629848480225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node block rotation + direction-aware segment insertion\n    if n > 4:\n        # Node block rotation: Select a block of 2-4 consecutive nodes and rotate them\n        block_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - block_length)\n        block = new_solution[start:start+block_length]\n\n        # Calculate block costs in both objectives\n        block_cost1 = sum(distance_matrix_1[block[i], block[i+1]] for i in range(len(block)-1))\n        block_cost2 = sum(distance_matrix_2[block[i], block[i+1]] for i in range(len(block)-1))\n\n        # Rotate the block if it improves at least one objective\n        if block_cost1 > distance_matrix_1[block[-1], block[0]]:\n            rotated_block = np.roll(block, 1)\n            new_solution[start:start+block_length] = rotated_block\n        elif block_cost2 > distance_matrix_2[block[-1], block[0]]:\n            rotated_block = np.roll(block, -1)\n            new_solution[start:start+block_length] = rotated_block\n\n        # Direction-aware segment insertion: Insert a segment from another part of the tour\n        if n > 8:\n            insertion_point = np.random.randint(0, n)\n            extract_start = np.random.randint(0, n - 3)\n            extract_length = np.random.randint(2, min(5, n - extract_start))\n\n            segment = new_solution[extract_start:extract_start+extract_length]\n\n            # Calculate direction vectors for the segment\n            x1_dir = instance[segment[-1], 0] - instance[segment[0], 0]\n            y1_dir = instance[segment[-1], 1] - instance[segment[0], 1]\n            x2_dir = instance[segment[-1], 2] - instance[segment[0], 2]\n            y2_dir = instance[segment[-1], 3] - instance[segment[0], 3]\n\n            # Find insertion point that maintains direction consistency\n            for i in range(n):\n                if i != insertion_point and i not in range(extract_start, extract_start+extract_length):\n                    prev_node = new_solution[(i-1) % n]\n                    next_node = new_solution[i % n]\n\n                    prev_x1_dir = instance[prev_node, 0] - instance[new_solution[(i-2) % n], 0]\n                    prev_y1_dir = instance[prev_node, 1] - instance[new_solution[(i-2) % n], 1]\n                    prev_x2_dir = instance[prev_node, 2] - instance[new_solution[(i-2) % n], 2]\n                    prev_y2_dir = instance[prev_node, 3] - instance[new_solution[(i-2) % n], 3]\n\n                    next_x1_dir = instance[next_node, 0] - instance[prev_node, 0]\n                    next_y1_dir = instance[next_node, 1] - instance[prev_node, 1]\n                    next_x2_dir = instance[next_node, 2] - instance[prev_node, 2]\n                    next_y2_dir = instance[next_node, 3] - instance[prev_node, 3]\n\n                    # Check if segment direction aligns with local direction\n                    if (x1_dir * prev_x1_dir + y1_dir * prev_y1_dir > 0 and\n                        x2_dir * prev_x2_dir + y2_dir * prev_y2_dir > 0 and\n                        x1_dir * next_x1_dir + y1_dir * next_y1_dir > 0 and\n                        x2_dir * next_x2_dir + y2_dir * next_y2_dir > 0):\n                        insertion_point = i\n                        break\n\n            # Insert the segment at the chosen point\n            new_solution = np.insert(new_solution, insertion_point, segment)\n            if insertion_point < extract_start:\n                new_solution = np.delete(new_solution, np.s_[extract_start+extract_length:extract_start+2*extract_length])\n            else:\n                new_solution = np.delete(new_solution, np.s_[extract_start:extract_start+extract_length])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This algorithm combines multi-objective solution selection with a novel \"adaptive path decomposition and reassembly\" strategy that dynamically partitions the tour into segments based on objective dominance and reassembles them using a hybrid of spatial and objective-based criteria to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path decomposition and reassembly\n    if n > 6:\n        # Determine decomposition points based on objective dominance\n        decomposition_points = []\n        for i in range(1, n):\n            if (distance_matrix_1[new_solution[i-1], new_solution[i]] > distance_matrix_2[new_solution[i-1], new_solution[i]] and\n                np.random.random() < 0.7) or (np.random.random() < 0.3):\n                decomposition_points.append(i)\n\n        if not decomposition_points:\n            decomposition_points = [n//2]\n\n        # Split into segments and reassemble\n        segments = []\n        prev_point = 0\n        for point in decomposition_points:\n            segments.append(new_solution[prev_point:point])\n            prev_point = point\n        segments.append(new_solution[prev_point:])\n\n        # Reassemble segments with hybrid criteria\n        new_solution = []\n        while segments:\n            if len(segments) == 1:\n                new_solution.extend(segments.pop())\n            else:\n                # Select segment based on objective dominance\n                segment_costs = []\n                for seg in segments:\n                    cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n                    cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n                    segment_costs.append((cost1, cost2))\n\n                # Choose segment to add based on objective balance\n                if np.random.random() < 0.6:\n                    # Add segment with higher cost in weaker objective\n                    weaker_obj = 0 if np.mean([c[0] for c in segment_costs]) < np.mean([c[1] for c in segment_costs]) else 1\n                    selected_seg_idx = np.argmax([c[weaker_obj] for c in segment_costs])\n                else:\n                    # Add segment with better spatial cohesion\n                    spatial_cohesion = []\n                    for seg in segments:\n                        centroid1 = np.mean(instance[seg, :2], axis=0)\n                        centroid2 = np.mean(instance[seg, 2:], axis=0)\n                        cohesion = np.mean([np.linalg.norm(instance[node, :2] - centroid1) for node in seg]) + \\\n                                  np.mean([np.linalg.norm(instance[node, 2:] - centroid2) for node in seg])\n                        spatial_cohesion.append(cohesion)\n                    selected_seg_idx = np.argmin(spatial_cohesion)\n\n                new_solution.extend(segments.pop(selected_seg_idx))\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.9433659783498201,
            1.5564814805984497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path decomposition and reassembly\n    if n > 6:\n        # Determine decomposition points based on objective dominance\n        decomposition_points = []\n        for i in range(1, n):\n            if (distance_matrix_1[new_solution[i-1], new_solution[i]] > distance_matrix_2[new_solution[i-1], new_solution[i]] and\n                np.random.random() < 0.7) or (np.random.random() < 0.3):\n                decomposition_points.append(i)\n\n        if not decomposition_points:\n            decomposition_points = [n//2]\n\n        # Split into segments and reassemble\n        segments = []\n        prev_point = 0\n        for point in decomposition_points:\n            segments.append(new_solution[prev_point:point])\n            prev_point = point\n        segments.append(new_solution[prev_point:])\n\n        # Reassemble segments with hybrid criteria\n        new_solution = []\n        while segments:\n            if len(segments) == 1:\n                new_solution.extend(segments.pop())\n            else:\n                # Select segment based on objective dominance\n                segment_costs = []\n                for seg in segments:\n                    cost1 = sum(distance_matrix_1[seg[i], seg[i+1]] for i in range(len(seg)-1))\n                    cost2 = sum(distance_matrix_2[seg[i], seg[i+1]] for i in range(len(seg)-1))\n                    segment_costs.append((cost1, cost2))\n\n                # Choose segment to add based on objective balance\n                if np.random.random() < 0.6:\n                    # Add segment with higher cost in weaker objective\n                    weaker_obj = 0 if np.mean([c[0] for c in segment_costs]) < np.mean([c[1] for c in segment_costs]) else 1\n                    selected_seg_idx = np.argmax([c[weaker_obj] for c in segment_costs])\n                else:\n                    # Add segment with better spatial cohesion\n                    spatial_cohesion = []\n                    for seg in segments:\n                        centroid1 = np.mean(instance[seg, :2], axis=0)\n                        centroid2 = np.mean(instance[seg, 2:], axis=0)\n                        cohesion = np.mean([np.linalg.norm(instance[node, :2] - centroid1) for node in seg]) + \\\n                                  np.mean([np.linalg.norm(instance[node, 2:] - centroid2) for node in seg])\n                        spatial_cohesion.append(cohesion)\n                    selected_seg_idx = np.argmin(spatial_cohesion)\n\n                new_solution.extend(segments.pop(selected_seg_idx))\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9790188012184374,
            0.07620197534561157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment insertion\" with \"objective-biased segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion with objective-biased segment rotation\n    if n > 4:\n        # Objective-biased segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = np.roll(segment, 1)\n\n        # Adaptive segment insertion with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Insert segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution = np.concatenate([new_solution[:first_start], second_segment, new_solution[first_start+first_length:]])\n            else:\n                new_solution = np.concatenate([new_solution[:second_start], first_segment, new_solution[second_start+first_length:]])\n\n    return new_solution\n\n",
        "score": [
            -0.910614620291468,
            0.07897144556045532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion with objective-biased segment rotation\n    if n > 4:\n        # Objective-biased segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = np.roll(segment, 1)\n\n        # Adaptive segment insertion with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Insert segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution = np.concatenate([new_solution[:first_start], second_segment, new_solution[first_start+first_length:]])\n            else:\n                new_solution = np.concatenate([new_solution[:second_start], first_segment, new_solution[second_start+first_length:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a hybrid local search combining a novel \"node segment reversal with adaptive insertion\" and a \"multi-objective aware swap\" to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.5:\n        c = random.randint(0, n-1)\n        node_to_insert = new_solution[c]\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    if n > 5 and random.random() < 0.7:\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        if (dist1 > 1.3 * np.mean(distance_matrix_1)) or (dist2 > 1.3 * np.mean(distance_matrix_2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9318871774538796,
            0.2384328842163086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.5:\n        c = random.randint(0, n-1)\n        node_to_insert = new_solution[c]\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    if n > 5 and random.random() < 0.7:\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        if (dist1 > 1.3 * np.mean(distance_matrix_1)) or (dist2 > 1.3 * np.mean(distance_matrix_2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"cross-segment exchange\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment inversion with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment exchange with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Exchange segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9041667407237057,
            0.07342267036437988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment inversion with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment exchange with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Exchange segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This new algorithm selects the best solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining a novel \"node segment rotation\" with an \"objective-aware insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted sum of objectives\n    weights = [0.6, 0.4]  # More weight on first objective\n    sorted_archive = sorted(archive, key=lambda x: (weights[0]*x[1][0] + weights[1]*x[1][1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment rotation\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment left or right\n        if np.random.rand() > 0.5:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        new_solution[start:start+segment_length] = segment\n\n    # Objective-aware insertion\n    if n > 6:\n        node_to_move = np.random.randint(0, n)\n        best_pos = node_to_move\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos != node_to_move and pos != (node_to_move - 1) % n:\n                # Calculate cost for both objectives\n                prev_node = new_solution[pos - 1]\n                next_node = new_solution[pos]\n                current_cost = (distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] +\n                               distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node])\n\n                if current_cost < best_cost:\n                    best_cost = current_cost\n                    best_pos = pos\n\n        if best_pos != node_to_move:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8060803998848437,
            0.23168450593948364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted sum of objectives\n    weights = [0.6, 0.4]  # More weight on first objective\n    sorted_archive = sorted(archive, key=lambda x: (weights[0]*x[1][0] + weights[1]*x[1][1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment rotation\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment left or right\n        if np.random.rand() > 0.5:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        new_solution[start:start+segment_length] = segment\n\n    # Objective-aware insertion\n    if n > 6:\n        node_to_move = np.random.randint(0, n)\n        best_pos = node_to_move\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos != node_to_move and pos != (node_to_move - 1) % n:\n                # Calculate cost for both objectives\n                prev_node = new_solution[pos - 1]\n                next_node = new_solution[pos]\n                current_cost = (distance_matrix_1[prev_node, node_to_move] + distance_matrix_1[node_to_move, next_node] +\n                               distance_matrix_2[prev_node, node_to_move] + distance_matrix_2[node_to_move, next_node])\n\n                if current_cost < best_cost:\n                    best_cost = current_cost\n                    best_pos = pos\n\n        if best_pos != node_to_move:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9412272315447058,
            0.07423776388168335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid objective score combining normalized objectives and solution crowding distance, then applies a novel \"adaptive segment relocation\" combined with an \"objective-balanced inversion\" to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Hybrid objective score with crowding distance\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[1:-1]] += (objectives[sorted_idx[2:], i] - objectives[sorted_idx[:-2], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n    scores = 0.6 * normalized[:, 0] + 0.4 * normalized[:, 1] + 0.2 * crowding\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if n > 4:\n        segment_size = min(n // 3, 5)\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:], segment])\n\n        # Objective-balanced inversion\n        if n > 8:\n            inv_start = np.random.randint(0, n - 3)\n            inv_end = min(inv_start + 3, n)\n            segment = new_solution[inv_start:inv_end]\n            if (np.sum(distance_matrix_1[segment[:-1], segment[1:]]) > np.sum(distance_matrix_1[segment[::-1][:-1], segment[::-1][1:]])) or \\\n               (np.sum(distance_matrix_2[segment[:-1], segment[1:]]) > np.sum(distance_matrix_2[segment[::-1][:-1], segment[::-1][1:]])):\n                new_solution[inv_start:inv_end] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8524224053407131,
            0.33988070487976074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Hybrid objective score with crowding distance\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding = np.zeros(len(archive))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[1:-1]] += (objectives[sorted_idx[2:], i] - objectives[sorted_idx[:-2], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n    scores = 0.6 * normalized[:, 0] + 0.4 * normalized[:, 1] + 0.2 * crowding\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if n > 4:\n        segment_size = min(n // 3, 5)\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:], segment])\n\n        # Objective-balanced inversion\n        if n > 8:\n            inv_start = np.random.randint(0, n - 3)\n            inv_end = min(inv_start + 3, n)\n            segment = new_solution[inv_start:inv_end]\n            if (np.sum(distance_matrix_1[segment[:-1], segment[1:]]) > np.sum(distance_matrix_1[segment[::-1][:-1], segment[::-1][1:]])) or \\\n               (np.sum(distance_matrix_2[segment[:-1], segment[1:]]) > np.sum(distance_matrix_2[segment[::-1][:-1], segment[::-1][1:]])):\n                new_solution[inv_start:inv_end] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and structural diversity, then applies a novel \"multi-objective segment reordering\" strategy that combines local segment reversals with adaptive node relocations to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective values and structural diversity\n    n = len(instance)\n    scores = []\n    for sol, obj in archive:\n        obj_score = (obj[0] + obj[1]) / 2\n        diversity_score = sum(1 for i in range(n-1) if sol[i] != sol[i+1])\n        scores.append(obj_score + 0.5 * diversity_score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment reordering\n    if n >= 5:\n        # Select a segment of 3-5 nodes\n        segment_len = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_len)\n\n        # Reverse the segment\n        segment = new_solution[start:start+segment_len]\n        new_solution[start:start+segment_len] = segment[::-1]\n\n        # Adaptive node relocation based on distance matrices\n        for i in range(start, start+segment_len):\n            for j in range(n):\n                if j < start or j >= start+segment_len:\n                    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n                    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n                    if dist1 < 0.8 * np.mean(distance_matrix_1) or dist2 < 0.8 * np.mean(distance_matrix_2):\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.808365868406502,
            0.7401880621910095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective values and structural diversity\n    n = len(instance)\n    scores = []\n    for sol, obj in archive:\n        obj_score = (obj[0] + obj[1]) / 2\n        diversity_score = sum(1 for i in range(n-1) if sol[i] != sol[i+1])\n        scores.append(obj_score + 0.5 * diversity_score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Multi-objective segment reordering\n    if n >= 5:\n        # Select a segment of 3-5 nodes\n        segment_len = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_len)\n\n        # Reverse the segment\n        segment = new_solution[start:start+segment_len]\n        new_solution[start:start+segment_len] = segment[::-1]\n\n        # Adaptive node relocation based on distance matrices\n        for i in range(start, start+segment_len):\n            for j in range(n):\n                if j < start or j >= start+segment_len:\n                    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n                    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n                    if dist1 < 0.8 * np.mean(distance_matrix_1) or dist2 < 0.8 * np.mean(distance_matrix_2):\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                        break\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node clustering\" with \"multi-objective segment relocation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node clustering with multi-objective segment relocation\n    if n > 4:\n        # Adaptive node clustering\n        cluster_size = np.random.randint(2, min(5, n//2))\n        clusters = []\n        for i in range(0, n, cluster_size):\n            cluster = new_solution[i:i+cluster_size]\n            clusters.append(cluster)\n\n        # Multi-objective segment relocation\n        for i in range(len(clusters)):\n            cluster = clusters[i]\n            cluster_cost1 = sum(distance_matrix_1[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n            cluster_cost2 = sum(distance_matrix_2[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n\n            # Relocate cluster based on objective balance\n            if cluster_cost1 > cluster_cost2:\n                new_pos = np.random.randint(0, n - len(cluster))\n                new_solution = np.concatenate([new_solution[:new_pos], cluster, new_solution[new_pos:]])\n                new_solution = new_solution[:n]\n            else:\n                new_pos = np.random.randint(len(cluster), n)\n                new_solution = np.concatenate([new_solution[:new_pos], cluster, new_solution[new_pos:]])\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8380905282211631,
            0.125379741191864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node clustering with multi-objective segment relocation\n    if n > 4:\n        # Adaptive node clustering\n        cluster_size = np.random.randint(2, min(5, n//2))\n        clusters = []\n        for i in range(0, n, cluster_size):\n            cluster = new_solution[i:i+cluster_size]\n            clusters.append(cluster)\n\n        # Multi-objective segment relocation\n        for i in range(len(clusters)):\n            cluster = clusters[i]\n            cluster_cost1 = sum(distance_matrix_1[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n            cluster_cost2 = sum(distance_matrix_2[cluster[j], cluster[j+1]] for j in range(len(cluster)-1))\n\n            # Relocate cluster based on objective balance\n            if cluster_cost1 > cluster_cost2:\n                new_pos = np.random.randint(0, n - len(cluster))\n                new_solution = np.concatenate([new_solution[:new_pos], cluster, new_solution[new_pos:]])\n                new_solution = new_solution[:n]\n            else:\n                new_pos = np.random.randint(len(cluster), n)\n                new_solution = np.concatenate([new_solution[:new_pos], cluster, new_solution[new_pos:]])\n                new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and low combined cost\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (len(set(x[0])) + 1e-6))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(8, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//3 - 2)\n            first_length = np.random.randint(2, min(8, n//3 - first_start))\n            second_start = np.random.randint(n//3, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9522244544488674,
            0.29135632514953613
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and low combined cost\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (len(set(x[0])) + 1e-6))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(8, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//3 - 2)\n            first_length = np.random.randint(2, min(8, n//3 - first_start))\n            second_start = np.random.randint(n//3, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment rotation\" with a \"cross-segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment rotation + cross-segment insertion\n    if n > 4:\n        # Node segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Insert first segment into second segment's position\n            new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9136972912623743,
            0.0765722393989563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment rotation + cross-segment insertion\n    if n > 4:\n        # Node segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Insert first segment into second segment's position\n            new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"cross-segment exchange\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment inversion and cross-segment exchange\n    if n > 4:\n        # Segment inversion with objective-aware selection\n        segment_length = np.random.randint(2, min(4, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Invert segment if it improves at least one objective\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        inverted_cost1 = sum(distance_matrix_1[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        inverted_cost2 = sum(distance_matrix_2[segment[i+1], segment[i]] for i in range(len(segment)-1))\n\n        if (inverted_cost1 < original_cost1) or (inverted_cost2 < original_cost2):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment exchange with diversity consideration\n        if n > 8:\n            split_point = n // 2\n            first_segment = new_solution[:split_point]\n            second_segment = new_solution[split_point:]\n\n            # Exchange segments if it improves diversity\n            if len(set(first_segment)) < len(set(second_segment)):\n                new_solution[:split_point], new_solution[split_point:] = second_segment, first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9407762492697851,
            0.24066132307052612
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment inversion and cross-segment exchange\n    if n > 4:\n        # Segment inversion with objective-aware selection\n        segment_length = np.random.randint(2, min(4, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Invert segment if it improves at least one objective\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        inverted_cost1 = sum(distance_matrix_1[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        inverted_cost2 = sum(distance_matrix_2[segment[i+1], segment[i]] for i in range(len(segment)-1))\n\n        if (inverted_cost1 < original_cost1) or (inverted_cost2 < original_cost2):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment exchange with diversity consideration\n        if n > 8:\n            split_point = n // 2\n            first_segment = new_solution[:split_point]\n            second_segment = new_solution[split_point:]\n\n            # Exchange segments if it improves diversity\n            if len(set(first_segment)) < len(set(second_segment)):\n                new_solution[:split_point], new_solution[split_point:] = second_segment, first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{This algorithm selects a solution from the archive based on objective diversity and applies a novel \"multi-objective path smoothing\" with \"adaptive node redistribution\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with diverse objectives\n    sorted_archive = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]), reverse=True)\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path smoothing\n    if n > 5:\n        # Identify nodes with high distance in either objective\n        high_dist_nodes = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if (distance_matrix_1[new_solution[i], new_solution[j]] > 1.5 * np.mean(distance_matrix_1) or\n                    distance_matrix_2[new_solution[i], new_solution[j]] > 1.5 * np.mean(distance_matrix_2)):\n                    high_dist_nodes.extend([i, j])\n\n        if high_dist_nodes:\n            # Smooth the path by redistributing high-distance nodes\n            high_dist_nodes = list(set(high_dist_nodes))\n            np.random.shuffle(high_dist_nodes)\n            for i in range(0, len(high_dist_nodes)-1, 2):\n                if i+1 < len(high_dist_nodes):\n                    new_solution[high_dist_nodes[i]], new_solution[high_dist_nodes[i+1]] = \\\n                    new_solution[high_dist_nodes[i+1]], new_solution[high_dist_nodes[i]]\n\n    # Adaptive node redistribution\n    if n > 7:\n        # Identify clusters of nodes in either objective space\n        cluster_size = max(2, n // 5)\n        for i in range(0, n, cluster_size):\n            cluster = new_solution[i:i+cluster_size]\n            if len(cluster) > 1:\n                # Calculate cluster centroids\n                centroid1 = instance[cluster, 0:2].mean(axis=0)\n                centroid2 = instance[cluster, 2:4].mean(axis=0)\n\n                # Reorder cluster nodes based on distance to centroids\n                dist_to_centroid1 = np.array([np.linalg.norm(instance[node, 0:2] - centroid1) for node in cluster])\n                dist_to_centroid2 = np.array([np.linalg.norm(instance[node, 2:4] - centroid2) for node in cluster])\n\n                combined_dist = dist_to_centroid1 + dist_to_centroid2\n                sorted_indices = np.argsort(combined_dist)\n                new_solution[i:i+cluster_size] = cluster[sorted_indices]\n\n    return new_solution\n\n",
        "score": [
            -0.9706317390151142,
            2.5205202102661133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with diverse objectives\n    sorted_archive = sorted(archive, key=lambda x: max(x[1][0], x[1][1]) - min(x[1][0], x[1][1]), reverse=True)\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path smoothing\n    if n > 5:\n        # Identify nodes with high distance in either objective\n        high_dist_nodes = []\n        for i in range(n):\n            for j in range(i+1, n):\n                if (distance_matrix_1[new_solution[i], new_solution[j]] > 1.5 * np.mean(distance_matrix_1) or\n                    distance_matrix_2[new_solution[i], new_solution[j]] > 1.5 * np.mean(distance_matrix_2)):\n                    high_dist_nodes.extend([i, j])\n\n        if high_dist_nodes:\n            # Smooth the path by redistributing high-distance nodes\n            high_dist_nodes = list(set(high_dist_nodes))\n            np.random.shuffle(high_dist_nodes)\n            for i in range(0, len(high_dist_nodes)-1, 2):\n                if i+1 < len(high_dist_nodes):\n                    new_solution[high_dist_nodes[i]], new_solution[high_dist_nodes[i+1]] = \\\n                    new_solution[high_dist_nodes[i+1]], new_solution[high_dist_nodes[i]]\n\n    # Adaptive node redistribution\n    if n > 7:\n        # Identify clusters of nodes in either objective space\n        cluster_size = max(2, n // 5)\n        for i in range(0, n, cluster_size):\n            cluster = new_solution[i:i+cluster_size]\n            if len(cluster) > 1:\n                # Calculate cluster centroids\n                centroid1 = instance[cluster, 0:2].mean(axis=0)\n                centroid2 = instance[cluster, 2:4].mean(axis=0)\n\n                # Reorder cluster nodes based on distance to centroids\n                dist_to_centroid1 = np.array([np.linalg.norm(instance[node, 0:2] - centroid1) for node in cluster])\n                dist_to_centroid2 = np.array([np.linalg.norm(instance[node, 2:4] - centroid2) for node in cluster])\n\n                combined_dist = dist_to_centroid1 + dist_to_centroid2\n                sorted_indices = np.argsort(combined_dist)\n                new_solution[i:i+cluster_size] = cluster[sorted_indices]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective dominance and solution quality, then applies a novel \"multi-objective path inversion with adaptive segment reversal\" to generate a neighbor solution while ensuring feasibility through careful segment handling and cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with good objective values and high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path inversion with adaptive segment reversal\n    if n > 4:\n        # Select two random segments\n        seg1_start = np.random.randint(0, n - 2)\n        seg1_end = np.random.randint(seg1_start + 1, n)\n        seg2_start = np.random.randint(0, n - 2)\n        seg2_end = np.random.randint(seg2_start + 1, n)\n\n        # Calculate original segment costs\n        orig_seg1_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg1_start, seg1_end)) +\n                          sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg1_start, seg1_end)))\n        orig_seg2_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg2_start, seg2_end)) +\n                          sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg2_start, seg2_end)))\n\n        # Invert and reverse segments\n        new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n        new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n        # Calculate new segment costs\n        new_seg1_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg1_start, seg1_end)) +\n                         sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg1_start, seg1_end)))\n        new_seg2_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg2_start, seg2_end)) +\n                         sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg2_start, seg2_end)))\n\n        # Revert if no improvement in both objectives\n        if (new_seg1_cost >= orig_seg1_cost) and (new_seg2_cost >= orig_seg2_cost):\n            new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n            new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n    # Adaptive segment reversal with cost evaluation\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before reversal\n                orig_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                orig_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Reverse segment between i and j\n                segment = new_solution[min(i,j):max(i,j)+1]\n                new_solution[min(i,j):max(i,j)+1] = segment[::-1]\n\n                # Calculate edge costs after reversal\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if reversal doesn't improve both objectives\n                if (new_cost1 >= orig_cost1) or (new_cost2 >= orig_cost2):\n                    new_solution[min(i,j):max(i,j)+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.8420617790362966,
            0.2528277039527893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with good objective values and high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path inversion with adaptive segment reversal\n    if n > 4:\n        # Select two random segments\n        seg1_start = np.random.randint(0, n - 2)\n        seg1_end = np.random.randint(seg1_start + 1, n)\n        seg2_start = np.random.randint(0, n - 2)\n        seg2_end = np.random.randint(seg2_start + 1, n)\n\n        # Calculate original segment costs\n        orig_seg1_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg1_start, seg1_end)) +\n                          sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg1_start, seg1_end)))\n        orig_seg2_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg2_start, seg2_end)) +\n                          sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg2_start, seg2_end)))\n\n        # Invert and reverse segments\n        new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n        new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n        # Calculate new segment costs\n        new_seg1_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg1_start, seg1_end)) +\n                         sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg1_start, seg1_end)))\n        new_seg2_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg2_start, seg2_end)) +\n                         sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg2_start, seg2_end)))\n\n        # Revert if no improvement in both objectives\n        if (new_seg1_cost >= orig_seg1_cost) and (new_seg2_cost >= orig_seg2_cost):\n            new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n            new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n    # Adaptive segment reversal with cost evaluation\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before reversal\n                orig_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                orig_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Reverse segment between i and j\n                segment = new_solution[min(i,j):max(i,j)+1]\n                new_solution[min(i,j):max(i,j)+1] = segment[::-1]\n\n                # Calculate edge costs after reversal\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if reversal doesn't improve both objectives\n                if (new_cost1 >= orig_cost1) or (new_cost2 >= orig_cost2):\n                    new_solution[min(i,j):max(i,j)+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score and crowding distance, then applies a hybrid local search combining a \"multi-segment inversion\" with an \"objective-balanced swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Normalized objective score with crowding distance\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4\n\n    # Calculate crowding distance\n    sorted_indices = np.argsort(scores)\n    crowding = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding[sorted_indices[i]] = scores[sorted_indices[i+1]] - scores[sorted_indices[i-1]]\n    crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n\n    # Combine score and crowding\n    combined_score = scores + 0.3 * crowding\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + objective-balanced swap\n    if n > 5:\n        # Multi-segment inversion: Invert 2-3 segments of 2-4 nodes each\n        num_segments = np.random.randint(2, 4)\n        segment_lengths = np.random.randint(2, 5, size=num_segments)\n        starts = np.random.choice(n-max(segment_lengths), num_segments, replace=False)\n\n        for start, length in zip(starts, segment_lengths):\n            if start + length <= n:\n                new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        # Objective-balanced swap: Swap nodes based on their contribution to each objective\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Calculate contribution to each objective\n            contrib1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] -\n                       distance_matrix_1[new_solution[j-1], new_solution[(j+1)%n]])\n\n            contrib2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] -\n                       distance_matrix_2[new_solution[j-1], new_solution[(j+1)%n]])\n\n            if contrib1 > 0.8 * np.mean(distance_matrix_1) or contrib2 > 0.8 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7625831061654952,
            0.3522537350654602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Normalized objective score with crowding distance\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4\n\n    # Calculate crowding distance\n    sorted_indices = np.argsort(scores)\n    crowding = np.zeros(len(archive))\n    for i in range(1, len(archive)-1):\n        crowding[sorted_indices[i]] = scores[sorted_indices[i+1]] - scores[sorted_indices[i-1]]\n    crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = float('inf')\n\n    # Combine score and crowding\n    combined_score = scores + 0.3 * crowding\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + objective-balanced swap\n    if n > 5:\n        # Multi-segment inversion: Invert 2-3 segments of 2-4 nodes each\n        num_segments = np.random.randint(2, 4)\n        segment_lengths = np.random.randint(2, 5, size=num_segments)\n        starts = np.random.choice(n-max(segment_lengths), num_segments, replace=False)\n\n        for start, length in zip(starts, segment_lengths):\n            if start + length <= n:\n                new_solution[start:start+length] = new_solution[start:start+length][::-1]\n\n        # Objective-balanced swap: Swap nodes based on their contribution to each objective\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Calculate contribution to each objective\n            contrib1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]] +\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] -\n                       distance_matrix_1[new_solution[j-1], new_solution[(j+1)%n]])\n\n            contrib2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                       distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                       distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] -\n                       distance_matrix_2[new_solution[j-1], new_solution[(j+1)%n]])\n\n            if contrib1 > 0.8 * np.mean(distance_matrix_1) or contrib2 > 0.8 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining an \"adaptive node insertion\" with a \"cross-segment inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node insertion with cross-segment inversion\n    if n > 4:\n        # Adaptive node insertion\n        node_to_move = np.random.randint(0, n)\n        insertion_pos = np.random.randint(0, n)\n\n        if node_to_move != insertion_pos:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, insertion_pos, node)\n\n        # Cross-segment inversion with objective consideration\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            first_start = np.random.randint(0, n//2 - segment_length)\n            second_start = np.random.randint(n//2, n - segment_length)\n\n            first_segment = new_solution[first_start:first_start+segment_length]\n            second_segment = new_solution[second_start:second_start+segment_length]\n\n            # Calculate segment costs in both objectives\n            first_cost1 = sum(distance_matrix_1[first_segment[i], first_segment[i+1]] for i in range(len(first_segment)-1))\n            first_cost2 = sum(distance_matrix_2[first_segment[i], first_segment[i+1]] for i in range(len(first_segment)-1))\n            second_cost1 = sum(distance_matrix_1[second_segment[i], second_segment[i+1]] for i in range(len(second_segment)-1))\n            second_cost2 = sum(distance_matrix_2[second_segment[i], second_segment[i+1]] for i in range(len(second_segment)-1))\n\n            # Invert segments if it improves at least one objective\n            if (first_cost1 + first_cost2) > (second_cost1 + second_cost2):\n                new_solution[first_start:first_start+segment_length] = second_segment\n                new_solution[second_start:second_start+segment_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8600193836909391,
            0.18386399745941162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node insertion with cross-segment inversion\n    if n > 4:\n        # Adaptive node insertion\n        node_to_move = np.random.randint(0, n)\n        insertion_pos = np.random.randint(0, n)\n\n        if node_to_move != insertion_pos:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, insertion_pos, node)\n\n        # Cross-segment inversion with objective consideration\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            first_start = np.random.randint(0, n//2 - segment_length)\n            second_start = np.random.randint(n//2, n - segment_length)\n\n            first_segment = new_solution[first_start:first_start+segment_length]\n            second_segment = new_solution[second_start:second_start+segment_length]\n\n            # Calculate segment costs in both objectives\n            first_cost1 = sum(distance_matrix_1[first_segment[i], first_segment[i+1]] for i in range(len(first_segment)-1))\n            first_cost2 = sum(distance_matrix_2[first_segment[i], first_segment[i+1]] for i in range(len(first_segment)-1))\n            second_cost1 = sum(distance_matrix_1[second_segment[i], second_segment[i+1]] for i in range(len(second_segment)-1))\n            second_cost2 = sum(distance_matrix_2[second_segment[i], second_segment[i+1]] for i in range(len(second_segment)-1))\n\n            # Invert segments if it improves at least one objective\n            if (first_cost1 + first_cost2) > (second_cost1 + second_cost2):\n                new_solution[first_start:first_start+segment_length] = second_segment\n                new_solution[second_start:second_start+segment_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility, and additionally incorporates an adaptive segment insertion strategy that considers both objective improvements and spatial diversity to further refine the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 6:\n        # Adaptive segment insertion strategy\n        segment_length = np.random.randint(2, min(5, n//2))\n        source_start = np.random.randint(0, n - segment_length)\n        target_start = np.random.randint(0, n - segment_length)\n\n        segment = new_solution[source_start:source_start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Calculate potential insertion costs\n        insertion_cost1 = (distance_matrix_1[new_solution[target_start-1], segment[0]] +\n                          distance_matrix_1[segment[-1], new_solution[target_start+segment_length-1]] -\n                          distance_matrix_1[new_solution[target_start-1], new_solution[target_start+segment_length-1]])\n\n        insertion_cost2 = (distance_matrix_2[new_solution[target_start-1], segment[0]] +\n                          distance_matrix_2[segment[-1], new_solution[target_start+segment_length-1]] -\n                          distance_matrix_2[new_solution[target_start-1], new_solution[target_start+segment_length-1]])\n\n        # Insert if it improves at least one objective\n        if (insertion_cost1 < 0) or (insertion_cost2 < 0):\n            # Remove the segment from its original position\n            new_solution = np.concatenate([new_solution[:source_start], new_solution[source_start+segment_length:]])\n            # Insert the segment at the new position\n            new_solution = np.concatenate([new_solution[:target_start], segment, new_solution[target_start:]])\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Calculate segment diversity\n            first_diversity = len(set(first_segment))\n            second_diversity = len(set(second_segment))\n\n            # Merge segments if it improves diversity\n            if first_diversity > second_diversity:\n                new_solution[second_start:second_start+first_length] = first_segment\n            else:\n                new_solution[first_start:first_start+first_length] = second_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9525577026652636,
            0.07732278108596802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 6:\n        # Adaptive segment insertion strategy\n        segment_length = np.random.randint(2, min(5, n//2))\n        source_start = np.random.randint(0, n - segment_length)\n        target_start = np.random.randint(0, n - segment_length)\n\n        segment = new_solution[source_start:source_start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Calculate potential insertion costs\n        insertion_cost1 = (distance_matrix_1[new_solution[target_start-1], segment[0]] +\n                          distance_matrix_1[segment[-1], new_solution[target_start+segment_length-1]] -\n                          distance_matrix_1[new_solution[target_start-1], new_solution[target_start+segment_length-1]])\n\n        insertion_cost2 = (distance_matrix_2[new_solution[target_start-1], segment[0]] +\n                          distance_matrix_2[segment[-1], new_solution[target_start+segment_length-1]] -\n                          distance_matrix_2[new_solution[target_start-1], new_solution[target_start+segment_length-1]])\n\n        # Insert if it improves at least one objective\n        if (insertion_cost1 < 0) or (insertion_cost2 < 0):\n            # Remove the segment from its original position\n            new_solution = np.concatenate([new_solution[:source_start], new_solution[source_start+segment_length:]])\n            # Insert the segment at the new position\n            new_solution = np.concatenate([new_solution[:target_start], segment, new_solution[target_start:]])\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Calculate segment diversity\n            first_diversity = len(set(first_segment))\n            second_diversity = len(set(second_segment))\n\n            # Merge segments if it improves diversity\n            if first_diversity > second_diversity:\n                new_solution[second_start:second_start+first_length] = first_segment\n            else:\n                new_solution[first_start:first_start+first_length] = second_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel \"objective-aware segment insertion\" technique that intelligently reinserts segments of the tour to improve both objectives while maintaining feasibility, ensuring no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with good balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(archive_sorted))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Objective-aware segment insertion\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment from its current position\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Evaluate insertion positions\n        best_pos = start\n        best_improvement = 0\n\n        for pos in range(len(remaining) - segment_length + 1):\n            # Insert segment at position pos\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Calculate improvement (sum of improvements in both objectives)\n            improvement = (archive_sorted[selected_idx][1][0] - cost1) + (archive_sorted[selected_idx][1][1] - cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Apply the best insertion\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6698691302670272,
            3.6417845487594604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Choose a solution with good balance between objectives\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(archive_sorted))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Objective-aware segment insertion\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment from its current position\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Evaluate insertion positions\n        best_pos = start\n        best_improvement = 0\n\n        for pos in range(len(remaining) - segment_length + 1):\n            # Insert segment at position pos\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Calculate improvement (sum of improvements in both objectives)\n            improvement = (archive_sorted[selected_idx][1][0] - cost1) + (archive_sorted[selected_idx][1][1] - cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Apply the best insertion\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"node segment inversion with objective-aware merging\" strategy that combines local segment inversion with global segment merging to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: Segment inversion with objective-aware merging\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_len = np.random.randint(2, min(6, n//2))\n        seg2_len = np.random.randint(2, min(6, n - seg1_len))\n        seg1_start = np.random.randint(0, n - seg1_len - seg2_len)\n        seg2_start = np.random.randint(seg1_start + seg1_len, n - seg2_len)\n\n        seg1 = new_solution[seg1_start:seg1_start+seg1_len]\n        seg2 = new_solution[seg2_start:seg2_start+seg2_len]\n\n        # Invert segments if they improve at least one objective\n        seg1_cost1 = sum(distance_matrix_1[seg1[i], seg1[i+1]] for i in range(seg1_len-1))\n        seg1_cost2 = sum(distance_matrix_2[seg1[i], seg1[i+1]] for i in range(seg1_len-1))\n        seg2_cost1 = sum(distance_matrix_1[seg2[i], seg2[i+1]] for i in range(seg2_len-1))\n        seg2_cost2 = sum(distance_matrix_2[seg2[i], seg2[i+1]] for i in range(seg2_len-1))\n\n        if seg1_cost1 > distance_matrix_1[seg1[-1], seg1[0]] or seg1_cost2 > distance_matrix_2[seg1[-1], seg1[0]]:\n            new_solution[seg1_start:seg1_start+seg1_len] = seg1[::-1]\n\n        if seg2_cost1 > distance_matrix_2[seg2[-1], seg2[0]] or seg2_cost2 > distance_matrix_2[seg2[-1], seg2[0]]:\n            new_solution[seg2_start:seg2_start+seg2_len] = seg2[::-1]\n\n        # Merge segments if it improves diversity\n        if len(set(new_solution[seg1_start:seg1_start+seg1_len])) < len(set(new_solution[seg2_start:seg2_start+seg2_len])):\n            merged = np.concatenate([new_solution[seg1_start:seg1_start+seg1_len], new_solution[seg2_start:seg2_start+seg2_len]])\n            np.random.shuffle(merged)\n            new_solution[seg1_start:seg1_start+seg1_len] = merged[:seg1_len]\n            new_solution[seg2_start:seg2_start+seg2_len] = merged[seg1_len:seg1_len+seg2_len]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9001685144931393,
            0.2276729941368103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel local search: Segment inversion with objective-aware merging\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_len = np.random.randint(2, min(6, n//2))\n        seg2_len = np.random.randint(2, min(6, n - seg1_len))\n        seg1_start = np.random.randint(0, n - seg1_len - seg2_len)\n        seg2_start = np.random.randint(seg1_start + seg1_len, n - seg2_len)\n\n        seg1 = new_solution[seg1_start:seg1_start+seg1_len]\n        seg2 = new_solution[seg2_start:seg2_start+seg2_len]\n\n        # Invert segments if they improve at least one objective\n        seg1_cost1 = sum(distance_matrix_1[seg1[i], seg1[i+1]] for i in range(seg1_len-1))\n        seg1_cost2 = sum(distance_matrix_2[seg1[i], seg1[i+1]] for i in range(seg1_len-1))\n        seg2_cost1 = sum(distance_matrix_1[seg2[i], seg2[i+1]] for i in range(seg2_len-1))\n        seg2_cost2 = sum(distance_matrix_2[seg2[i], seg2[i+1]] for i in range(seg2_len-1))\n\n        if seg1_cost1 > distance_matrix_1[seg1[-1], seg1[0]] or seg1_cost2 > distance_matrix_2[seg1[-1], seg1[0]]:\n            new_solution[seg1_start:seg1_start+seg1_len] = seg1[::-1]\n\n        if seg2_cost1 > distance_matrix_2[seg2[-1], seg2[0]] or seg2_cost2 > distance_matrix_2[seg2[-1], seg2[0]]:\n            new_solution[seg2_start:seg2_start+seg2_len] = seg2[::-1]\n\n        # Merge segments if it improves diversity\n        if len(set(new_solution[seg1_start:seg1_start+seg1_len])) < len(set(new_solution[seg2_start:seg2_start+seg2_len])):\n            merged = np.concatenate([new_solution[seg1_start:seg1_start+seg1_len], new_solution[seg2_start:seg2_start+seg2_len]])\n            np.random.shuffle(merged)\n            new_solution[seg1_start:seg1_start+seg1_len] = merged[:seg1_len]\n            new_solution[seg2_start:seg2_start+seg2_len] = merged[seg1_len:seg1_len+seg2_len]\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment rotation\" with a \"cross-segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment rotation with objective-aware selection\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment if it improves at least one objective\n        rotated_segment = np.roll(segment, 1)\n        rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n        rotated_cost2 = sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n\n        if rotated_cost1 < segment_cost1 or rotated_cost2 < segment_cost2:\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion with diversity consideration\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            segment_start = np.random.randint(0, n - segment_length)\n            segment_to_insert = new_solution[segment_start:segment_start+segment_length]\n\n            # Insert segment if it improves diversity\n            if len(set(new_solution[:insert_pos])) > len(set(new_solution[insert_pos:insert_pos+segment_length])):\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment_to_insert,\n                    new_solution[insert_pos+segment_length:]\n                ])\n                # Ensure no duplicates\n                unique_nodes = np.unique(new_solution)\n                if len(unique_nodes) < n:\n                    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n                    for i in range(len(new_solution)):\n                        if new_solution[i] in unique_nodes:\n                            continue\n                        new_solution[i] = missing_nodes[0]\n                        missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.9821105945594084,
            0.2876160740852356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment rotation with objective-aware selection\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment if it improves at least one objective\n        rotated_segment = np.roll(segment, 1)\n        rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n        rotated_cost2 = sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n\n        if rotated_cost1 < segment_cost1 or rotated_cost2 < segment_cost2:\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion with diversity consideration\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            segment_start = np.random.randint(0, n - segment_length)\n            segment_to_insert = new_solution[segment_start:segment_start+segment_length]\n\n            # Insert segment if it improves diversity\n            if len(set(new_solution[:insert_pos])) > len(set(new_solution[insert_pos:insert_pos+segment_length])):\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment_to_insert,\n                    new_solution[insert_pos+segment_length:]\n                ])\n                # Ensure no duplicates\n                unique_nodes = np.unique(new_solution)\n                if len(unique_nodes) < n:\n                    missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n                    for i in range(len(new_solution)):\n                        if new_solution[i] in unique_nodes:\n                            continue\n                        new_solution[i] = missing_nodes[0]\n                        missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a hybrid local search combining a novel \"adaptive segment insertion\" with a \"multi-segment inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and quality\n    weighted_scores = []\n    for sol, obj in archive:\n        total_cost = obj[0] + obj[1]\n        quality = 1 / (1 + total_cost)  # Higher quality for lower cost\n        weighted_scores.append(quality * (obj[0] + obj[1]))\n\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion + multi-segment inversion\n    if n > 5:\n        # Adaptive segment insertion: Select a segment of variable size and insert it elsewhere\n        segment_size = min(n // 3, np.random.randint(2, 6))\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_pos = np.random.randint(0, n - segment_size)\n        if new_pos > start:\n            new_pos += segment_size\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_size:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n        # Multi-segment inversion: Invert multiple non-overlapping segments\n        if n > 10:\n            num_inversions = np.random.randint(1, min(4, n // 5))\n            inversion_points = sorted(np.random.choice(range(1, n), num_inversions, replace=False))\n            inversion_points = [0] + inversion_points + [n]\n            for i in range(len(inversion_points) - 1):\n                if inversion_points[i+1] - inversion_points[i] > 1:\n                    new_solution[inversion_points[i]:inversion_points[i+1]] = new_solution[inversion_points[i]:inversion_points[i+1]][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8591066033385534,
            0.16695553064346313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and quality\n    weighted_scores = []\n    for sol, obj in archive:\n        total_cost = obj[0] + obj[1]\n        quality = 1 / (1 + total_cost)  # Higher quality for lower cost\n        weighted_scores.append(quality * (obj[0] + obj[1]))\n\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion + multi-segment inversion\n    if n > 5:\n        # Adaptive segment insertion: Select a segment of variable size and insert it elsewhere\n        segment_size = min(n // 3, np.random.randint(2, 6))\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        new_pos = np.random.randint(0, n - segment_size)\n        if new_pos > start:\n            new_pos += segment_size\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_size:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n        # Multi-segment inversion: Invert multiple non-overlapping segments\n        if n > 10:\n            num_inversions = np.random.randint(1, min(4, n // 5))\n            inversion_points = sorted(np.random.choice(range(1, n), num_inversions, replace=False))\n            inversion_points = [0] + inversion_points + [n]\n            for i in range(len(inversion_points) - 1):\n                if inversion_points[i+1] - inversion_points[i] > 1:\n                    new_solution[inversion_points[i]:inversion_points[i+1]] = new_solution[inversion_points[i]:inversion_points[i+1]][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a novel \"objective-aware segment insertion\" strategy that intelligently reinserts segments from one part of the tour into another part while considering the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 3:\n        return archive[0][0].copy()\n\n    # Selection: Prioritize solutions with balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-aware segment insertion\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate segment costs\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    # Find insertion point considering both objectives\n    best_insertion = -1\n    best_score = float('inf')\n\n    for i in range(n - segment_length):\n        if i >= start and i < start + segment_length:\n            continue\n\n        # Calculate insertion cost\n        prev_node = new_solution[i]\n        next_node = new_solution[(i + segment_length) % n]\n\n        insertion_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        insertion_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        # Score based on objective trade-off\n        score = abs(insertion_cost1 - insertion_cost2)\n\n        if score < best_score:\n            best_score = score\n            best_insertion = i\n\n    if best_insertion != -1:\n        # Remove original segment\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:]\n        ])\n\n        # Insert at new position\n        new_solution = np.concatenate([\n            new_solution[:best_insertion],\n            segment,\n            new_solution[best_insertion:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8948062085036042,
            0.23161089420318604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 3:\n        return archive[0][0].copy()\n\n    # Selection: Prioritize solutions with balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-aware segment insertion\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate segment costs\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    # Find insertion point considering both objectives\n    best_insertion = -1\n    best_score = float('inf')\n\n    for i in range(n - segment_length):\n        if i >= start and i < start + segment_length:\n            continue\n\n        # Calculate insertion cost\n        prev_node = new_solution[i]\n        next_node = new_solution[(i + segment_length) % n]\n\n        insertion_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        insertion_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        # Score based on objective trade-off\n        score = abs(insertion_cost1 - insertion_cost2)\n\n        if score < best_score:\n            best_score = score\n            best_insertion = i\n\n    if best_insertion != -1:\n        # Remove original segment\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[start+segment_length:]\n        ])\n\n        # Insert at new position\n        new_solution = np.concatenate([\n            new_solution[:best_insertion],\n            segment,\n            new_solution[best_insertion:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(4, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(4, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8457679843825775,
            0.12484508752822876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(4, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(4, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"objective-aware segment reversal\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            np.random.shuffle(segment)\n            new_solution[start:start+segment_length] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.8423572711588683,
            0.3434475064277649
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            np.random.shuffle(segment)\n            new_solution[start:start+segment_length] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"adaptive segment insertion\" strategy that combines local and global reordering with objective-aware segment prioritization to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with lower combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with objective-aware prioritization\n    if n > 4:\n        # Select segment to insert\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Determine insertion point based on objective prioritization\n        if random.random() < 0.5:  # Prioritize first objective\n            insertion_point = np.argmin([distance_matrix_1[segment[-1], new_solution[i]] + distance_matrix_1[new_solution[i], segment[0]] for i in range(n) if i not in range(start, start+segment_length)])\n        else:  # Prioritize second objective\n            insertion_point = np.argmin([distance_matrix_2[segment[-1], new_solution[i]] + distance_matrix_2[new_solution[i], segment[0]] for i in range(n) if i not in range(start, start+segment_length)])\n\n        # Remove the segment and insert it at the new position\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        new_solution = np.insert(new_solution, insertion_point, segment)\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8200608764864113,
            0.3581938147544861
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with lower combined objective values\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with objective-aware prioritization\n    if n > 4:\n        # Select segment to insert\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Determine insertion point based on objective prioritization\n        if random.random() < 0.5:  # Prioritize first objective\n            insertion_point = np.argmin([distance_matrix_1[segment[-1], new_solution[i]] + distance_matrix_1[new_solution[i], segment[0]] for i in range(n) if i not in range(start, start+segment_length)])\n        else:  # Prioritize second objective\n            insertion_point = np.argmin([distance_matrix_2[segment[-1], new_solution[i]] + distance_matrix_2[new_solution[i], segment[0]] for i in range(n) if i not in range(start, start+segment_length)])\n\n        # Remove the segment and insert it at the new position\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        new_solution = np.insert(new_solution, insertion_point, segment)\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + cross-segment rotation\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and reverse it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, first_length)\n            new_solution[first_start:first_start+first_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n\n    return new_solution\n\n",
        "score": [
            -0.8802067696982778,
            0.21280068159103394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + cross-segment rotation\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-4 nodes and reverse it\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, first_length)\n            new_solution[first_start:first_start+first_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node cluster reallocation\" with an \"objective-balanced segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node cluster reallocation with objective-balanced segment rotation\n    if n > 5:\n        # Node cluster reallocation\n        cluster_size = np.random.randint(2, min(5, n//2))\n        cluster_pos = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_pos:cluster_pos+cluster_size]\n\n        # Calculate cluster costs in both objectives\n        cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n        cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n\n        # Reallocate cluster based on objective balance\n        if cluster_cost1 > cluster_cost2:\n            new_pos = np.random.randint(0, n - cluster_size)\n            new_solution = np.concatenate([new_solution[:cluster_pos], new_solution[cluster_pos+cluster_size:]])\n            new_solution = np.concatenate([new_solution[:new_pos], cluster, new_solution[new_pos:]])\n        else:\n            new_pos = np.random.randint(0, n - cluster_size)\n            new_solution = np.concatenate([new_solution[:cluster_pos], new_solution[cluster_pos+cluster_size:]])\n            new_solution = np.concatenate([new_solution[:new_pos], cluster[::-1], new_solution[new_pos:]])\n\n        # Objective-balanced segment rotation\n        if n > 10:\n            segment_length = np.random.randint(3, min(7, n//2))\n            segment_start = np.random.randint(0, n - segment_length)\n            segment = new_solution[segment_start:segment_start+segment_length]\n\n            # Calculate segment costs\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Rotate segment to balance objectives\n            rotation = np.random.randint(1, len(segment))\n            if segment_cost1 > segment_cost2:\n                rotated_segment = np.roll(segment, rotation)\n                new_solution[segment_start:segment_start+segment_length] = rotated_segment\n            else:\n                rotated_segment = np.roll(segment, -rotation)\n                new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8742963601674288,
            0.295834481716156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node cluster reallocation with objective-balanced segment rotation\n    if n > 5:\n        # Node cluster reallocation\n        cluster_size = np.random.randint(2, min(5, n//2))\n        cluster_pos = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_pos:cluster_pos+cluster_size]\n\n        # Calculate cluster costs in both objectives\n        cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n        cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n\n        # Reallocate cluster based on objective balance\n        if cluster_cost1 > cluster_cost2:\n            new_pos = np.random.randint(0, n - cluster_size)\n            new_solution = np.concatenate([new_solution[:cluster_pos], new_solution[cluster_pos+cluster_size:]])\n            new_solution = np.concatenate([new_solution[:new_pos], cluster, new_solution[new_pos:]])\n        else:\n            new_pos = np.random.randint(0, n - cluster_size)\n            new_solution = np.concatenate([new_solution[:cluster_pos], new_solution[cluster_pos+cluster_size:]])\n            new_solution = np.concatenate([new_solution[:new_pos], cluster[::-1], new_solution[new_pos:]])\n\n        # Objective-balanced segment rotation\n        if n > 10:\n            segment_length = np.random.randint(3, min(7, n//2))\n            segment_start = np.random.randint(0, n - segment_length)\n            segment = new_solution[segment_start:segment_start+segment_length]\n\n            # Calculate segment costs\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Rotate segment to balance objectives\n            rotation = np.random.randint(1, len(segment))\n            if segment_cost1 > segment_cost2:\n                rotated_segment = np.roll(segment, rotation)\n                new_solution[segment_start:segment_start+segment_length] = rotated_segment\n            else:\n                rotated_segment = np.roll(segment, -rotation)\n                new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel \"multi-objective segment inversion with adaptive edge flipping\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with diverse objectives and good balance\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_length)\n\n        # Calculate segment cost before inversion\n        original_segment = new_solution[start:start+segment_length]\n        cost1_before = sum(distance_matrix_1[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n        cost2_before = sum(distance_matrix_2[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n\n        # Invert segment\n        new_solution[start:start+segment_length] = original_segment[::-1]\n\n        inverted_segment = new_solution[start:start+segment_length]\n        cost1_after = sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n        cost2_after = sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n\n        # Revert if inversion doesn't improve both objectives\n        if (cost1_after >= cost1_before and cost2_after >= cost2_before) or \\\n           (cost1_after > cost1_before or cost2_after > cost2_before):\n            new_solution[start:start+segment_length] = original_segment\n\n    # Adaptive edge flipping\n    if n > 6:\n        for _ in range(3):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n\n            # Calculate edges before flipping\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            # Flip edges\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n            # Calculate edges after flipping\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            # Revert if flipping doesn't improve both objectives\n            if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2) or \\\n               (new_cost1 > original_cost1 or new_cost2 > original_cost2):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9466365748551666,
            0.3338868021965027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with diverse objectives and good balance\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (abs(x[1][0] - x[1][1]) + 1))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_length)\n\n        # Calculate segment cost before inversion\n        original_segment = new_solution[start:start+segment_length]\n        cost1_before = sum(distance_matrix_1[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n        cost2_before = sum(distance_matrix_2[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n\n        # Invert segment\n        new_solution[start:start+segment_length] = original_segment[::-1]\n\n        inverted_segment = new_solution[start:start+segment_length]\n        cost1_after = sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n        cost2_after = sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n\n        # Revert if inversion doesn't improve both objectives\n        if (cost1_after >= cost1_before and cost2_after >= cost2_before) or \\\n           (cost1_after > cost1_before or cost2_after > cost2_before):\n            new_solution[start:start+segment_length] = original_segment\n\n    # Adaptive edge flipping\n    if n > 6:\n        for _ in range(3):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n\n            # Calculate edges before flipping\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            # Flip edges\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n            # Calculate edges after flipping\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            # Revert if flipping doesn't improve both objectives\n            if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2) or \\\n               (new_cost1 > original_cost1 or new_cost2 > original_cost2):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment insertion\" with an \"objective-aware segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment insertion with segment swap\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(4, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert segment at a different position if it improves at least one objective\n        insert_pos = np.random.randint(0, n)\n        if insert_pos >= start and insert_pos <= start + segment_length:\n            insert_pos = (start + segment_length) % n\n\n        # Calculate new costs\n        prev_node = new_solution[insert_pos - 1] if insert_pos > 0 else new_solution[-1]\n        next_node = new_solution[insert_pos] if insert_pos < n - 1 else new_solution[0]\n        new_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        new_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        if new_cost1 < segment_cost1 or new_cost2 < segment_cost2:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:]\n            ])\n            if len(new_solution) > n:\n                new_solution = np.delete(new_solution, insert_pos + segment_length)\n\n        # Cross-segment swap with objective consideration\n        if n > 6:\n            swap_pos1 = np.random.randint(0, n//2 - 1)\n            swap_pos2 = np.random.randint(n//2, n - 1)\n            swap_length = np.random.randint(1, min(3, n//2 - swap_pos1))\n\n            segment1 = new_solution[swap_pos1:swap_pos1+swap_length]\n            segment2 = new_solution[swap_pos2:swap_pos2+swap_length]\n\n            # Calculate segment costs\n            cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[i+1]] for i in range(len(segment1)-1))\n            cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[i+1]] for i in range(len(segment1)-1))\n            cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[i+1]] for i in range(len(segment2)-1))\n            cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[i+1]] for i in range(len(segment2)-1))\n\n            # Swap if it improves at least one objective\n            if (cost1_seg1 > cost1_seg2 or cost2_seg1 > cost2_seg2):\n                new_solution[swap_pos1:swap_pos1+swap_length] = segment2\n                new_solution[swap_pos2:swap_pos2+swap_length] = segment1\n\n    return new_solution\n\n",
        "score": [
            -0.970395179570867,
            0.1744043231010437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment insertion with segment swap\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(4, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert segment at a different position if it improves at least one objective\n        insert_pos = np.random.randint(0, n)\n        if insert_pos >= start and insert_pos <= start + segment_length:\n            insert_pos = (start + segment_length) % n\n\n        # Calculate new costs\n        prev_node = new_solution[insert_pos - 1] if insert_pos > 0 else new_solution[-1]\n        next_node = new_solution[insert_pos] if insert_pos < n - 1 else new_solution[0]\n        new_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        new_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        if new_cost1 < segment_cost1 or new_cost2 < segment_cost2:\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos:]\n            ])\n            if len(new_solution) > n:\n                new_solution = np.delete(new_solution, insert_pos + segment_length)\n\n        # Cross-segment swap with objective consideration\n        if n > 6:\n            swap_pos1 = np.random.randint(0, n//2 - 1)\n            swap_pos2 = np.random.randint(n//2, n - 1)\n            swap_length = np.random.randint(1, min(3, n//2 - swap_pos1))\n\n            segment1 = new_solution[swap_pos1:swap_pos1+swap_length]\n            segment2 = new_solution[swap_pos2:swap_pos2+swap_length]\n\n            # Calculate segment costs\n            cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[i+1]] for i in range(len(segment1)-1))\n            cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[i+1]] for i in range(len(segment1)-1))\n            cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[i+1]] for i in range(len(segment2)-1))\n            cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[i+1]] for i in range(len(segment2)-1))\n\n            # Swap if it improves at least one objective\n            if (cost1_seg1 > cost1_seg2 or cost2_seg1 > cost2_seg2):\n                new_solution[swap_pos1:swap_pos1+swap_length] = segment2\n                new_solution[swap_pos2:swap_pos2+swap_length] = segment1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining an \"adaptive node sequence inversion\" with \"objective-biased segment transposition\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better balance between objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence inversion with objective-biased segment transposition\n    if n > 4:\n        # Adaptive node sequence inversion\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert or reorder segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = segment[::-1]\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 0] - instance[x, 2])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment transposition\n        if n > 8:\n            trans_length = np.random.randint(2, min(5, n//2))\n            trans_start = np.random.randint(0, n - trans_length)\n            trans_segment = new_solution[trans_start:trans_start+trans_length]\n\n            # Calculate transposition cost in both objectives\n            trans_cost1 = sum(distance_matrix_1[trans_segment[i], trans_segment[i+1]] for i in range(len(trans_segment)-1))\n            trans_cost2 = sum(distance_matrix_2[trans_segment[i], trans_segment[i+1]] for i in range(len(trans_segment)-1))\n\n            # Transpose segment to position that improves the weaker objective\n            if trans_cost1 > trans_cost2:\n                new_pos = np.random.randint(0, n - trans_length)\n                new_solution = np.concatenate([new_solution[:trans_start], new_solution[trans_start+trans_length:]])\n                new_solution = np.concatenate([new_solution[:new_pos], trans_segment, new_solution[new_pos:]])\n            else:\n                new_pos = np.random.randint(0, n - trans_length)\n                new_solution = np.concatenate([new_solution[:trans_start], new_solution[trans_start+trans_length:]])\n                new_solution = np.concatenate([new_solution[:new_pos], trans_segment, new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8260115575097786,
            0.38884276151657104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with better balance between objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence inversion with objective-biased segment transposition\n    if n > 4:\n        # Adaptive node sequence inversion\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert or reorder segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = segment[::-1]\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 0] - instance[x, 2])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment transposition\n        if n > 8:\n            trans_length = np.random.randint(2, min(5, n//2))\n            trans_start = np.random.randint(0, n - trans_length)\n            trans_segment = new_solution[trans_start:trans_start+trans_length]\n\n            # Calculate transposition cost in both objectives\n            trans_cost1 = sum(distance_matrix_1[trans_segment[i], trans_segment[i+1]] for i in range(len(trans_segment)-1))\n            trans_cost2 = sum(distance_matrix_2[trans_segment[i], trans_segment[i+1]] for i in range(len(trans_segment)-1))\n\n            # Transpose segment to position that improves the weaker objective\n            if trans_cost1 > trans_cost2:\n                new_pos = np.random.randint(0, n - trans_length)\n                new_solution = np.concatenate([new_solution[:trans_start], new_solution[trans_start+trans_length:]])\n                new_solution = np.concatenate([new_solution[:new_pos], trans_segment, new_solution[new_pos:]])\n            else:\n                new_pos = np.random.randint(0, n - trans_length)\n                new_solution = np.concatenate([new_solution[:trans_start], new_solution[trans_start+trans_length:]])\n                new_solution = np.concatenate([new_solution[:new_pos], trans_segment, new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-segment rotation\" with \"objective-aware edge flipping\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment rotation\n    if n > 6:\n        num_segments = np.random.randint(2, min(4, n//3))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n        segment_starts = np.sort(np.random.choice(n - sum(segment_lengths), num_segments, replace=False))\n\n        segments = []\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            segments.append(new_solution[start:start+length])\n\n        # Rotate segments\n        np.random.shuffle(segments)\n        current_pos = 0\n        for segment in segments:\n            new_solution[current_pos:current_pos+len(segment)] = segment\n            current_pos += len(segment)\n\n    # Objective-aware edge flipping\n    if n > 4:\n        for _ in range(3):\n            i = np.random.randint(1, n-1)\n            j = np.random.randint(1, n-1)\n            if i != j:\n                # Calculate edge costs before flipping\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                                distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                                distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n                # Flip edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after flipping\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n                # Revert if flipping doesn't improve both objectives\n                if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8760712827419869,
            0.11806643009185791
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment rotation\n    if n > 6:\n        num_segments = np.random.randint(2, min(4, n//3))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n        segment_starts = np.sort(np.random.choice(n - sum(segment_lengths), num_segments, replace=False))\n\n        segments = []\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            segments.append(new_solution[start:start+length])\n\n        # Rotate segments\n        np.random.shuffle(segments)\n        current_pos = 0\n        for segment in segments:\n            new_solution[current_pos:current_pos+len(segment)] = segment\n            current_pos += len(segment)\n\n    # Objective-aware edge flipping\n    if n > 4:\n        for _ in range(3):\n            i = np.random.randint(1, n-1)\n            j = np.random.randint(1, n-1)\n            if i != j:\n                # Calculate edge costs before flipping\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                                distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                                distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n                # Flip edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after flipping\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]] + \\\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]] + \\\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n\n                # Revert if flipping doesn't improve both objectives\n                if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel \"adaptive segment inversion and position swapping\" strategy that combines local segment manipulation with global position adjustments to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    # Selection: Prioritize solutions with balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment inversion and position swapping\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Invert segment if it improves the weaker objective\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    if segment_cost1 > segment_cost2:\n        segment = segment[::-1]\n    else:\n        segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n    new_solution[start:start+segment_length] = segment\n\n    # Global position swapping\n    swap_positions = random.sample(range(n), 2)\n    new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.7400845661369829,
            0.2461937665939331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 4:\n        return archive[0][0].copy()\n\n    # Selection: Prioritize solutions with balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = np.random.choice(min(3, len(archive_sorted)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Adaptive segment inversion and position swapping\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Invert segment if it improves the weaker objective\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    if segment_cost1 > segment_cost2:\n        segment = segment[::-1]\n    else:\n        segment = np.roll(segment, np.random.randint(1, len(segment)))\n\n    new_solution[start:start+segment_length] = segment\n\n    # Global position swapping\n    swap_positions = random.sample(range(n), 2)\n    new_solution[swap_positions[0]], new_solution[swap_positions[1]] = new_solution[swap_positions[1]], new_solution[swap_positions[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment inversion\" with \"adaptive edge swapping\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_length)\n\n        # Calculate segment cost before inversion\n        original_segment = new_solution[start:start+segment_length]\n        cost1_before = sum(distance_matrix_1[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n        cost2_before = sum(distance_matrix_2[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n\n        # Perform inversion\n        new_solution[start:start+segment_length] = original_segment[::-1]\n\n        inverted_segment = new_solution[start:start+segment_length]\n        cost1_after = sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n        cost2_after = sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n\n        # Revert if inversion doesn't improve both objectives\n        if (cost1_after >= cost1_before) or (cost2_after >= cost2_before):\n            new_solution[start:start+segment_length] = original_segment\n\n    # Adaptive edge swapping\n    if n > 6:\n        for _ in range(3):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before swapping\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Swap edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after swapping\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if swapping doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.928758937195772,
            0.2457282543182373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_length)\n\n        # Calculate segment cost before inversion\n        original_segment = new_solution[start:start+segment_length]\n        cost1_before = sum(distance_matrix_1[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n        cost2_before = sum(distance_matrix_2[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n\n        # Perform inversion\n        new_solution[start:start+segment_length] = original_segment[::-1]\n\n        inverted_segment = new_solution[start:start+segment_length]\n        cost1_after = sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n        cost2_after = sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n\n        # Revert if inversion doesn't improve both objectives\n        if (cost1_after >= cost1_before) or (cost2_after >= cost2_before):\n            new_solution[start:start+segment_length] = original_segment\n\n    # Adaptive edge swapping\n    if n > 6:\n        for _ in range(3):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before swapping\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Swap edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after swapping\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if swapping doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(10, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(8, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 12:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(8, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9316990061128116,
            0.07611352205276489
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(10, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(8, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 12:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(8, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"node segment insertion\" with a \"cross-segment inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment insertion + cross-segment inversion\n    if n > 4:\n        # Node segment insertion: Select a segment and insert it at a different position\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment and insert it elsewhere\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Cross-segment inversion: Invert a segment between two nodes with high diversity\n        if n > 8:\n            node1 = np.random.randint(0, n//2)\n            node2 = np.random.randint(n//2, n)\n\n            # Find the segment between node1 and node2\n            if node1 > node2:\n                node1, node2 = node2, node1\n            segment = new_solution[node1:node2+1]\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert if it improves at least one objective\n            if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n                new_solution[node1:node2+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9145073643261231,
            0.22440850734710693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment insertion + cross-segment inversion\n    if n > 4:\n        # Node segment insertion: Select a segment and insert it at a different position\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment and insert it elsewhere\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Cross-segment inversion: Invert a segment between two nodes with high diversity\n        if n > 8:\n            node1 = np.random.randint(0, n//2)\n            node2 = np.random.randint(n//2, n)\n\n            # Find the segment between node1 and node2\n            if node1 > node2:\n                node1, node2 = node2, node1\n            segment = new_solution[node1:node2+1]\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert if it improves at least one objective\n            if segment_cost1 > distance_matrix_1[segment[-1], segment[0]] or segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n                new_solution[node1:node2+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"objective-aware node cluster shuffle\" with \"adaptive partial tour inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware node cluster shuffle with adaptive partial inversion\n    if n > 5:\n        # Objective-aware node cluster identification\n        cluster_size = np.random.randint(2, min(5, n//2))\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Calculate cluster costs in both objectives\n        cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n        cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n\n        # Shuffle cluster if it improves at least one objective\n        if cluster_cost1 > distance_matrix_1[cluster[-1], cluster[0]] or \\\n           cluster_cost2 > distance_matrix_2[cluster[-1], cluster[0]]:\n            np.random.shuffle(cluster)\n            new_solution[cluster_start:cluster_start+cluster_size] = cluster\n\n        # Adaptive partial inversion with objective bias\n        if n > 8:\n            inversion_length = np.random.randint(3, min(7, n))\n            inversion_start = np.random.randint(0, n - inversion_length)\n            segment = new_solution[inversion_start:inversion_start+inversion_length]\n\n            # Calculate segment costs\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert if it improves both objectives or one objective significantly\n            if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and \\\n                segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n               (segment_cost1 > 1.1 * distance_matrix_1[segment[-1], segment[0]] or \\\n                segment_cost2 > 1.1 * distance_matrix_2[segment[-1], segment[0]]):\n                new_solution[inversion_start:inversion_start+inversion_length] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7629040899386894,
            0.31147676706314087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware node cluster shuffle with adaptive partial inversion\n    if n > 5:\n        # Objective-aware node cluster identification\n        cluster_size = np.random.randint(2, min(5, n//2))\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Calculate cluster costs in both objectives\n        cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n        cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n\n        # Shuffle cluster if it improves at least one objective\n        if cluster_cost1 > distance_matrix_1[cluster[-1], cluster[0]] or \\\n           cluster_cost2 > distance_matrix_2[cluster[-1], cluster[0]]:\n            np.random.shuffle(cluster)\n            new_solution[cluster_start:cluster_start+cluster_size] = cluster\n\n        # Adaptive partial inversion with objective bias\n        if n > 8:\n            inversion_length = np.random.randint(3, min(7, n))\n            inversion_start = np.random.randint(0, n - inversion_length)\n            segment = new_solution[inversion_start:inversion_start+inversion_length]\n\n            # Calculate segment costs\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert if it improves both objectives or one objective significantly\n            if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and \\\n                segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n               (segment_cost1 > 1.1 * distance_matrix_1[segment[-1], segment[0]] or \\\n                segment_cost2 > 1.1 * distance_matrix_2[segment[-1], segment[0]]):\n                new_solution[inversion_start:inversion_start+inversion_length] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment rotation\" with a \"cross-segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment rotation with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[start:start+segment_length] = rotated_segment\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion with diversity consideration\n        if n > 10:\n            insert_pos = np.random.randint(n//2, n - 3)\n            segment_start = np.random.randint(0, n//2 - 3)\n            segment_length = np.random.randint(3, min(7, n//2 - segment_start))\n            segment = new_solution[segment_start:segment_start+segment_length]\n\n            # Insert segment if it improves diversity\n            if len(set(new_solution[insert_pos:insert_pos+segment_length])) < len(set(segment)):\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment,\n                    new_solution[insert_pos+segment_length:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.8329685367547373,
            0.2081817388534546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment rotation with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[start:start+segment_length] = rotated_segment\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion with diversity consideration\n        if n > 10:\n            insert_pos = np.random.randint(n//2, n - 3)\n            segment_start = np.random.randint(0, n//2 - 3)\n            segment_length = np.random.randint(3, min(7, n//2 - segment_start))\n            segment = new_solution[segment_start:segment_start+segment_length]\n\n            # Insert segment if it improves diversity\n            if len(set(new_solution[insert_pos:insert_pos+segment_length])) < len(set(segment)):\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment,\n                    new_solution[insert_pos+segment_length:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"multi-objective segment rotation\" with \"objective-balanced node insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(np.std(normalized, axis=0))\n    scores = np.linalg.norm(normalized, axis=1) * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-objective segment rotation + objective-balanced node insertion\n    if n > 4:\n        # Multi-objective segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment based on objective balance\n        if segment_cost1 > segment_cost2:\n            rotate_amount = np.random.randint(1, len(segment))\n            segment = np.roll(segment, rotate_amount)\n        else:\n            rotate_amount = np.random.randint(1, len(segment))\n            segment = np.roll(segment, -rotate_amount)\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-balanced node insertion\n        if n > 6:\n            insert_pos = np.random.randint(0, n)\n            insert_node = np.random.choice(new_solution)\n\n            # Calculate insertion cost in both objectives\n            prev_node = new_solution[insert_pos-1] if insert_pos > 0 else new_solution[-1]\n            next_node = new_solution[insert_pos] if insert_pos < n-1 else new_solution[0]\n            cost1_remove = distance_matrix_1[prev_node, next_node]\n            cost2_remove = distance_matrix_2[prev_node, next_node]\n            cost1_insert = distance_matrix_1[prev_node, insert_node] + distance_matrix_1[insert_node, next_node]\n            cost2_insert = distance_matrix_2[prev_node, insert_node] + distance_matrix_2[insert_node, next_node]\n\n            # Insert if it improves the balanced objective\n            if (cost1_insert - cost1_remove) + (cost2_insert - cost2_remove) < 0:\n                new_solution = np.insert(new_solution, insert_pos, insert_node)\n                new_solution = np.delete(new_solution, np.where(new_solution == insert_node)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.6267212064770297,
            0.3962233066558838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    objectives = np.array([x[1] for x in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    diversity = np.mean(np.std(normalized, axis=0))\n    scores = np.linalg.norm(normalized, axis=1) * diversity\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-objective segment rotation + objective-balanced node insertion\n    if n > 4:\n        # Multi-objective segment rotation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment based on objective balance\n        if segment_cost1 > segment_cost2:\n            rotate_amount = np.random.randint(1, len(segment))\n            segment = np.roll(segment, rotate_amount)\n        else:\n            rotate_amount = np.random.randint(1, len(segment))\n            segment = np.roll(segment, -rotate_amount)\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-balanced node insertion\n        if n > 6:\n            insert_pos = np.random.randint(0, n)\n            insert_node = np.random.choice(new_solution)\n\n            # Calculate insertion cost in both objectives\n            prev_node = new_solution[insert_pos-1] if insert_pos > 0 else new_solution[-1]\n            next_node = new_solution[insert_pos] if insert_pos < n-1 else new_solution[0]\n            cost1_remove = distance_matrix_1[prev_node, next_node]\n            cost2_remove = distance_matrix_2[prev_node, next_node]\n            cost1_insert = distance_matrix_1[prev_node, insert_node] + distance_matrix_1[insert_node, next_node]\n            cost2_insert = distance_matrix_2[prev_node, insert_node] + distance_matrix_2[insert_node, next_node]\n\n            # Insert if it improves the balanced objective\n            if (cost1_insert - cost1_remove) + (cost2_insert - cost2_remove) < 0:\n                new_solution = np.insert(new_solution, insert_pos, insert_node)\n                new_solution = np.delete(new_solution, np.where(new_solution == insert_node)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This algorithm selects a high-diversity solution from the archive, then applies a novel \"objective-balanced segment inversion\" with \"adaptive node reinsertion\" to generate neighbors that explore the trade-off space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 3:\n        return archive[0][0].copy()\n\n    # Selection: Choose a solution with high diversity (large difference in objectives)\n    archive_with_diversity = sorted(archive, key=lambda x: -abs(x[1][0] - x[1][1]))\n    selected_idx = min(3, len(archive_with_diversity) - 1)\n    base_solution = archive_with_diversity[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-balanced segment inversion\n    segment_length = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_length)\n\n    # Invert the segment if it improves the balance between objectives\n    original_segment = new_solution[start:start+segment_length]\n    inverted_segment = original_segment[::-1]\n\n    original_cost1 = sum(distance_matrix_1[original_segment[i-1], original_segment[i]] for i in range(1, len(original_segment)))\n    original_cost2 = sum(distance_matrix_2[original_segment[i-1], original_segment[i]] for i in range(1, len(original_segment)))\n\n    new_cost1 = sum(distance_matrix_1[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n    new_cost2 = sum(distance_matrix_2[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n\n    # Calculate balance metrics\n    original_balance = abs(original_cost1 - original_cost2)\n    new_balance = abs(new_cost1 - new_cost2)\n\n    if new_balance < original_balance:\n        new_solution[start:start+segment_length] = inverted_segment\n\n    # Adaptive node reinsertion\n    if n > 4:\n        node_to_move = np.random.randint(0, n)\n        original_node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n\n        # Find best insertion point that improves both objectives\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(n-1):\n            temp_solution = np.insert(new_solution, i, original_node)\n            temp_cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(1, n))\n            temp_cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(1, n))\n\n            if temp_cost1 < best_cost1 and temp_cost2 < best_cost2:\n                best_pos = i\n                best_cost1 = temp_cost1\n                best_cost2 = temp_cost2\n\n        new_solution = np.insert(new_solution, best_pos, original_node)\n\n    return new_solution\n\n",
        "score": [
            -0.6571738785363515,
            1.3277576565742493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    if n < 3:\n        return archive[0][0].copy()\n\n    # Selection: Choose a solution with high diversity (large difference in objectives)\n    archive_with_diversity = sorted(archive, key=lambda x: -abs(x[1][0] - x[1][1]))\n    selected_idx = min(3, len(archive_with_diversity) - 1)\n    base_solution = archive_with_diversity[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-balanced segment inversion\n    segment_length = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_length)\n\n    # Invert the segment if it improves the balance between objectives\n    original_segment = new_solution[start:start+segment_length]\n    inverted_segment = original_segment[::-1]\n\n    original_cost1 = sum(distance_matrix_1[original_segment[i-1], original_segment[i]] for i in range(1, len(original_segment)))\n    original_cost2 = sum(distance_matrix_2[original_segment[i-1], original_segment[i]] for i in range(1, len(original_segment)))\n\n    new_cost1 = sum(distance_matrix_1[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n    new_cost2 = sum(distance_matrix_2[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n\n    # Calculate balance metrics\n    original_balance = abs(original_cost1 - original_cost2)\n    new_balance = abs(new_cost1 - new_cost2)\n\n    if new_balance < original_balance:\n        new_solution[start:start+segment_length] = inverted_segment\n\n    # Adaptive node reinsertion\n    if n > 4:\n        node_to_move = np.random.randint(0, n)\n        original_node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n\n        # Find best insertion point that improves both objectives\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(n-1):\n            temp_solution = np.insert(new_solution, i, original_node)\n            temp_cost1 = sum(distance_matrix_1[temp_solution[j-1], temp_solution[j]] for j in range(1, n))\n            temp_cost2 = sum(distance_matrix_2[temp_solution[j-1], temp_solution[j]] for j in range(1, n))\n\n            if temp_cost1 < best_cost1 and temp_cost2 < best_cost2:\n                best_pos = i\n                best_cost1 = temp_cost1\n                best_cost2 = temp_cost2\n\n        new_solution = np.insert(new_solution, best_pos, original_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This new algorithm selects a solution from the archive using a weighted random selection based on the harmonic mean of normalized objectives, then applies a hybrid local search combining adaptive segment rotation with objective-aware segment replacement to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted random selection based on harmonic mean of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / (max_obj + 1e-10)\n    harmonic_weights = 2 / (1/norm_obj[:, 0] + 1/norm_obj[:, 1])\n    selection_probs = harmonic_weights / np.sum(harmonic_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment rotation with objective-aware replacement\n    if n > 5:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment if it improves both objectives\n        rotated_segment = np.roll(segment, 1)\n        rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost2 = sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(segment)-1))\n\n        if (rotated_cost1 < cost1 and rotated_cost2 < cost2) or \\\n           (rotated_cost1 < cost1 and np.random.random() < 0.3) or \\\n           (rotated_cost2 < cost2 and np.random.random() < 0.3):\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Objective-aware segment replacement\n        if n > 10 and np.random.random() < 0.7:\n            other_idx = np.random.choice(len(archive))\n            other_solution = archive[other_idx][0]\n            other_segment_start = np.random.randint(0, n - segment_length)\n            other_segment = other_solution[other_segment_start:other_segment_start+segment_length]\n\n            other_cost1 = sum(distance_matrix_1[other_segment[i], other_segment[i+1]] for i in range(len(segment)-1))\n            other_cost2 = sum(distance_matrix_2[other_segment[i], other_segment[i+1]] for i in range(len(segment)-1))\n\n            if (other_cost1 < cost1 and other_cost2 < cost2) or \\\n               (other_cost1 < cost1 and np.random.random() < 0.4) or \\\n               (other_cost2 < cost2 and np.random.random() < 0.4):\n                new_solution[start:start+segment_length] = other_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8265404918311694,
            0.6450703144073486
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted random selection based on harmonic mean of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    norm_obj = objectives / (max_obj + 1e-10)\n    harmonic_weights = 2 / (1/norm_obj[:, 0] + 1/norm_obj[:, 1])\n    selection_probs = harmonic_weights / np.sum(harmonic_weights)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment rotation with objective-aware replacement\n    if n > 5:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment if it improves both objectives\n        rotated_segment = np.roll(segment, 1)\n        rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost2 = sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(segment)-1))\n\n        if (rotated_cost1 < cost1 and rotated_cost2 < cost2) or \\\n           (rotated_cost1 < cost1 and np.random.random() < 0.3) or \\\n           (rotated_cost2 < cost2 and np.random.random() < 0.3):\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Objective-aware segment replacement\n        if n > 10 and np.random.random() < 0.7:\n            other_idx = np.random.choice(len(archive))\n            other_solution = archive[other_idx][0]\n            other_segment_start = np.random.randint(0, n - segment_length)\n            other_segment = other_solution[other_segment_start:other_segment_start+segment_length]\n\n            other_cost1 = sum(distance_matrix_1[other_segment[i], other_segment[i+1]] for i in range(len(segment)-1))\n            other_cost2 = sum(distance_matrix_2[other_segment[i], other_segment[i+1]] for i in range(len(segment)-1))\n\n            if (other_cost1 < cost1 and other_cost2 < cost2) or \\\n               (other_cost1 < cost1 and np.random.random() < 0.4) or \\\n               (other_cost2 < cost2 and np.random.random() < 0.4):\n                new_solution[start:start+segment_length] = other_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8239904352191229,
            0.07319021224975586
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"objective-aware segment insertion\" local search that intelligently reinserts segments of the tour into different positions while considering the trade-off between both objectives, ensuring feasibility and potentially improving both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment insertion\n    if n > 4:\n        # Select a segment to move\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment temporarily\n            temp_solution = np.insert(new_solution, pos, segment)\n\n            # Calculate new costs\n            new_cost1 = 0\n            new_cost2 = 0\n            for i in range(len(temp_solution)-1):\n                new_cost1 += distance_matrix_1[temp_solution[i], temp_solution[i+1]]\n                new_cost2 += distance_matrix_2[temp_solution[i], temp_solution[i+1]]\n\n            # Normalize and combine objectives\n            score = (new_cost1 - segment_cost1) + (new_cost2 - segment_cost2)\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8919004647674527,
            2.570391893386841
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment insertion\n    if n > 4:\n        # Select a segment to move\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment temporarily\n            temp_solution = np.insert(new_solution, pos, segment)\n\n            # Calculate new costs\n            new_cost1 = 0\n            new_cost2 = 0\n            for i in range(len(temp_solution)-1):\n                new_cost1 += distance_matrix_1[temp_solution[i], temp_solution[i+1]]\n                new_cost2 += distance_matrix_2[temp_solution[i], temp_solution[i+1]]\n\n            # Normalize and combine objectives\n            score = (new_cost1 - segment_cost1) + (new_cost2 - segment_cost2)\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and a novel diversity score, then applies a hybrid local search combining a \"node segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity score\n    def diversity_score(sol, ref_sol):\n        return np.sum(np.abs(sol - ref_sol)) / len(sol)\n\n    ref_solution = archive[0][0]\n    scored_archive = [(sol, obj, diversity_score(sol, ref_solution)) for sol, obj in archive]\n    scored_archive.sort(key=lambda x: (x[1][0] + x[1][1], -x[2]))\n    candidate_indices = min(5, len(scored_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = scored_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + cross-segment rotation\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-5 nodes and invert it\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, first_length)\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n",
        "score": [
            -0.9844915737009426,
            0.6236663460731506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity score\n    def diversity_score(sol, ref_sol):\n        return np.sum(np.abs(sol - ref_sol)) / len(sol)\n\n    ref_solution = archive[0][0]\n    scored_archive = [(sol, obj, diversity_score(sol, ref_solution)) for sol, obj in archive]\n    scored_archive.sort(key=lambda x: (x[1][0] + x[1][1], -x[2]))\n    candidate_indices = min(5, len(scored_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = scored_archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + cross-segment rotation\n    if n > 4:\n        # Node segment inversion: Select a segment of 2-5 nodes and invert it\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, first_length)\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.772339699677957,
            0.07346558570861816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objective improvement and high diversity\n    sorted_archive = sorted(archive, key=lambda x: (abs(x[1][0] - x[1][1]), x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment rotation and cross-segment insertion\n    if n > 4:\n        # Segment rotation: Rotate a segment by a random amount\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion: Insert a segment from one position to another\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            remove_start = np.random.randint(0, n - segment_length)\n            removed_segment = new_solution[remove_start:remove_start+segment_length]\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                removed_segment,\n                new_solution[insert_pos:]\n            ])\n            # Ensure no duplicates by removing excess nodes\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) < n:\n                missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n                new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.9249751912830915,
            0.1148638129234314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objective improvement and high diversity\n    sorted_archive = sorted(archive, key=lambda x: (abs(x[1][0] - x[1][1]), x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment rotation and cross-segment insertion\n    if n > 4:\n        # Segment rotation: Rotate a segment by a random amount\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotation = np.random.randint(1, segment_length)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion: Insert a segment from one position to another\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            remove_start = np.random.randint(0, n - segment_length)\n            removed_segment = new_solution[remove_start:remove_start+segment_length]\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                removed_segment,\n                new_solution[insert_pos:]\n            ])\n            # Ensure no duplicates by removing excess nodes\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) < n:\n                missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n                new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive cluster-based reordering\" with \"objective-aware segment inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive cluster-based reordering with objective-aware segment inversion\n    if n > 4:\n        # Cluster nodes based on their positions in both objective spaces\n        from sklearn.cluster import KMeans\n        coords = instance[new_solution, :2]  # Using first objective space coordinates\n        k = min(3, n // 4)\n        kmeans = KMeans(n_clusters=k, random_state=42).fit(coords)\n        clusters = kmeans.labels_\n\n        # Reorder nodes within clusters based on objective dominance\n        for cluster in range(k):\n            cluster_indices = np.where(clusters == cluster)[0]\n            if len(cluster_indices) > 1:\n                cluster_nodes = new_solution[cluster_indices]\n                # Calculate cluster cost in both objectives\n                cluster_cost1 = sum(distance_matrix_1[cluster_nodes[i], cluster_nodes[i+1]] for i in range(len(cluster_nodes)-1))\n                cluster_cost2 = sum(distance_matrix_2[cluster_nodes[i], cluster_nodes[i+1]] for i in range(len(cluster_nodes)-1))\n\n                # Invert cluster if it improves the weaker objective\n                if cluster_cost1 > cluster_cost2:\n                    new_solution[cluster_indices] = cluster_nodes[::-1]\n                else:\n                    # Reorder nodes in cluster based on objective dominance\n                    if cluster_cost1 > cluster_cost2:\n                        sorted_nodes = sorted(cluster_nodes, key=lambda x: instance[x, 0] + instance[x, 1])\n                    else:\n                        sorted_nodes = sorted(cluster_nodes, key=lambda x: instance[x, 2] + instance[x, 3])\n                    new_solution[cluster_indices] = sorted_nodes\n\n        # Objective-aware segment inversion\n        if n > 8:\n            segment_length = np.random.randint(3, min(6, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert segment if it improves the weaker objective\n            if segment_cost1 > segment_cost2:\n                new_solution[start:start+segment_length] = segment[::-1]\n            else:\n                # Reorder segment nodes based on objective dominance\n                if segment_cost1 > segment_cost2:\n                    sorted_segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n                else:\n                    sorted_segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n                new_solution[start:start+segment_length] = sorted_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9146622401992122,
            2.7649399638175964
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive cluster-based reordering with objective-aware segment inversion\n    if n > 4:\n        # Cluster nodes based on their positions in both objective spaces\n        from sklearn.cluster import KMeans\n        coords = instance[new_solution, :2]  # Using first objective space coordinates\n        k = min(3, n // 4)\n        kmeans = KMeans(n_clusters=k, random_state=42).fit(coords)\n        clusters = kmeans.labels_\n\n        # Reorder nodes within clusters based on objective dominance\n        for cluster in range(k):\n            cluster_indices = np.where(clusters == cluster)[0]\n            if len(cluster_indices) > 1:\n                cluster_nodes = new_solution[cluster_indices]\n                # Calculate cluster cost in both objectives\n                cluster_cost1 = sum(distance_matrix_1[cluster_nodes[i], cluster_nodes[i+1]] for i in range(len(cluster_nodes)-1))\n                cluster_cost2 = sum(distance_matrix_2[cluster_nodes[i], cluster_nodes[i+1]] for i in range(len(cluster_nodes)-1))\n\n                # Invert cluster if it improves the weaker objective\n                if cluster_cost1 > cluster_cost2:\n                    new_solution[cluster_indices] = cluster_nodes[::-1]\n                else:\n                    # Reorder nodes in cluster based on objective dominance\n                    if cluster_cost1 > cluster_cost2:\n                        sorted_nodes = sorted(cluster_nodes, key=lambda x: instance[x, 0] + instance[x, 1])\n                    else:\n                        sorted_nodes = sorted(cluster_nodes, key=lambda x: instance[x, 2] + instance[x, 3])\n                    new_solution[cluster_indices] = sorted_nodes\n\n        # Objective-aware segment inversion\n        if n > 8:\n            segment_length = np.random.randint(3, min(6, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            # Calculate segment costs in both objectives\n            segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert segment if it improves the weaker objective\n            if segment_cost1 > segment_cost2:\n                new_solution[start:start+segment_length] = segment[::-1]\n            else:\n                # Reorder segment nodes based on objective dominance\n                if segment_cost1 > segment_cost2:\n                    sorted_segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n                else:\n                    sorted_segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n                new_solution[start:start+segment_length] = sorted_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a hybrid local search combining a novel \"node chain inversion\" with a \"cross-chain relocation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion with cross-chain relocation\n    if n > 4:\n        # Node chain inversion\n        chain_length = np.random.randint(2, min(5, n))\n        chain_start = np.random.randint(0, n - chain_length)\n        chain = new_solution[chain_start:chain_start+chain_length]\n\n        # Calculate chain costs in both objectives\n        chain_cost1 = sum(distance_matrix_1[chain[i], chain[i+1]] for i in range(len(chain)-1))\n        chain_cost2 = sum(distance_matrix_2[chain[i], chain[i+1]] for i in range(len(chain)-1))\n\n        # Invert if it improves at least one objective\n        if chain_cost1 > distance_matrix_1[chain[-1], chain[0]]:\n            new_solution[chain_start:chain_start+chain_length] = chain[::-1]\n        elif chain_cost2 > distance_matrix_2[chain[-1], chain[0]]:\n            new_solution[chain_start:chain_start+chain_length] = chain[::-1]\n\n        # Cross-chain relocation with quality consideration\n        if n > 8:\n            first_pos = np.random.randint(0, n//2 - 1)\n            second_pos = np.random.randint(n//2, n - 1)\n\n            first_node = new_solution[first_pos]\n            second_node = new_solution[second_pos]\n\n            # Relocate nodes if it improves overall quality\n            if (distance_matrix_1[new_solution[first_pos-1], second_node] + distance_matrix_1[second_node, new_solution[first_pos+1]]) < \\\n               (distance_matrix_1[new_solution[first_pos-1], first_node] + distance_matrix_1[first_node, new_solution[first_pos+1]]):\n                new_solution[first_pos], new_solution[second_pos] = new_solution[second_pos], new_solution[first_pos]\n            elif (distance_matrix_2[new_solution[second_pos-1], first_node] + distance_matrix_2[first_node, new_solution[second_pos+1]]) < \\\n                 (distance_matrix_2[new_solution[second_pos-1], second_node] + distance_matrix_2[second_node, new_solution[second_pos+1]]):\n                new_solution[first_pos], new_solution[second_pos] = new_solution[second_pos], new_solution[first_pos]\n\n    return new_solution\n\n",
        "score": [
            -0.7687456705288123,
            0.28033554553985596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion with cross-chain relocation\n    if n > 4:\n        # Node chain inversion\n        chain_length = np.random.randint(2, min(5, n))\n        chain_start = np.random.randint(0, n - chain_length)\n        chain = new_solution[chain_start:chain_start+chain_length]\n\n        # Calculate chain costs in both objectives\n        chain_cost1 = sum(distance_matrix_1[chain[i], chain[i+1]] for i in range(len(chain)-1))\n        chain_cost2 = sum(distance_matrix_2[chain[i], chain[i+1]] for i in range(len(chain)-1))\n\n        # Invert if it improves at least one objective\n        if chain_cost1 > distance_matrix_1[chain[-1], chain[0]]:\n            new_solution[chain_start:chain_start+chain_length] = chain[::-1]\n        elif chain_cost2 > distance_matrix_2[chain[-1], chain[0]]:\n            new_solution[chain_start:chain_start+chain_length] = chain[::-1]\n\n        # Cross-chain relocation with quality consideration\n        if n > 8:\n            first_pos = np.random.randint(0, n//2 - 1)\n            second_pos = np.random.randint(n//2, n - 1)\n\n            first_node = new_solution[first_pos]\n            second_node = new_solution[second_pos]\n\n            # Relocate nodes if it improves overall quality\n            if (distance_matrix_1[new_solution[first_pos-1], second_node] + distance_matrix_1[second_node, new_solution[first_pos+1]]) < \\\n               (distance_matrix_1[new_solution[first_pos-1], first_node] + distance_matrix_1[first_node, new_solution[first_pos+1]]):\n                new_solution[first_pos], new_solution[second_pos] = new_solution[second_pos], new_solution[first_pos]\n            elif (distance_matrix_2[new_solution[second_pos-1], first_node] + distance_matrix_2[first_node, new_solution[second_pos+1]]) < \\\n                 (distance_matrix_2[new_solution[second_pos-1], second_node] + distance_matrix_2[second_node, new_solution[second_pos+1]]):\n                new_solution[first_pos], new_solution[second_pos] = new_solution[second_pos], new_solution[first_pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment rotation\" with \"objective-balanced segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    archive_with_diversity = [(sol, obj, len(set(sol))) for sol, obj in archive]\n    sorted_archive = sorted(archive_with_diversity, key=lambda x: (x[1][0] + x[1][1], -x[2]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment rotation\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment if it improves both objectives or one significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.1 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.1 * distance_matrix_2[segment[-1], segment[0]]):\n            rotation = np.random.randint(1, len(segment))\n            new_solution[start:start+segment_length] = np.roll(segment, rotation)\n\n    # Objective-balanced segment insertion\n    if n > 6:\n        # Select a segment from the first half and insert it into the second half\n        segment_length = np.random.randint(2, min(4, n//2))\n        first_start = np.random.randint(0, n//2 - segment_length)\n        second_start = np.random.randint(n//2, n - segment_length)\n\n        segment = new_solution[first_start:first_start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert if it improves the less improved objective\n        if segment_cost1 < segment_cost2:\n            # Insert in the first objective space\n            new_solution = np.concatenate([\n                new_solution[:second_start],\n                segment,\n                new_solution[second_start:first_start],\n                new_solution[first_start+segment_length:]\n            ])\n        else:\n            # Insert in the second objective space\n            new_solution = np.concatenate([\n                new_solution[:first_start],\n                new_solution[first_start+segment_length:second_start],\n                segment,\n                new_solution[second_start:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.7907262889867601,
            0.20489901304244995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    archive_with_diversity = [(sol, obj, len(set(sol))) for sol, obj in archive]\n    sorted_archive = sorted(archive_with_diversity, key=lambda x: (x[1][0] + x[1][1], -x[2]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment rotation\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Rotate segment if it improves both objectives or one significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.1 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.1 * distance_matrix_2[segment[-1], segment[0]]):\n            rotation = np.random.randint(1, len(segment))\n            new_solution[start:start+segment_length] = np.roll(segment, rotation)\n\n    # Objective-balanced segment insertion\n    if n > 6:\n        # Select a segment from the first half and insert it into the second half\n        segment_length = np.random.randint(2, min(4, n//2))\n        first_start = np.random.randint(0, n//2 - segment_length)\n        second_start = np.random.randint(n//2, n - segment_length)\n\n        segment = new_solution[first_start:first_start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert if it improves the less improved objective\n        if segment_cost1 < segment_cost2:\n            # Insert in the first objective space\n            new_solution = np.concatenate([\n                new_solution[:second_start],\n                segment,\n                new_solution[second_start:first_start],\n                new_solution[first_start+segment_length:]\n            ])\n        else:\n            # Insert in the second objective space\n            new_solution = np.concatenate([\n                new_solution[:first_start],\n                new_solution[first_start+segment_length:second_start],\n                segment,\n                new_solution[second_start:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective balance and solution quality, then applies a novel \"multi-objective path inversion with adaptive segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path inversion with adaptive segment rotation\n    if n > 4:\n        # Randomly select two segments to invert\n        segment_length = np.random.randint(2, min(5, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate original costs\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + \\\n                         sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + \\\n                         sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1))\n\n        # Invert segments\n        new_solution[start1:start1+segment_length] = new_solution[start1:start1+segment_length][::-1]\n        new_solution[start2:start2+segment_length] = new_solution[start2:start2+segment_length][::-1]\n\n        # Rotate segments if beneficial\n        if np.random.random() < 0.5:\n            rotation = np.random.randint(1, segment_length)\n            new_solution[start1:start1+segment_length] = np.roll(new_solution[start1:start1+segment_length], rotation)\n            new_solution[start2:start2+segment_length] = np.roll(new_solution[start2:start2+segment_length], rotation)\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + \\\n                    sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + \\\n                    sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1))\n\n        # Revert if no improvement in both objectives\n        if (new_cost1 >= original_cost1) and (new_cost2 >= original_cost2):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9342425037171204,
            1.0730603337287903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path inversion with adaptive segment rotation\n    if n > 4:\n        # Randomly select two segments to invert\n        segment_length = np.random.randint(2, min(5, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate original costs\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + \\\n                         sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + \\\n                         sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1))\n\n        # Invert segments\n        new_solution[start1:start1+segment_length] = new_solution[start1:start1+segment_length][::-1]\n        new_solution[start2:start2+segment_length] = new_solution[start2:start2+segment_length][::-1]\n\n        # Rotate segments if beneficial\n        if np.random.random() < 0.5:\n            rotation = np.random.randint(1, segment_length)\n            new_solution[start1:start1+segment_length] = np.roll(new_solution[start1:start1+segment_length], rotation)\n            new_solution[start2:start2+segment_length] = np.roll(new_solution[start2:start2+segment_length], rotation)\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + \\\n                    sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + \\\n                    sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1))\n\n        # Revert if no improvement in both objectives\n        if (new_cost1 >= original_cost1) and (new_cost2 >= original_cost2):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective path inversion with adaptive segment reversal\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) * abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path inversion\n    if n > 4:\n        # Select a random segment to invert\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, n)\n\n        # Calculate costs before inversion\n        original_segment = new_solution[start:end]\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, end))\n\n        # Invert the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Calculate costs after inversion\n        inverted_segment = new_solution[start:end]\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, end))\n\n        # Revert if inversion doesn't improve both objectives\n        if (new_cost1 >= original_cost1) and (new_cost2 >= original_cost2):\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive segment reversal\n    if n > 6:\n        for _ in range(3):\n            # Select two non-overlapping segments\n            seg1_start = np.random.randint(0, n//2 - 2)\n            seg1_length = np.random.randint(2, min(5, n//2 - seg1_start))\n            seg2_start = np.random.randint(n//2, n - seg1_length)\n            seg2_length = seg1_length\n\n            # Calculate costs before reversal\n            seg1 = new_solution[seg1_start:seg1_start+seg1_length]\n            seg2 = new_solution[seg2_start:seg2_start+seg2_length]\n            cost1_before = sum(distance_matrix_1[seg1[i-1], seg1[i]] for i in range(1, seg1_length)) + \\\n                          sum(distance_matrix_2[seg2[i-1], seg2[i]] for i in range(1, seg2_length))\n            cost2_before = sum(distance_matrix_2[seg1[i-1], seg1[i]] for i in range(1, seg1_length)) + \\\n                          sum(distance_matrix_1[seg2[i-1], seg2[i]] for i in range(1, seg2_length))\n\n            # Reverse segments\n            new_solution[seg1_start:seg1_start+seg1_length] = seg1[::-1]\n            new_solution[seg2_start:seg2_start+seg2_length] = seg2[::-1]\n\n            # Calculate costs after reversal\n            seg1_reversed = new_solution[seg1_start:seg1_start+seg1_length]\n            seg2_reversed = new_solution[seg2_start:seg2_start+seg2_length]\n            cost1_after = sum(distance_matrix_1[seg1_reversed[i-1], seg1_reversed[i]] for i in range(1, seg1_length)) + \\\n                         sum(distance_matrix_2[seg2_reversed[i-1], seg2_reversed[i]] for i in range(1, seg2_length))\n            cost2_after = sum(distance_matrix_2[seg1_reversed[i-1], seg1_reversed[i]] for i in range(1, seg1_length)) + \\\n                         sum(distance_matrix_1[seg2_reversed[i-1], seg2_reversed[i]] for i in range(1, seg2_length))\n\n            # Revert if reversal doesn't improve both objectives\n            if (cost1_after >= cost1_before) or (cost2_after >= cost2_before):\n                new_solution[seg1_start:seg1_start+seg1_length] = seg1\n                new_solution[seg2_start:seg2_start+seg2_length] = seg2\n\n    return new_solution\n\n",
        "score": [
            -0.9566771956882775,
            0.30831050872802734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) * abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path inversion\n    if n > 4:\n        # Select a random segment to invert\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, n)\n\n        # Calculate costs before inversion\n        original_segment = new_solution[start:end]\n        original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, end))\n\n        # Invert the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Calculate costs after inversion\n        inverted_segment = new_solution[start:end]\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(start, end))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(start, end))\n\n        # Revert if inversion doesn't improve both objectives\n        if (new_cost1 >= original_cost1) and (new_cost2 >= original_cost2):\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive segment reversal\n    if n > 6:\n        for _ in range(3):\n            # Select two non-overlapping segments\n            seg1_start = np.random.randint(0, n//2 - 2)\n            seg1_length = np.random.randint(2, min(5, n//2 - seg1_start))\n            seg2_start = np.random.randint(n//2, n - seg1_length)\n            seg2_length = seg1_length\n\n            # Calculate costs before reversal\n            seg1 = new_solution[seg1_start:seg1_start+seg1_length]\n            seg2 = new_solution[seg2_start:seg2_start+seg2_length]\n            cost1_before = sum(distance_matrix_1[seg1[i-1], seg1[i]] for i in range(1, seg1_length)) + \\\n                          sum(distance_matrix_2[seg2[i-1], seg2[i]] for i in range(1, seg2_length))\n            cost2_before = sum(distance_matrix_2[seg1[i-1], seg1[i]] for i in range(1, seg1_length)) + \\\n                          sum(distance_matrix_1[seg2[i-1], seg2[i]] for i in range(1, seg2_length))\n\n            # Reverse segments\n            new_solution[seg1_start:seg1_start+seg1_length] = seg1[::-1]\n            new_solution[seg2_start:seg2_start+seg2_length] = seg2[::-1]\n\n            # Calculate costs after reversal\n            seg1_reversed = new_solution[seg1_start:seg1_start+seg1_length]\n            seg2_reversed = new_solution[seg2_start:seg2_start+seg2_length]\n            cost1_after = sum(distance_matrix_1[seg1_reversed[i-1], seg1_reversed[i]] for i in range(1, seg1_length)) + \\\n                         sum(distance_matrix_2[seg2_reversed[i-1], seg2_reversed[i]] for i in range(1, seg2_length))\n            cost2_after = sum(distance_matrix_2[seg1_reversed[i-1], seg1_reversed[i]] for i in range(1, seg1_length)) + \\\n                         sum(distance_matrix_1[seg2_reversed[i-1], seg2_reversed[i]] for i in range(1, seg2_length))\n\n            # Revert if reversal doesn't improve both objectives\n            if (cost1_after >= cost1_before) or (cost2_after >= cost2_before):\n                new_solution[seg1_start:seg1_start+seg1_length] = seg1\n                new_solution[seg2_start:seg2_start+seg2_length] = seg2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8504797882940551,
            0.07321226596832275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining an \"adaptive node sequence inversion\" with \"objective-biased segment relocation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence inversion with objective-biased segment relocation\n    if n > 4:\n        # Adaptive node sequence inversion\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = segment[::-1]\n        else:\n            segment = sorted(segment, key=lambda x: (instance[x, 0] - instance[x, 2])**2 + (instance[x, 1] - instance[x, 3])**2)\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment relocation\n        if n > 8:\n            relocate_length = np.random.randint(2, min(5, n//2))\n            relocate_segment = new_solution[:relocate_length]\n\n            # Calculate relocation cost in both objectives\n            relocate_cost1 = sum(distance_matrix_1[relocate_segment[i], relocate_segment[i+1]] for i in range(len(relocate_segment)-1))\n            relocate_cost2 = sum(distance_matrix_2[relocate_segment[i], relocate_segment[i+1]] for i in range(len(relocate_segment)-1))\n\n            # Relocate segment to a position that improves the weaker objective\n            if relocate_cost1 > relocate_cost2:\n                relocate_pos = np.random.randint(relocate_length, n - relocate_length)\n                new_solution = np.concatenate([new_solution[relocate_length:relocate_pos], relocate_segment, new_solution[relocate_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                relocate_pos = np.random.randint(relocate_length, n - relocate_length)\n                new_solution = np.concatenate([new_solution[:relocate_pos], relocate_segment, new_solution[relocate_pos+relocate_length:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8468219261568564,
            0.10717594623565674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence inversion with objective-biased segment relocation\n    if n > 4:\n        # Adaptive node sequence inversion\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = segment[::-1]\n        else:\n            segment = sorted(segment, key=lambda x: (instance[x, 0] - instance[x, 2])**2 + (instance[x, 1] - instance[x, 3])**2)\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment relocation\n        if n > 8:\n            relocate_length = np.random.randint(2, min(5, n//2))\n            relocate_segment = new_solution[:relocate_length]\n\n            # Calculate relocation cost in both objectives\n            relocate_cost1 = sum(distance_matrix_1[relocate_segment[i], relocate_segment[i+1]] for i in range(len(relocate_segment)-1))\n            relocate_cost2 = sum(distance_matrix_2[relocate_segment[i], relocate_segment[i+1]] for i in range(len(relocate_segment)-1))\n\n            # Relocate segment to a position that improves the weaker objective\n            if relocate_cost1 > relocate_cost2:\n                relocate_pos = np.random.randint(relocate_length, n - relocate_length)\n                new_solution = np.concatenate([new_solution[relocate_length:relocate_pos], relocate_segment, new_solution[relocate_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                relocate_pos = np.random.randint(relocate_length, n - relocate_length)\n                new_solution = np.concatenate([new_solution[:relocate_pos], relocate_segment, new_solution[relocate_pos+relocate_length:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"cross-segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment inversion with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment insertion with diversity consideration\n        if n > 8:\n            insertion_point = np.random.randint(0, n)\n            segment_start = np.random.randint(0, n - segment_length)\n            segment = new_solution[segment_start:segment_start+segment_length]\n\n            # Insert segment at new position if it improves diversity\n            if insertion_point != segment_start:\n                new_segment = np.concatenate([\n                    new_solution[:insertion_point],\n                    segment,\n                    new_solution[insertion_point:segment_start],\n                    new_solution[segment_start+segment_length:]\n                ])\n                new_solution = new_segment\n\n    return new_solution\n\n",
        "score": [
            -0.824777366621869,
            0.12372422218322754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment inversion with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment insertion with diversity consideration\n        if n > 8:\n            insertion_point = np.random.randint(0, n)\n            segment_start = np.random.randint(0, n - segment_length)\n            segment = new_solution[segment_start:segment_start+segment_length]\n\n            # Insert segment at new position if it improves diversity\n            if insertion_point != segment_start:\n                new_segment = np.concatenate([\n                    new_solution[:insertion_point],\n                    segment,\n                    new_solution[insertion_point:segment_start],\n                    new_solution[segment_start+segment_length:]\n                ])\n                new_solution = new_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel \"multi-objective node insertion with adaptive segment reversal\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with diverse objectives and high quality\n    sorted_archive = sorted(archive, key=lambda x: (abs(x[1][0] - x[1][1]), x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective node insertion\n    if n > 4:\n        node_to_insert = np.random.choice(new_solution[2:-2])\n        pos = np.random.randint(1, n-1)\n        original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[node_to_insert, new_solution[pos]]\n        original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[node_to_insert, new_solution[pos]]\n\n        # Remove node and insert at new position\n        node_index = np.where(new_solution == node_to_insert)[0][0]\n        new_solution = np.delete(new_solution, node_index)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n        new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            # Revert if not improving both objectives\n            new_solution = np.delete(new_solution, pos)\n            new_solution = np.insert(new_solution, node_index, node_to_insert)\n\n    # Adaptive segment reversal\n    if n > 6:\n        segment_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_length)\n\n        original_segment = new_solution[start:start+segment_length]\n        original_cost1 = sum(distance_matrix_1[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n        original_cost2 = sum(distance_matrix_2[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n\n        # Reverse the segment\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        reversed_segment = new_solution[start:start+segment_length]\n        new_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        new_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            # Revert if not improving both objectives\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6777765652671628,
            1.3179139494895935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with diverse objectives and high quality\n    sorted_archive = sorted(archive, key=lambda x: (abs(x[1][0] - x[1][1]), x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective node insertion\n    if n > 4:\n        node_to_insert = np.random.choice(new_solution[2:-2])\n        pos = np.random.randint(1, n-1)\n        original_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[node_to_insert, new_solution[pos]]\n        original_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[node_to_insert, new_solution[pos]]\n\n        # Remove node and insert at new position\n        node_index = np.where(new_solution == node_to_insert)[0][0]\n        new_solution = np.delete(new_solution, node_index)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n        new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[pos+1]]\n        new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[pos+1]]\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            # Revert if not improving both objectives\n            new_solution = np.delete(new_solution, pos)\n            new_solution = np.insert(new_solution, node_index, node_to_insert)\n\n    # Adaptive segment reversal\n    if n > 6:\n        segment_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_length)\n\n        original_segment = new_solution[start:start+segment_length]\n        original_cost1 = sum(distance_matrix_1[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n        original_cost2 = sum(distance_matrix_2[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n\n        # Reverse the segment\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        reversed_segment = new_solution[start:start+segment_length]\n        new_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n        new_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[i+1]] for i in range(len(reversed_segment)-1))\n\n        if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n            # Revert if not improving both objectives\n            new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8614124200751112,
            0.12811821699142456
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"multi-segment rotation\" with an \"objective-aware insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment rotation + objective-aware insertion\n    if n > 6:\n        # Multi-segment rotation: Rotate 2-4 segments of the tour\n        num_segments = np.random.randint(2, min(5, n // 3))\n        segment_lengths = np.random.randint(2, min(6, n // num_segments), size=num_segments)\n        segment_starts = np.sort(np.random.choice(n - sum(segment_lengths) + 1, num_segments, replace=False))\n\n        # Rotate segments in a circular fashion\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n            rotated_segment = np.roll(segment, np.random.randint(1, length))\n            new_solution[start:start+length] = rotated_segment\n\n        # Objective-aware insertion: Insert nodes that improve at least one objective\n        if n > 8:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                node_i = new_solution[i]\n                node_j = new_solution[j]\n\n                # Calculate potential insertion costs\n                prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_i = new_solution[(i+1) % n]\n\n                prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n                next_j = new_solution[(j+1) % n]\n\n                cost1_before = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n                cost2_before = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n                cost1_after = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] + distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]\n                cost2_after = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] + distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]\n\n                # Insert if it improves at least one objective\n                if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9168034636479114,
            0.26284873485565186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment rotation + objective-aware insertion\n    if n > 6:\n        # Multi-segment rotation: Rotate 2-4 segments of the tour\n        num_segments = np.random.randint(2, min(5, n // 3))\n        segment_lengths = np.random.randint(2, min(6, n // num_segments), size=num_segments)\n        segment_starts = np.sort(np.random.choice(n - sum(segment_lengths) + 1, num_segments, replace=False))\n\n        # Rotate segments in a circular fashion\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n            rotated_segment = np.roll(segment, np.random.randint(1, length))\n            new_solution[start:start+length] = rotated_segment\n\n        # Objective-aware insertion: Insert nodes that improve at least one objective\n        if n > 8:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                node_i = new_solution[i]\n                node_j = new_solution[j]\n\n                # Calculate potential insertion costs\n                prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_i = new_solution[(i+1) % n]\n\n                prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n                next_j = new_solution[(j+1) % n]\n\n                cost1_before = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] + distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j]\n                cost2_before = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] + distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j]\n\n                cost1_after = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] + distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j]\n                cost2_after = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] + distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j]\n\n                # Insert if it improves at least one objective\n                if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a hybrid local search combining a \"multi-segment inversion\" with an \"objective-aware segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and diversity\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    scores = [weights[i] * (archive[i][1][0] + archive[i][1][1]) + (1 - weights[i]) * (np.std(archive[i][0]) + np.mean(archive[i][0])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion with objective-aware segment insertion\n    if n > 5:\n        # Multi-segment inversion\n        num_segments = np.random.randint(2, min(4, n // 3))\n        segment_lengths = np.random.randint(2, min(5, n // num_segments), size=num_segments)\n        starts = np.random.choice(np.arange(n - sum(segment_lengths)), size=num_segments, replace=False)\n\n        for i in range(num_segments):\n            start = starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n\n            # Calculate segment costs\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert if it improves at least one objective\n            if cost1 > distance_matrix_1[segment[-1], segment[0]] or cost2 > distance_matrix_2[segment[-1], segment[0]]:\n                new_solution[start:start+length] = segment[::-1]\n\n        # Objective-aware segment insertion\n        if n > 10:\n            segment_length = np.random.randint(3, min(7, n // 2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            # Find insertion point that minimizes both objectives\n            best_pos = start\n            best_cost = float('inf')\n\n            for pos in range(n - segment_length + 1):\n                if pos != start:\n                    # Calculate cost of inserting segment at this position\n                    cost = 0\n                    if pos > 0:\n                        cost += distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_2[new_solution[pos-1], segment[0]]\n                    if pos + segment_length < n:\n                        cost += distance_matrix_1[segment[-1], new_solution[pos+segment_length]] + distance_matrix_2[segment[-1], new_solution[pos+segment_length]]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            # Insert segment at best position\n            if best_pos != start:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[start:start+segment_length],\n                    new_solution[best_pos+segment_length:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.9025827316086941,
            2.4863070845603943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objectives and diversity\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    scores = [weights[i] * (archive[i][1][0] + archive[i][1][1]) + (1 - weights[i]) * (np.std(archive[i][0]) + np.mean(archive[i][0])) for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion with objective-aware segment insertion\n    if n > 5:\n        # Multi-segment inversion\n        num_segments = np.random.randint(2, min(4, n // 3))\n        segment_lengths = np.random.randint(2, min(5, n // num_segments), size=num_segments)\n        starts = np.random.choice(np.arange(n - sum(segment_lengths)), size=num_segments, replace=False)\n\n        for i in range(num_segments):\n            start = starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n\n            # Calculate segment costs\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Invert if it improves at least one objective\n            if cost1 > distance_matrix_1[segment[-1], segment[0]] or cost2 > distance_matrix_2[segment[-1], segment[0]]:\n                new_solution[start:start+length] = segment[::-1]\n\n        # Objective-aware segment insertion\n        if n > 10:\n            segment_length = np.random.randint(3, min(7, n // 2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n\n            # Find insertion point that minimizes both objectives\n            best_pos = start\n            best_cost = float('inf')\n\n            for pos in range(n - segment_length + 1):\n                if pos != start:\n                    # Calculate cost of inserting segment at this position\n                    cost = 0\n                    if pos > 0:\n                        cost += distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_2[new_solution[pos-1], segment[0]]\n                    if pos + segment_length < n:\n                        cost += distance_matrix_1[segment[-1], new_solution[pos+segment_length]] + distance_matrix_2[segment[-1], new_solution[pos+segment_length]]\n\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_pos = pos\n\n            # Insert segment at best position\n            if best_pos != start:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[start:start+segment_length],\n                    new_solution[best_pos+segment_length:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9325762243808133,
            0.1323087215423584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a \"multi-objective segment inversion\" with \"adaptive node relocation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: (abs(x[1][0] - x[1][1]), np.random.random()))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_length)\n\n        # Calculate segment cost before inversion\n        original_segment = new_solution[start:start+segment_length]\n        cost1_before = sum(distance_matrix_1[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n        cost2_before = sum(distance_matrix_2[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n\n        # Perform inversion\n        new_solution[start:start+segment_length] = original_segment[::-1]\n\n        # Calculate segment cost after inversion\n        inverted_segment = new_solution[start:start+segment_length]\n        cost1_after = sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n        cost2_after = sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n\n        # Revert if inversion doesn't improve both objectives\n        if (cost1_after >= cost1_before) or (cost2_after >= cost2_before):\n            new_solution[start:start+segment_length] = original_segment\n\n    # Adaptive node relocation\n    if n > 6:\n        for _ in range(3):\n            i = np.random.randint(1, n-1)\n            j = np.random.randint(1, n-1)\n            if i != j and abs(i-j) > 1:\n                # Calculate costs before relocation\n                original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                                distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                                distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n                original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                                distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                                distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n                # Perform relocation\n                node_to_move = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n                # Calculate costs after relocation\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n                # Revert if relocation doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    node_to_move = new_solution[j]\n                    new_solution = np.concatenate([new_solution[:i], [node_to_move], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8464960798371493,
            0.22549927234649658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with high diversity and balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: (abs(x[1][0] - x[1][1]), np.random.random()))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_length)\n\n        # Calculate segment cost before inversion\n        original_segment = new_solution[start:start+segment_length]\n        cost1_before = sum(distance_matrix_1[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n        cost2_before = sum(distance_matrix_2[original_segment[i], original_segment[i+1]] for i in range(len(original_segment)-1))\n\n        # Perform inversion\n        new_solution[start:start+segment_length] = original_segment[::-1]\n\n        # Calculate segment cost after inversion\n        inverted_segment = new_solution[start:start+segment_length]\n        cost1_after = sum(distance_matrix_1[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n        cost2_after = sum(distance_matrix_2[inverted_segment[i], inverted_segment[i+1]] for i in range(len(inverted_segment)-1))\n\n        # Revert if inversion doesn't improve both objectives\n        if (cost1_after >= cost1_before) or (cost2_after >= cost2_before):\n            new_solution[start:start+segment_length] = original_segment\n\n    # Adaptive node relocation\n    if n > 6:\n        for _ in range(3):\n            i = np.random.randint(1, n-1)\n            j = np.random.randint(1, n-1)\n            if i != j and abs(i-j) > 1:\n                # Calculate costs before relocation\n                original_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                                distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                                distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n                original_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                                distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                                distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n                # Perform relocation\n                node_to_move = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n                # Calculate costs after relocation\n                new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n                new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n                # Revert if relocation doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    node_to_move = new_solution[j]\n                    new_solution = np.concatenate([new_solution[:i], [node_to_move], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel \"adaptive segment inversion and cross-segment merge\" strategy that dynamically balances local and global perturbations to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))  # Top 5 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion and cross-segment merge\n    if n > 4:\n        # Adaptive segment inversion\n        segment_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]  # Invert segment\n\n        # Cross-segment merge\n        if n > 8:\n            split_point = np.random.randint(4, n-4)\n            first_part = new_solution[:split_point]\n            second_part = new_solution[split_point:]\n\n            # Merge with different starting points\n            merge_offset = np.random.randint(1, min(4, len(second_part)))\n            merged = np.concatenate([second_part[merge_offset:], first_part, second_part[:merge_offset]])\n            new_solution = merged\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8490325680204929,
            0.23627781867980957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))  # Top 5 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion and cross-segment merge\n    if n > 4:\n        # Adaptive segment inversion\n        segment_length = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution[start:start+segment_length] = segment[::-1]  # Invert segment\n\n        # Cross-segment merge\n        if n > 8:\n            split_point = np.random.randint(4, n-4)\n            first_part = new_solution[:split_point]\n            second_part = new_solution[split_point:]\n\n            # Merge with different starting points\n            merge_offset = np.random.randint(1, min(4, len(second_part)))\n            merged = np.concatenate([second_part[merge_offset:], first_part, second_part[:merge_offset]])\n            new_solution = merged\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"adaptive segment insertion\" with \"objective-aware segment relocation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with objective-aware segment relocation\n    if n > 4:\n        # Select a random segment to remove\n        segment_length = np.random.randint(2, min(5, n // 2))\n        remove_start = np.random.randint(0, n - segment_length)\n        removed_segment = new_solution[remove_start:remove_start + segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([\n            new_solution[:remove_start],\n            new_solution[remove_start + segment_length:]\n        ])\n\n        # Calculate insertion positions and their costs\n        insertion_positions = []\n        for pos in range(len(new_solution) - segment_length + 1):\n            # Insert the segment at position pos\n            candidate = np.concatenate([\n                new_solution[:pos],\n                removed_segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate the cost of the new solution\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            insertion_positions.append((pos, cost1, cost2))\n\n        # Select the best insertion position that improves at least one objective\n        best_pos = None\n        best_cost1, best_cost2 = float('inf'), float('inf')\n\n        for pos, cost1, cost2 in insertion_positions:\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost2 < best_cost2 and cost1 <= best_cost1):\n                best_pos = pos\n                best_cost1, best_cost2 = cost1, cost2\n\n        if best_pos is not None:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                removed_segment,\n                new_solution[best_pos:]\n            ])\n\n        # Objective-aware segment relocation\n        if n > 8:\n            # Select a segment to relocate\n            relocate_length = np.random.randint(2, min(5, n // 3))\n            relocate_start = np.random.randint(0, n - relocate_length)\n            relocate_segment = new_solution[relocate_start:relocate_start + relocate_length]\n\n            # Remove the segment\n            new_solution = np.concatenate([\n                new_solution[:relocate_start],\n                new_solution[relocate_start + relocate_length:]\n            ])\n\n            # Calculate relocation positions and their costs\n            relocation_positions = []\n            for pos in range(len(new_solution) - relocate_length + 1):\n                # Relocate the segment to position pos\n                candidate = np.concatenate([\n                    new_solution[:pos],\n                    relocate_segment,\n                    new_solution[pos:]\n                ])\n\n                # Calculate the cost of the new solution\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n                relocation_positions.append((pos, cost1, cost2))\n\n            # Select the best relocation position that improves at least one objective\n            best_relocate_pos = None\n            best_relocate_cost1, best_relocate_cost2 = float('inf'), float('inf')\n\n            for pos, cost1, cost2 in relocation_positions:\n                if (cost1 < best_relocate_cost1 and cost2 <= best_relocate_cost2) or (cost2 < best_relocate_cost2 and cost1 <= best_relocate_cost1):\n                    best_relocate_pos = pos\n                    best_relocate_cost1, best_relocate_cost2 = cost1, cost2\n\n            if best_relocate_pos is not None:\n                new_solution = np.concatenate([\n                    new_solution[:best_relocate_pos],\n                    relocate_segment,\n                    new_solution[best_relocate_pos:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.7661413281001219,
            1.4795445203781128
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion with objective-aware segment relocation\n    if n > 4:\n        # Select a random segment to remove\n        segment_length = np.random.randint(2, min(5, n // 2))\n        remove_start = np.random.randint(0, n - segment_length)\n        removed_segment = new_solution[remove_start:remove_start + segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([\n            new_solution[:remove_start],\n            new_solution[remove_start + segment_length:]\n        ])\n\n        # Calculate insertion positions and their costs\n        insertion_positions = []\n        for pos in range(len(new_solution) - segment_length + 1):\n            # Insert the segment at position pos\n            candidate = np.concatenate([\n                new_solution[:pos],\n                removed_segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate the cost of the new solution\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            insertion_positions.append((pos, cost1, cost2))\n\n        # Select the best insertion position that improves at least one objective\n        best_pos = None\n        best_cost1, best_cost2 = float('inf'), float('inf')\n\n        for pos, cost1, cost2 in insertion_positions:\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost2 < best_cost2 and cost1 <= best_cost1):\n                best_pos = pos\n                best_cost1, best_cost2 = cost1, cost2\n\n        if best_pos is not None:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                removed_segment,\n                new_solution[best_pos:]\n            ])\n\n        # Objective-aware segment relocation\n        if n > 8:\n            # Select a segment to relocate\n            relocate_length = np.random.randint(2, min(5, n // 3))\n            relocate_start = np.random.randint(0, n - relocate_length)\n            relocate_segment = new_solution[relocate_start:relocate_start + relocate_length]\n\n            # Remove the segment\n            new_solution = np.concatenate([\n                new_solution[:relocate_start],\n                new_solution[relocate_start + relocate_length:]\n            ])\n\n            # Calculate relocation positions and their costs\n            relocation_positions = []\n            for pos in range(len(new_solution) - relocate_length + 1):\n                # Relocate the segment to position pos\n                candidate = np.concatenate([\n                    new_solution[:pos],\n                    relocate_segment,\n                    new_solution[pos:]\n                ])\n\n                # Calculate the cost of the new solution\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n                relocation_positions.append((pos, cost1, cost2))\n\n            # Select the best relocation position that improves at least one objective\n            best_relocate_pos = None\n            best_relocate_cost1, best_relocate_cost2 = float('inf'), float('inf')\n\n            for pos, cost1, cost2 in relocation_positions:\n                if (cost1 < best_relocate_cost1 and cost2 <= best_relocate_cost2) or (cost2 < best_relocate_cost2 and cost1 <= best_relocate_cost1):\n                    best_relocate_pos = pos\n                    best_relocate_cost1, best_relocate_cost2 = cost1, cost2\n\n            if best_relocate_pos is not None:\n                new_solution = np.concatenate([\n                    new_solution[:best_relocate_pos],\n                    relocate_segment,\n                    new_solution[best_relocate_pos:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel \"adaptive segment insertion\" hybrid local search operator that combines segment relocations with a \"multi-objective segment crossover\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    archive_with_quality = []\n    for sol, obj in archive:\n        total_cost = obj[0] + obj[1]\n        normalized_cost = total_cost / (len(sol) * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)) / 2)\n        archive_with_quality.append((sol, obj, normalized_cost))\n\n    sorted_archive = sorted(archive_with_quality, key=lambda x: x[2])\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion with multi-objective segment crossover\n    if n > 6:\n        # Adaptive segment insertion\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Remove segment and insert elsewhere\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Multi-objective segment crossover\n        if n > 10:\n            crossover_point = np.random.randint(1, n-1)\n            first_half = new_solution[:crossover_point]\n            second_half = new_solution[crossover_point:]\n\n            # Calculate crossover costs\n            first_cost1 = sum(distance_matrix_1[first_half[i], first_half[i+1]] for i in range(len(first_half)-1))\n            first_cost2 = sum(distance_matrix_2[first_half[i], first_half[i+1]] for i in range(len(first_half)-1))\n            second_cost1 = sum(distance_matrix_1[second_half[i], second_half[i+1]] for i in range(len(second_half)-1))\n            second_cost2 = sum(distance_matrix_2[second_half[i], second_half[i+1]] for i in range(len(second_half)-1))\n\n            # Swap segments if it improves at least one objective\n            if (first_cost1 + second_cost1) > (first_cost2 + second_cost2):\n                new_solution = np.concatenate([second_half, first_half])\n\n    return new_solution\n\n",
        "score": [
            -0.9247608275651902,
            0.5372278690338135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and solution quality\n    archive_with_quality = []\n    for sol, obj in archive:\n        total_cost = obj[0] + obj[1]\n        normalized_cost = total_cost / (len(sol) * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)) / 2)\n        archive_with_quality.append((sol, obj, normalized_cost))\n\n    sorted_archive = sorted(archive_with_quality, key=lambda x: x[2])\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion with multi-objective segment crossover\n    if n > 6:\n        # Adaptive segment insertion\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Remove segment and insert elsewhere\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Multi-objective segment crossover\n        if n > 10:\n            crossover_point = np.random.randint(1, n-1)\n            first_half = new_solution[:crossover_point]\n            second_half = new_solution[crossover_point:]\n\n            # Calculate crossover costs\n            first_cost1 = sum(distance_matrix_1[first_half[i], first_half[i+1]] for i in range(len(first_half)-1))\n            first_cost2 = sum(distance_matrix_2[first_half[i], first_half[i+1]] for i in range(len(first_half)-1))\n            second_cost1 = sum(distance_matrix_1[second_half[i], second_half[i+1]] for i in range(len(second_half)-1))\n            second_cost2 = sum(distance_matrix_2[second_half[i], second_half[i+1]] for i in range(len(second_half)-1))\n\n            # Swap segments if it improves at least one objective\n            if (first_cost1 + second_cost1) > (first_cost2 + second_cost2):\n                new_solution = np.concatenate([second_half, first_half])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment rotation\" with an \"objective-aware segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objective values and diversity\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.array([obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive])\n    diversity_scores = np.array([len(set(sol)) / len(sol) for sol, _ in archive])\n    combined_scores = scores * 0.7 + diversity_scores * 0.3\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment rotation with objective-aware insertion\n    if n > 4:\n        # Segment rotation\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, shift=1)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Objective-aware segment insertion\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            if insert_pos >= start and insert_pos < start + segment_length:\n                insert_pos = (start + segment_length) % n\n\n            # Calculate costs before and after insertion\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1))\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1))\n\n            # Create temporary solution with insertion\n            temp_solution = np.insert(new_solution, insert_pos, segment)\n            if len(temp_solution) > n:\n                temp_solution = temp_solution[:n]\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1))\n\n            # Accept if at least one objective improves\n            if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8839434033089817,
            0.26158738136291504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted combination of objective values and diversity\n    weights = np.array([0.6, 0.4])  # Higher weight for first objective\n    scores = np.array([obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive])\n    diversity_scores = np.array([len(set(sol)) / len(sol) for sol, _ in archive])\n    combined_scores = scores * 0.7 + diversity_scores * 0.3\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment rotation with objective-aware insertion\n    if n > 4:\n        # Segment rotation\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, shift=1)\n        new_solution[start:start+segment_length] = rotated_segment\n\n        # Objective-aware segment insertion\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            if insert_pos >= start and insert_pos < start + segment_length:\n                insert_pos = (start + segment_length) % n\n\n            # Calculate costs before and after insertion\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1))\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1))\n\n            # Create temporary solution with insertion\n            temp_solution = np.insert(new_solution, insert_pos, segment)\n            if len(temp_solution) > n:\n                temp_solution = temp_solution[:n]\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1))\n\n            # Accept if at least one objective improves\n            if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment insertion\" with \"objective-aware segment relocation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion with objective-aware segment relocation\n    if n > 4:\n        # Objective-aware segment relocation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.delete(new_solution, np.s_[start:start+segment_length])\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert segment at a new position based on objective improvement\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution) - segment_length + 1):\n            temp_solution = np.insert(new_solution, pos, segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1))\n\n            if (cost1 + cost2) < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8425897204583146,
            1.7197867035865784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment insertion with objective-aware segment relocation\n    if n > 4:\n        # Objective-aware segment relocation\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.delete(new_solution, np.s_[start:start+segment_length])\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Insert segment at a new position based on objective improvement\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution) - segment_length + 1):\n            temp_solution = np.insert(new_solution, pos, segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(len(temp_solution)-1))\n\n            if (cost1 + cost2) < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"objective-balanced node clustering\" with \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-balanced node clustering with cross-segment rotation\n    if n > 5:\n        # Cluster nodes based on objective-balanced coordinates\n        cluster_size = np.random.randint(2, min(6, n//2))\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Calculate cluster costs in both objectives\n        cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n        cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n\n        # Rotate cluster nodes based on objective balance\n        if cluster_cost1 > cluster_cost2:\n            rotation = np.random.randint(1, len(cluster))\n            cluster = np.roll(cluster, rotation)\n        else:\n            rotation = np.random.randint(1, len(cluster))\n            cluster = np.roll(cluster, -rotation)\n\n        new_solution[cluster_start:cluster_start+cluster_size] = cluster\n\n        # Cross-segment rotation for diversity\n        if n > 10:\n            segment_length = np.random.randint(2, min(5, n//3))\n            first_start = np.random.randint(0, n//2 - segment_length)\n            second_start = np.random.randint(n//2, n - segment_length)\n\n            first_segment = new_solution[first_start:first_start+segment_length]\n            second_segment = new_solution[second_start:second_start+segment_length]\n\n            # Rotate segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                rotation = np.random.randint(1, len(first_segment))\n                first_segment = np.roll(first_segment, rotation)\n                new_solution[first_start:first_start+segment_length] = first_segment\n            else:\n                rotation = np.random.randint(1, len(second_segment))\n                second_segment = np.roll(second_segment, -rotation)\n                new_solution[second_start:second_start+segment_length] = second_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9370292681753509,
            0.26988792419433594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-balanced node clustering with cross-segment rotation\n    if n > 5:\n        # Cluster nodes based on objective-balanced coordinates\n        cluster_size = np.random.randint(2, min(6, n//2))\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster = new_solution[cluster_start:cluster_start+cluster_size]\n\n        # Calculate cluster costs in both objectives\n        cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n        cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[i+1]] for i in range(len(cluster)-1))\n\n        # Rotate cluster nodes based on objective balance\n        if cluster_cost1 > cluster_cost2:\n            rotation = np.random.randint(1, len(cluster))\n            cluster = np.roll(cluster, rotation)\n        else:\n            rotation = np.random.randint(1, len(cluster))\n            cluster = np.roll(cluster, -rotation)\n\n        new_solution[cluster_start:cluster_start+cluster_size] = cluster\n\n        # Cross-segment rotation for diversity\n        if n > 10:\n            segment_length = np.random.randint(2, min(5, n//3))\n            first_start = np.random.randint(0, n//2 - segment_length)\n            second_start = np.random.randint(n//2, n - segment_length)\n\n            first_segment = new_solution[first_start:first_start+segment_length]\n            second_segment = new_solution[second_start:second_start+segment_length]\n\n            # Rotate segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                rotation = np.random.randint(1, len(first_segment))\n                first_segment = np.roll(first_segment, rotation)\n                new_solution[first_start:first_start+segment_length] = first_segment\n            else:\n                rotation = np.random.randint(1, len(second_segment))\n                second_segment = np.roll(second_segment, -rotation)\n                new_solution[second_start:second_start+segment_length] = second_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"multi-objective path decomposition\" with \"adaptive segment inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-objective path decomposition with adaptive segment inversion\n    if n > 4:\n        # Path decomposition into segments based on objective dominance\n        segment_length = np.random.randint(2, min(6, n))\n        segments = []\n        for i in range(0, n, segment_length):\n            segment = new_solution[i:i+segment_length]\n            if len(segment) > 1:\n                segments.append(segment)\n\n        # Calculate segment costs in both objectives\n        segment_costs = []\n        for segment in segments:\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_costs.append((cost1, cost2))\n\n        # Adaptive segment inversion based on objective balance\n        for i, segment in enumerate(segments):\n            cost1, cost2 = segment_costs[i]\n            if abs(cost1 - cost2) > 0.1 * (cost1 + cost2):  # Significant imbalance\n                if cost1 > cost2:\n                    # Invert segment to balance objectives\n                    segments[i] = segment[::-1]\n\n        # Reconstruct solution from modified segments\n        new_solution = np.concatenate(segments)\n\n        # Cross-segment optimization with diversity consideration\n        if n > 8:\n            swap_pos1 = np.random.randint(0, n//2)\n            swap_pos2 = np.random.randint(n//2, n)\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.8040607304162375,
            0.26693862676620483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-objective path decomposition with adaptive segment inversion\n    if n > 4:\n        # Path decomposition into segments based on objective dominance\n        segment_length = np.random.randint(2, min(6, n))\n        segments = []\n        for i in range(0, n, segment_length):\n            segment = new_solution[i:i+segment_length]\n            if len(segment) > 1:\n                segments.append(segment)\n\n        # Calculate segment costs in both objectives\n        segment_costs = []\n        for segment in segments:\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_costs.append((cost1, cost2))\n\n        # Adaptive segment inversion based on objective balance\n        for i, segment in enumerate(segments):\n            cost1, cost2 = segment_costs[i]\n            if abs(cost1 - cost2) > 0.1 * (cost1 + cost2):  # Significant imbalance\n                if cost1 > cost2:\n                    # Invert segment to balance objectives\n                    segments[i] = segment[::-1]\n\n        # Reconstruct solution from modified segments\n        new_solution = np.concatenate(segments)\n\n        # Cross-segment optimization with diversity consideration\n        if n > 8:\n            swap_pos1 = np.random.randint(0, n//2)\n            swap_pos2 = np.random.randint(n//2, n)\n            new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment rotation\" with a \"cross-segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced improvement potential\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment rotation with objective-aware insertion\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment if it improves at least one objective\n        rotated_segment = np.roll(segment, 1)\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost2 = sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n\n        if (rotated_cost1 < original_cost1) or (rotated_cost2 < original_cost2):\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion with diversity consideration\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            segment_pos = np.random.randint(0, n - segment_length)\n            segment_to_insert = new_solution[segment_pos:segment_pos+segment_length]\n\n            # Insert segment if it improves diversity\n            if len(set(new_solution[:insert_pos])) < len(set(new_solution[insert_pos:])):\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment_to_insert,\n                    new_solution[insert_pos:]\n                ])\n                new_solution = np.unique(new_solution, return_index=True)[1]\n                new_solution = np.concatenate([new_solution, new_solution[:n-len(new_solution)]])\n\n    return new_solution\n\n",
        "score": [
            -0.8007253121195609,
            0.32602471113204956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced improvement potential\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment rotation with objective-aware insertion\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Rotate segment if it improves at least one objective\n        rotated_segment = np.roll(segment, 1)\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost1 = sum(distance_matrix_1[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        rotated_cost2 = sum(distance_matrix_2[rotated_segment[i], rotated_segment[i+1]] for i in range(len(rotated_segment)-1))\n\n        if (rotated_cost1 < original_cost1) or (rotated_cost2 < original_cost2):\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Cross-segment insertion with diversity consideration\n        if n > 8:\n            insert_pos = np.random.randint(0, n)\n            segment_pos = np.random.randint(0, n - segment_length)\n            segment_to_insert = new_solution[segment_pos:segment_pos+segment_length]\n\n            # Insert segment if it improves diversity\n            if len(set(new_solution[:insert_pos])) < len(set(new_solution[insert_pos:])):\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment_to_insert,\n                    new_solution[insert_pos:]\n                ])\n                new_solution = np.unique(new_solution, return_index=True)[1]\n                new_solution = np.concatenate([new_solution, new_solution[:n-len(new_solution)]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with an \"objective-aware segment exchange\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment inversion with segment exchange\n    if n > 6:\n        # Segment inversion with objective-aware selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Objective-aware segment exchange\n        if n > 10:\n            exchange_length = np.random.randint(2, min(5, n//2))\n            exchange_pos1 = np.random.randint(0, n - exchange_length)\n            exchange_pos2 = np.random.randint(0, n - exchange_length)\n\n            segment1 = new_solution[exchange_pos1:exchange_pos1+exchange_length]\n            segment2 = new_solution[exchange_pos2:exchange_pos2+exchange_length]\n\n            # Calculate exchange costs\n            cost1_before = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(exchange_pos1, exchange_pos1+exchange_length)) + \\\n                           sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(exchange_pos2, exchange_pos2+exchange_length))\n            cost2_before = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(exchange_pos1, exchange_pos1+exchange_length)) + \\\n                           sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(exchange_pos2, exchange_pos2+exchange_length))\n\n            # Exchange segments\n            new_solution[exchange_pos1:exchange_pos1+exchange_length] = segment2\n            new_solution[exchange_pos2:exchange_pos2+exchange_length] = segment1\n\n            cost1_after = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(exchange_pos1, exchange_pos1+exchange_length)) + \\\n                          sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(exchange_pos2, exchange_pos2+exchange_length))\n            cost2_after = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(exchange_pos1, exchange_pos1+exchange_length)) + \\\n                          sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(exchange_pos2, exchange_pos2+exchange_length))\n\n            # Revert if no improvement in either objective\n            if (cost1_after >= cost1_before and cost2_after >= cost2_before):\n                new_solution[exchange_pos1:exchange_pos1+exchange_length] = segment1\n                new_solution[exchange_pos2:exchange_pos2+exchange_length] = segment2\n\n    return new_solution\n\n",
        "score": [
            -0.981638050386983,
            0.08767056465148926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware segment inversion with segment exchange\n    if n > 6:\n        # Segment inversion with objective-aware selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Invert segment if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Objective-aware segment exchange\n        if n > 10:\n            exchange_length = np.random.randint(2, min(5, n//2))\n            exchange_pos1 = np.random.randint(0, n - exchange_length)\n            exchange_pos2 = np.random.randint(0, n - exchange_length)\n\n            segment1 = new_solution[exchange_pos1:exchange_pos1+exchange_length]\n            segment2 = new_solution[exchange_pos2:exchange_pos2+exchange_length]\n\n            # Calculate exchange costs\n            cost1_before = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(exchange_pos1, exchange_pos1+exchange_length)) + \\\n                           sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(exchange_pos2, exchange_pos2+exchange_length))\n            cost2_before = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(exchange_pos1, exchange_pos1+exchange_length)) + \\\n                           sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(exchange_pos2, exchange_pos2+exchange_length))\n\n            # Exchange segments\n            new_solution[exchange_pos1:exchange_pos1+exchange_length] = segment2\n            new_solution[exchange_pos2:exchange_pos2+exchange_length] = segment1\n\n            cost1_after = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(exchange_pos1, exchange_pos1+exchange_length)) + \\\n                          sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(exchange_pos2, exchange_pos2+exchange_length))\n            cost2_after = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(exchange_pos1, exchange_pos1+exchange_length)) + \\\n                          sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(exchange_pos2, exchange_pos2+exchange_length))\n\n            # Revert if no improvement in either objective\n            if (cost1_after >= cost1_before and cost2_after >= cost2_before):\n                new_solution[exchange_pos1:exchange_pos1+exchange_length] = segment1\n                new_solution[exchange_pos2:exchange_pos2+exchange_length] = segment2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a novel \"multi-segment inversion and rotation\" local search that combines segment inversions with rotational shifts to generate diverse neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion and rotation\n        num_segments = np.random.randint(2, min(4, n // 2))\n        segment_lengths = np.random.randint(2, min(5, n // num_segments), size=num_segments)\n        segment_starts = np.sort(np.random.choice(n - sum(segment_lengths) + 1, num_segments, replace=False))\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n\n            # Invert or rotate the segment\n            if np.random.rand() < 0.5:\n                segment = segment[::-1]  # Inversion\n            else:\n                shift = np.random.randint(1, length)\n                segment = np.roll(segment, shift)  # Rotation\n\n            new_solution[start:start+length] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7398492343203849,
            0.3249465823173523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment inversion and rotation\n        num_segments = np.random.randint(2, min(4, n // 2))\n        segment_lengths = np.random.randint(2, min(5, n // num_segments), size=num_segments)\n        segment_starts = np.sort(np.random.choice(n - sum(segment_lengths) + 1, num_segments, replace=False))\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            segment = new_solution[start:start+length]\n\n            # Invert or rotate the segment\n            if np.random.rand() < 0.5:\n                segment = segment[::-1]  # Inversion\n            else:\n                shift = np.random.randint(1, length)\n                segment = np.roll(segment, shift)  # Rotation\n\n            new_solution[start:start+length] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"objective-aware node relocation\" with a \"multi-segment crossover\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware node relocation with multi-segment crossover\n    if n > 4:\n        # Objective-aware node relocation\n        node = np.random.randint(0, n)\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node or (pos + 1) % n == node:\n                continue\n\n            # Calculate potential improvement\n            old_cost1 = distance_matrix_1[new_solution[node-1], new_solution[node]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]]\n            old_cost2 = distance_matrix_2[new_solution[node-1], new_solution[node]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[node-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[(node+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[node-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[(node+1)%n]]\n\n            improvement1 = old_cost1 - new_cost1\n            improvement2 = old_cost2 - new_cost2\n\n            if improvement1 > 0 or improvement2 > 0:\n                if improvement1 + improvement2 > best_improvement:\n                    best_improvement = improvement1 + improvement2\n                    best_pos = pos\n\n        if best_pos != -1:\n            # Relocate node\n            node_val = new_solution[node]\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, node_val)\n\n        # Multi-segment crossover\n        if n > 8:\n            num_segments = np.random.randint(2, 4)\n            segment_length = n // num_segments\n\n            segments = []\n            for i in range(num_segments):\n                start = i * segment_length\n                end = (i + 1) * segment_length if i < num_segments - 1 else n\n                segments.append(new_solution[start:end])\n\n            # Randomly shuffle segments\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n    return new_solution\n\n",
        "score": [
            -0.8421990714661143,
            0.3158751130104065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Objective-aware node relocation with multi-segment crossover\n    if n > 4:\n        # Objective-aware node relocation\n        node = np.random.randint(0, n)\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == node or (pos + 1) % n == node:\n                continue\n\n            # Calculate potential improvement\n            old_cost1 = distance_matrix_1[new_solution[node-1], new_solution[node]] + distance_matrix_1[new_solution[node], new_solution[(node+1)%n]]\n            old_cost2 = distance_matrix_2[new_solution[node-1], new_solution[node]] + distance_matrix_2[new_solution[node], new_solution[(node+1)%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[node-1], new_solution[pos]] + distance_matrix_1[new_solution[pos], new_solution[(node+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[node-1], new_solution[pos]] + distance_matrix_2[new_solution[pos], new_solution[(node+1)%n]]\n\n            improvement1 = old_cost1 - new_cost1\n            improvement2 = old_cost2 - new_cost2\n\n            if improvement1 > 0 or improvement2 > 0:\n                if improvement1 + improvement2 > best_improvement:\n                    best_improvement = improvement1 + improvement2\n                    best_pos = pos\n\n        if best_pos != -1:\n            # Relocate node\n            node_val = new_solution[node]\n            new_solution = np.delete(new_solution, node)\n            new_solution = np.insert(new_solution, best_pos, node_val)\n\n        # Multi-segment crossover\n        if n > 8:\n            num_segments = np.random.randint(2, 4)\n            segment_length = n // num_segments\n\n            segments = []\n            for i in range(num_segments):\n                start = i * segment_length\n                end = (i + 1) * segment_length if i < num_segments - 1 else n\n                segments.append(new_solution[start:end])\n\n            # Randomly shuffle segments\n            np.random.shuffle(segments)\n            new_solution = np.concatenate(segments)\n\n    return new_solution\n\n"
    }
]