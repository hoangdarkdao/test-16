[
     {
          "algorithm": "{The new algorithm will first identify solutions in the archive that show potential for improvement by analyzing both their objective values and the diversity of their node sequences, then apply a novel 'multi-dimensional cluster inversion' strategy that randomly groups nodes into clusters based on their geometric proximity in both coordinate spaces, inverts each cluster's sequence while maintaining spatial coherence, and optimally reassigns edges between clusters by considering both distance matrices, all while ensuring feasibility by verifying that the resulting tour remains a valid permutation of all nodes and maintaining the circular nature of the tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate potential improvement score considering both objectives and diversity\n        obj_score = (obj[0] + obj[1]) / 2\n        diversity_score = len(set(sol)) / len(sol)\n        improvement_score = obj_score * diversity_score\n        candidates.append((sol, improvement_score))\n\n    candidates.sort(key=lambda x: -x[1])\n    selected = candidates[0][0].copy()\n\n    # Step 2: Apply multi-dimensional cluster inversion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Create clusters based on geometric proximity in both spaces\n    clusters = []\n    remaining = list(range(n))\n    while len(remaining) > 0:\n        # Randomly select a seed node\n        seed = random.choice(remaining)\n        cluster = [seed]\n        remaining.remove(seed)\n\n        # Find nearby nodes in both spaces\n        for node in remaining[:]:\n            x1_seed, y1_seed, x2_seed, y2_seed = instance[selected[seed]]\n            x1_node, y1_node, x2_node, y2_node = instance[selected[node]]\n\n            # Calculate distances in both spaces\n            dist1 = np.sqrt((x1_seed - x1_node)**2 + (y1_seed - y1_node)**2)\n            dist2 = np.sqrt((x2_seed - x2_node)**2 + (y2_seed - y2_node)**2)\n\n            # Add to cluster if close in both spaces\n            if dist1 < np.mean(distance_matrix_1) * 0.5 and dist2 < np.mean(distance_matrix_2) * 0.5:\n                cluster.append(node)\n                remaining.remove(node)\n\n        if len(cluster) > 1:\n            clusters.append(cluster)\n\n    # Invert each cluster while maintaining spatial coherence\n    for cluster in clusters:\n        # Find the cluster's centroid in both spaces\n        centroid1_x = np.mean([instance[selected[node]][0] for node in cluster])\n        centroid1_y = np.mean([instance[selected[node]][1] for node in cluster])\n        centroid2_x = np.mean([instance[selected[node]][2] for node in cluster])\n        centroid2_y = np.mean([instance[selected[node]][3] for node in cluster])\n\n        # Sort nodes in the cluster by angle relative to centroid in both spaces\n        def angle_sort_key(node):\n            x1, y1, x2, y2 = instance[selected[node]]\n            angle1 = np.arctan2(y1 - centroid1_y, x1 - centroid1_x)\n            angle2 = np.arctan2(y2 - centroid2_y, x2 - centroid2_x)\n            return (angle1 + angle2) / 2\n\n        cluster_sorted = sorted(cluster, key=angle_sort_key)\n        new_solution[cluster] = [selected[node] for node in cluster_sorted[::-1]]\n\n    # Step 3: Optimally reassign edges between clusters\n    for i in range(len(clusters)-1):\n        cluster1 = clusters[i]\n        cluster2 = clusters[i+1]\n\n        # Find best edge to connect clusters\n        best_improvement = 0\n        best_edge = None\n\n        for a in cluster1:\n            for b in cluster2:\n                # Current edges\n                prev_a = selected[a-1] if a > 0 else selected[-1]\n                next_a = selected[(a+1)%n]\n                prev_b = selected[b-1] if b > 0 else selected[-1]\n                next_b = selected[(b+1)%n]\n\n                # Current costs\n                current_cost1 = (distance_matrix_1[prev_a, selected[a]] +\n                                distance_matrix_1[selected[a], next_a] +\n                                distance_matrix_1[prev_b, selected[b]] +\n                                distance_matrix_1[selected[b], next_b])\n                current_cost2 = (distance_matrix_2[prev_a, selected[a]] +\n                                distance_matrix_2[selected[a], next_a] +\n                                distance_matrix_2[prev_b, selected[b]] +\n                                distance_matrix_2[selected[b], next_b])\n\n                # New costs if we connect a to b\n                new_cost1 = (distance_matrix_1[prev_a, selected[a]] +\n                            distance_matrix_1[selected[a], selected[b]] +\n                            distance_matrix_1[selected[b], next_a] +\n                            distance_matrix_1[prev_b, selected[b]] +\n                            distance_matrix_1[selected[b], next_b])\n                new_cost2 = (distance_matrix_2[prev_a, selected[a]] +\n                            distance_matrix_2[selected[a], selected[b]] +\n                            distance_matrix_2[selected[b], next_a] +\n                            distance_matrix_2[prev_b, selected[b]] +\n                            distance_matrix_2[selected[b], next_b])\n\n                improvement = (current_cost1 + current_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_edge = (a, b)\n\n        # Apply the best edge connection\n        if best_edge:\n            a, b = best_edge\n            a_pos = np.where(new_solution == selected[a])[0][0]\n            b_pos = np.where(new_solution == selected[b])[0][0]\n\n            if a_pos > b_pos:\n                a_pos, b_pos = b_pos, a_pos\n\n            new_solution[a_pos+1:b_pos] = new_solution[a_pos+1:b_pos][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.036349290086442,
               2.395252764225006
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel multi-objective adaptive segment exchange mechanism that combines a probabilistic segment selection strategy with an objective-aware segment relocation operator. It first identifies solutions with high potential by analyzing their objective-space coverage and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively exchanges entire segments between the current solution and a reference solution, where the segment selection probability and relocation depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the segment relocation mechanism explores different solution structures by probabilistically relocating segments to positions that improve both objectives. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, while maintaining a focus on segment-based operations that can efficiently explore the solution space in the bi-objective context.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of coverage and dominance)\n    coverage_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.5 * coverage_scores + 0.5 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply adaptive segment exchange with objective-aware relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment selection with probability based on objective improvements\n    segment_length = max(2, min(n // 5, np.random.randint(2, n // 3)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Objective-aware segment relocation\n    if len(archive) > 1:\n        # Select a reference solution\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n\n        # Calculate potential improvement for the segment\n        current_segment = base_solution[start:end]\n        ref_segment = ref_solution[start:end]\n\n        # Calculate cost difference\n        current_cost1 = sum(distance_matrix_1[current_segment[i], current_segment[i+1]] for i in range(len(current_segment)-1))\n        current_cost1 += distance_matrix_1[current_segment[-1], current_segment[0]]\n        ref_cost1 = sum(distance_matrix_1[ref_segment[i], ref_segment[i+1]] for i in range(len(ref_segment)-1))\n        ref_cost1 += distance_matrix_1[ref_segment[-1], ref_segment[0]]\n\n        current_cost2 = sum(distance_matrix_2[current_segment[i], current_segment[i+1]] for i in range(len(current_segment)-1))\n        current_cost2 += distance_matrix_2[current_segment[-1], current_segment[0]]\n        ref_cost2 = sum(distance_matrix_2[ref_segment[i], ref_segment[i+1]] for i in range(len(ref_segment)-1))\n        ref_cost2 += distance_matrix_2[ref_segment[-1], ref_segment[0]]\n\n        # Decide whether to exchange based on objective improvement\n        if (ref_cost1 < current_cost1 and ref_cost2 < current_cost2):\n            new_solution[start:end] = ref_segment.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0345572131886867,
               0.27952826023101807
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive k-opt operator with a dynamic objective-aware node insertion mechanism. It first identifies solutions with high potential by evaluating their objective-space coverage and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively selects a random k (between 2 and a problem-specific maximum) and replaces a segment of the tour with a new segment constructed through a combination of node reinsertion and segment reversal, where the k value and insertion strategy are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the dynamic k-opt mechanism explores different solution structures by probabilistically selecting larger segments for more significant modifications when the current solution shows poor objective trade-offs. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, while maintaining a focus on segment-based operations that can efficiently explore the solution space in the bi-objective context.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential (combination of coverage and dominance)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    coverage_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.5 * coverage_scores + 0.5 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply adaptive k-opt with dynamic node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine k value based on solution quality\n    k_max = min(5, n // 2)\n    k = np.random.randint(2, k_max + 1)\n\n    # Select a random segment to modify\n    start = np.random.randint(0, n - k)\n    end = start + k\n    segment = new_solution[start:end]\n\n    # Calculate current segment cost\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n    current_cost1 += distance_matrix_1[new_solution[end-1], new_solution[start]]\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n    current_cost2 += distance_matrix_2[new_solution[end-1], new_solution[start]]\n\n    # Create a candidate segment by either reversing or reinserting nodes\n    if np.random.random() < 0.5:\n        # Reverse segment\n        candidate_segment = segment[::-1]\n    else:\n        # Reinsert nodes with objective-aware selection\n        candidate_segment = segment.copy()\n        for i in range(k):\n            if np.random.random() < 0.3:\n                # Swap with a random node from the tour\n                j = np.random.randint(0, n)\n                candidate_segment[i], new_solution[j] = new_solution[j], candidate_segment[i]\n\n    # Calculate candidate segment cost\n    candidate_cost1 = sum(distance_matrix_1[candidate_segment[i], candidate_segment[i+1]] for i in range(k-1))\n    candidate_cost1 += distance_matrix_1[candidate_segment[-1], candidate_segment[0]]\n    candidate_cost2 = sum(distance_matrix_2[candidate_segment[i], candidate_segment[i+1]] for i in range(k-1))\n    candidate_cost2 += distance_matrix_2[candidate_segment[-1], candidate_segment[0]]\n\n    # Accept the candidate if it improves both objectives\n    if (candidate_cost1 < current_cost1 and candidate_cost2 < current_cost2):\n        new_solution[start:end] = candidate_segment\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, perform a simple valid move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9698985616258731,
               0.2399190068244934
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel multi-objective adaptive path decomposition and reconstruction mechanism that combines a probabilistic path segmentation strategy with an objective-aware path merging operator. It first identifies solutions with high potential by analyzing their objective-space coverage and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively decomposes the current solution into multiple non-overlapping paths and reconstructs them by merging segments from reference solutions, where the path decomposition granularity and merging strategy are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path merging mechanism explores different solution structures by probabilistically combining segments from multiple reference solutions to create new paths. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, while maintaining a focus on path-based operations that can efficiently explore the solution space in the bi-objective context.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of coverage and dominance)\n    coverage_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.6 * coverage_scores + 0.4 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply adaptive path decomposition and reconstruction\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine decomposition granularity\n    num_paths = max(2, min(5, np.random.randint(2, n // 3)))\n    path_length = n // num_paths\n    paths = [base_solution[i*path_length:(i+1)*path_length] for i in range(num_paths)]\n\n    # Select reference solutions for merging\n    if len(archive) > 1:\n        ref_indices = np.random.choice(len(archive), size=min(3, len(archive)), replace=False)\n        ref_solutions = [archive[i][0] for i in ref_indices]\n\n        # Reconstruct paths by merging segments from reference solutions\n        for i in range(num_paths):\n            ref_idx = np.random.randint(0, len(ref_solutions))\n            ref_path = ref_solutions[ref_idx][i*path_length:(i+1)*path_length]\n            merge_ratio = np.random.uniform(0.3, 0.7)\n\n            for j in range(len(paths[i])):\n                if np.random.random() < merge_ratio:\n                    paths[i][j] = ref_path[j]\n\n    # Reconstruct the solution from paths\n    new_solution = np.concatenate(paths)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9662619036768505,
               0.1421421766281128
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive segment inversion with a dynamic path crossover mechanism. It first identifies solutions with high potential by evaluating their objective-space coverage and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively inverts segments of the solution path and crosses them with segments from reference solutions, where the inversion strength and crossover points are dynamically determined based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path crossover mechanism explores different solution structures by combining segments from multiple reference solutions to create new paths. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, while maintaining a focus on segment-based operations that can efficiently explore the solution space in the bi-objective context.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of coverage and dominance)\n    coverage_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.5 * coverage_scores + 0.5 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply hybrid adaptive segment inversion and path crossover\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = max(2, min(n // 2, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic path crossover with reference solutions\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        crossover_point = np.random.randint(1, n)\n        new_solution[crossover_point:] = ref_solution[crossover_point:]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, perform a simple valid move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9131760210307921,
               0.10895580053329468
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive clustering with a dynamic segment inversion mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a cluster-based perturbation with a segment inversion-inspired move, where the cluster size and inversion depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the segment inversion mechanism explores intermediate solutions by flipping segments of the tour to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, while also incorporating spatial information from the instance to guide the local search.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.5 * diversity_scores + 0.5 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive clustering with dynamic segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive cluster-based perturbation\n    cluster_size = max(2, min(n // 4, np.random.randint(2, n // 3)))\n    num_clusters = max(2, n // cluster_size)\n\n    # Create clusters by grouping consecutive nodes\n    clusters = []\n    for i in range(num_clusters):\n        start = i * cluster_size\n        end = min((i + 1) * cluster_size, n)\n        clusters.append(new_solution[start:end])\n\n    # Dynamic segment inversion: invert clusters based on spatial proximity\n    if len(clusters) > 1:\n        for i in range(len(clusters)):\n            if np.random.random() < 0.3:  # 30% chance to invert a cluster\n                clusters[i] = clusters[i][::-1]\n\n    # Reconstruct the solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0289927276199635,
               0.35933321714401245
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 4, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment inversion\n    if end < n:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.002562955635491,
               0.30344176292419434
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach called \"Objective-Driven Segment Exchange with Adaptive Relocation,\" which first analyzes the archive to identify solutions with the most promising objective trade-offs by evaluating their normalized objective values and dominance relationships. It then selects a solution based on a weighted combination of objective improvements and diversity, and applies a hybrid operator that adaptively exchanges segments between the selected solution and a reference solution while dynamically adjusting the segment length and exchange probability based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the adaptive relocation mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, and incorporates a novel segment exchange strategy that considers both objective spaces to generate high-quality solutions.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with the most promising trade-offs\n    improvement_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * improvement_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply objective-driven segment exchange with adaptive relocation\n    n = len(new_solution)\n    segment_length = max(2, min(n // 3, np.random.randint(2, n // 2)))\n\n    # Select reference solution with complementary objectives\n    ref_idx = np.argmin(np.sum(np.abs(normalized_objectives - (1 - normalized_objectives[selected_idx])), axis=1))\n    ref_solution = archive[ref_idx][0]\n\n    # Find exchange segments based on objective improvements\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Calculate objective improvements for the segments\n    def calculate_improvement(solution, ref_solution, start, end):\n        original_cost1 = distance_matrix_1[solution[start-1], solution[start]] + distance_matrix_1[solution[end-1], solution[(end)%n]]\n        new_cost1 = distance_matrix_1[ref_solution[start-1], ref_solution[start]] + distance_matrix_1[ref_solution[end-1], ref_solution[(end)%n]]\n        original_cost2 = distance_matrix_2[solution[start-1], solution[start]] + distance_matrix_2[solution[end-1], solution[(end)%n]]\n        new_cost2 = distance_matrix_2[ref_solution[start-1], ref_solution[start]] + distance_matrix_2[ref_solution[end-1], ref_solution[(end)%n]]\n        return (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n    improvement = calculate_improvement(new_solution, ref_solution, start, end)\n    exchange_prob = min(1.0, max(0.1, 0.5 * improvement / (segment_length * n)))\n\n    if np.random.random() < exchange_prob:\n        # Exchange segments and relocate nodes\n        temp = new_solution[start:end].copy()\n        new_solution[start:end] = ref_solution[start:end]\n        # Adaptive relocation based on objective space\n        for i in range(start, end):\n            if np.random.random() < 0.3:\n                # Relocate based on first objective\n                best_pos = start\n                best_cost = float('inf')\n                for pos in range(start, end):\n                    if pos != i:\n                        cost = distance_matrix_1[new_solution[pos-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(pos+1)%n]]\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_pos = pos\n                if best_pos != i:\n                    node = new_solution[i]\n                    new_solution = np.delete(new_solution, i)\n                    new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # Perform segment rotation\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, perform a valid move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -1.0206797994754273,
               0.33938342332839966
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, while also incorporating a novel segment-based perturbation that dynamically adjusts the segment length and position based on the solution's objective values and the instance's characteristics.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply dynamic segment-based perturbation with adaptive relinking\n    n = len(new_solution)\n    segment_length = max(2, min(n // 3, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.4, 0.8)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment inversion and rotation\n    if np.random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.969885523101226,
               0.28102558851242065
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 2, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment rotation\n    if end < n:\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, perform a simple valid move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9636209173816817,
               0.14570850133895874
          ]
     }
]