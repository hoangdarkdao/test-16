[
    {
        "algorithm": "{This algorithm implements a novel multi-objective adaptive path inversion strategy that combines probabilistic segment inversion with dynamic node reinsertion and intelligent segment reordering, dynamically balancing improvements across both objectives through adaptive weight adjustment and path quality evaluation while ensuring feasibility through path validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(1, min(3, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segments.append(new_solution[start:end])\n\n    for segment in segments:\n        if len(segment) < 2:\n            continue\n\n        segment = segment.copy()\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution) - len(segment) + 1):\n            candidate = new_solution.copy()\n            candidate[pos:pos+len(segment)] = segment\n\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n\n            weight = 0.7 if (pos == 0 or pos == len(new_solution) - len(segment)) else 0.3\n            score = weight * cost1 + (1 - weight) * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution[best_pos:best_pos+len(segment)] = segment\n\n    remaining_nodes = list(set(range(n)) - set(new_solution))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution) + 1):\n            candidate = np.insert(new_solution, pos, node)\n\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n\n            weight = 0.8 if (pos == 0 or pos == len(new_solution)) else 0.2\n            score = weight * cost1 + (1 - weight) * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            8.330893410295563,
            4.4166464509761925
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel path-splitting and reassembly strategy that divides the tour into multiple segments, randomly permutes these segments, and then intelligently reinserts them using a multi-objective segment alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with intelligent segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on current solution quality\n            current_cost1, current_cost2 = calculate_cost(reassembled)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.484883794537127,
            8.87657962803985
        ]
    }
]