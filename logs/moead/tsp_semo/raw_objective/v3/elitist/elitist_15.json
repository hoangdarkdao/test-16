[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.765381223706096,
            6.829708949278469
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.765381223706096,
            6.829708949278469
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse and reinsert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b]\n    remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    # Find the best insertion point for the reversed segment\n    best_cost = float('inf')\n    best_pos = a\n    for i in range(1, len(remaining)):\n        candidate = np.concatenate([remaining[:i], segment[::-1], remaining[i:]])\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n        if cost1 + cost2 < best_cost:\n            best_cost = cost1 + cost2\n            best_pos = i\n\n    # Apply the best insertion\n    new_solution = np.concatenate([remaining[:best_pos], segment[::-1], remaining[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Fallback to a random swap if feasibility is violated\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n",
        "score": [
            6.097869335743309,
            5.796472227952588
        ]
    },
    {
        "algorithm": "{This algorithm selects the best solution from the archive based on a weighted sum of objectives, then applies a novel hybrid local search combining node insertion and segment reversal with probabilistic bias towards cost reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Hybrid operator: probabilistic node insertion with segment reversal\n    if np.random.rand() < 0.7:\n        # Node insertion with bias\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n    else:\n        # Segment reversal with cost consideration\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        segment = new_solution[a:b]\n        if (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]) < \\\n           (distance_matrix_1[new_solution[a-1], segment[0]] + distance_matrix_2[new_solution[a-1], segment[0]]):\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            4.833055663618152,
            8.301807858743382
        ]
    },
    {
        "algorithm": "{The new algorithm will select a solution from the archive based on a weighted combination of both objectives, then apply a novel \"segment inversion and relocation\" operator that randomly selects two segments of the tour, inverts one of them, and relocates it to a new position while ensuring the solution remains valid.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to modify\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:]\n\n    # Invert one segment and relocate it\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_order)) == n:\n        new_solution = new_order\n    else:\n        # Fallback to relocating a random segment\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    return new_solution\n\n",
        "score": [
            4.853602681242226,
            8.093264043437422
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a novel \"segment inversion with objective-biased reinsertion\" operator that intelligently inverts and reinserts segments of the tour based on the relative improvement in both objectives, ensuring feasibility through careful validation and fallback to a random swap if the operation fails.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to invert and reinsert\n    start, end = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Calculate potential insertion points and evaluate their impact on both objectives\n    best_insert_pos = -1\n    best_improvement = 0\n    for i in range(len(remaining)):\n        # Try inserting the inverted segment at position i\n        candidate = np.concatenate([remaining[:i], segment[::-1], remaining[i:]])\n        # Calculate the change in both objectives\n        old_cost1 = distance_matrix_1[selected_solution[start-1], selected_solution[start]] + distance_matrix_1[selected_solution[end-1], selected_solution[end]]\n        old_cost2 = distance_matrix_2[selected_solution[start-1], selected_solution[start]] + distance_matrix_2[selected_solution[end-1], selected_solution[end]]\n        new_cost1 = distance_matrix_1[candidate[i-1], candidate[i]] + distance_matrix_1[candidate[i+len(segment)-1], candidate[i+len(segment)]]\n        new_cost2 = distance_matrix_2[candidate[i-1], candidate[i]] + distance_matrix_2[candidate[i+len(segment)-1], candidate[i+len(segment)]]\n        improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = i\n\n    # Apply the best insertion if it improves the solution\n    if best_insert_pos != -1:\n        candidate = np.concatenate([remaining[:best_insert_pos], segment[::-1], remaining[best_insert_pos:]])\n        if len(np.unique(candidate)) == n:\n            new_solution = candidate\n        else:\n            # Fallback to random swap if the operation fails\n            i, j = np.random.choice(range(n), size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Fallback to random swap if no improvement found\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.956907168424829,
            5.804027952379856
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objectives, then applies a novel local search operator that combines 2-opt with a biased random segment reversal to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: 2-opt with biased segment reversal\n    a, b = sorted(np.random.choice(range(1, n), size=2, replace=False))\n    segment = new_solution[a:b]\n\n    if np.random.rand() < 0.7:  # Higher probability for segment reversal\n        segment = segment[::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(np.concatenate([new_solution[:a], segment, new_solution[b:]]))) == n:\n        new_solution[a:b] = segment\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.268829284637378,
            6.8636386993217835
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a hybrid local search that combines segment reversal with biased random insertion to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.5 * x[1][0] + 0.5 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search combining segment reversal and biased insertion\n    if np.random.rand() < 0.7:  # 70% chance for segment reversal\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        segment = new_solution[a:b]\n        new_solution[a:b] = segment[::-1]\n    else:  # 30% chance for biased insertion\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to swapping two random nodes if invalid\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.538754924693423,
            5.5752336340747695
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 4-opt with biased segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select four edges to modify\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3[::-1]])\n    else:\n        new_order = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:d] = new_order\n    else:\n        # Fallback to reversing a random segment if the above fails\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.217571056967836,
            5.6318697616168905
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] * 0.7 + x[1][1] * 0.3)[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a novel local search operator: 4-segment relocation with objective-aware segment selection\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:d]\n    segment5 = new_solution[d:]\n\n    # Evaluate possible segment rearrangements based on objective improvements\n    candidates = [\n        np.concatenate([segment1, segment3, segment2, segment4, segment5]),\n        np.concatenate([segment1, segment2, segment4, segment3, segment5]),\n        np.concatenate([segment1, segment4, segment2, segment3, segment5])\n    ]\n\n    # Select the candidate with the best combined objective improvement\n    best_candidate = min(candidates, key=lambda x: (\n        sum(distance_matrix_1[x[i], x[i+1]] for i in range(n-1)) + distance_matrix_1[x[-1], x[0]],\n        sum(distance_matrix_2[x[i], x[i+1]] for i in range(n-1)) + distance_matrix_2[x[-1], x[0]]\n    ))\n\n    new_solution = best_candidate\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Fallback to a simple 2-opt if the above fails\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n",
        "score": [
            5.244545397932713,
            7.856513483081924
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 4-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select four edges to modify\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    segment4 = new_solution[d:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3, segment4[::-1]])\n    else:\n        new_order = np.concatenate([segment1, segment4, segment3[::-1], segment2])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:d] = new_order\n    else:\n        # Fallback to reversing a random segment if the above fails\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.954977864677905,
            5.913752711816938
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n\n    # Apply a novel local search operator: \"Biased Segment Reversal with Objective-Aware Insertion\"\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[a:b]\n\n    # Reverse the segment with a bias towards reducing the higher-cost objective\n    if np.random.rand() < 0.7:  # Higher probability to reverse\n        new_solution[a:b] = segment[::-1]\n\n    # Objective-aware insertion: find the best insertion point for the reversed segment\n    if np.random.rand() < 0.5:  # Apply insertion with 50% probability\n        best_pos = a\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos >= a and pos < b:\n                continue  # Skip the original segment position\n\n            # Temporarily insert the reversed segment\n            temp_solution = np.concatenate([new_solution[:pos], segment[::-1], new_solution[pos:]])\n            temp_solution = np.delete(temp_solution, range(pos, pos + len(segment)))\n\n            # Calculate the cost in both objectives\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Prefer solutions that reduce the higher-cost objective\n            total_cost = max(cost1, cost2)\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_pos], segment[::-1], new_solution[best_pos:]])\n        new_solution = np.delete(new_solution, range(best_pos, best_pos + len(segment)))\n\n    return new_solution\n\n",
        "score": [
            9.405815450473165,
            5.521342826652818
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution with high potential for improvement by considering both objective costs and applies a novel \"segmented inversion with objective-aware insertion\" operator that reverses segments and strategically reinserts them based on the combined cost reduction in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse and reinsert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b]\n    remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    # Evaluate potential insertion points based on combined cost reduction\n    best_insertion = None\n    min_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Try inserting the reversed segment at position i\n        candidate = np.concatenate([remaining[:i], segment[::-1], remaining[i:]])\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insertion = candidate\n\n    if best_insertion is not None:\n        new_solution = best_insertion\n    else:\n        # Fallback to random swap if no improvement found\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.524100728355354,
            6.100611625385507
        ]
    }
]