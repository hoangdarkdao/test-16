[
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt with a probabilistic segment relocation to explore diverse regions in the solution space, prioritizing nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 4-opt with probabilistic segment relocation\n    for _ in range(4):  # Repeat a few times for better exploration\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Dynamic 4-opt: rearrange segments in different orders\n        if random.random() < 0.6:  # 60% chance to apply dynamic 4-opt\n            options = [\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2, segment3]),\n                np.concatenate([segment2[::-1], segment1, segment3]),\n                np.concatenate([segment3[::-1], segment1, segment2])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:l] = new_segment\n        else:  # Probabilistic segment relocation\n            if random.random() < 0.5:\n                new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[l:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], segment3, segment2, new_solution[k:]])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8882747956793511,
            0.18436086177825928
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt with a probabilistic edge exchange that prioritizes nodes with high edge diversity and objective trade-off potential, while adaptively adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 3-opt with probabilistic edge exchange\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Dynamic 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply dynamic 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2[::-1]]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1[::-1]])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Probabilistic edge exchange\n            if random.random() < 0.6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -1.0277778368353312,
            0.2724300026893616
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt with a probabilistic segment relocation to explore diverse regions in the solution space, prioritizing nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 4-opt with probabilistic segment relocation\n    for _ in range(4):  # Repeat a few times for better exploration\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Dynamic 4-opt: rearrange segments in different orders\n        if random.random() < 0.6:  # 60% chance to apply dynamic 4-opt\n            options = [\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2, segment3]),\n                np.concatenate([segment2[::-1], segment1, segment3]),\n                np.concatenate([segment3[::-1], segment1, segment2])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:l] = new_segment\n        else:  # Probabilistic segment relocation\n            if random.random() < 0.5:\n                new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[l:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], segment3, segment2, new_solution[k:]])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8882747956793511,
            0.18436086177825928
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt with a probabilistic edge exchange that prioritizes nodes with high edge diversity and objective trade-off potential, while adaptively adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 3-opt with probabilistic edge exchange\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Dynamic 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply dynamic 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2[::-1]]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1[::-1]])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Probabilistic edge exchange\n            if random.random() < 0.6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -1.0277778368353312,
            0.2724300026893616
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines an adaptive 3-opt with a stochastic edge inversion to explore the solution space, focusing on nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Adaptive 3-opt with stochastic edge inversion\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Adaptive 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply adaptive 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1]),\n                np.concatenate([segment1, segment2[::-1]])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Stochastic edge inversion\n            if random.random() < 0.4:\n                new_solution[i:j] = segment1[::-1]\n            else:\n                new_solution[j:k] = segment2[::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.9787162909951734,
            0.23318934440612793
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt with a probabilistic segment relocation to explore diverse regions in the solution space, prioritizing nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 4-opt with probabilistic segment relocation\n    for _ in range(4):  # Repeat a few times for better exploration\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Dynamic 4-opt: rearrange segments in different orders\n        if random.random() < 0.6:  # 60% chance to apply dynamic 4-opt\n            options = [\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2, segment3]),\n                np.concatenate([segment2[::-1], segment1, segment3]),\n                np.concatenate([segment3[::-1], segment1, segment2])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:l] = new_segment\n        else:  # Probabilistic segment relocation\n            if random.random() < 0.5:\n                new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[l:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], segment3, segment2, new_solution[k:]])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8882747956793511,
            0.18436086177825928
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 3-opt with a probabilistic edge exchange that prioritizes nodes with high edge diversity and objective trade-off potential, while adaptively adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 3-opt with probabilistic edge exchange\n    for _ in range(3):  # Repeat a few times for better exploration\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Dynamic 3-opt: rearrange segments in different orders\n        if random.random() < 0.7:  # 70% chance to apply dynamic 3-opt\n            options = [\n                np.concatenate([segment2, segment1]),\n                np.concatenate([segment1, segment2[::-1]]),\n                np.concatenate([segment1[::-1], segment2]),\n                np.concatenate([segment2[::-1], segment1[::-1]])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:k] = new_segment\n        else:  # Probabilistic edge exchange\n            if random.random() < 0.6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -1.0277778368353312,
            0.2724300026893616
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt with a probabilistic segment relocation to explore diverse regions in the solution space, prioritizing nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 4-opt with probabilistic segment relocation\n    for _ in range(4):  # Repeat a few times for better exploration\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Dynamic 4-opt: rearrange segments in different orders\n        if random.random() < 0.6:  # 60% chance to apply dynamic 4-opt\n            options = [\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2, segment3]),\n                np.concatenate([segment2[::-1], segment1, segment3]),\n                np.concatenate([segment3[::-1], segment1, segment2])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:l] = new_segment\n        else:  # Probabilistic segment relocation\n            if random.random() < 0.5:\n                new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[l:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], segment3, segment2, new_solution[k:]])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8882747956793511,
            0.18436086177825928
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt with a probabilistic segment relocation to explore diverse regions in the solution space, prioritizing nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 4-opt with probabilistic segment relocation\n    for _ in range(4):  # Repeat a few times for better exploration\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Dynamic 4-opt: rearrange segments in different orders\n        if random.random() < 0.6:  # 60% chance to apply dynamic 4-opt\n            options = [\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2, segment3]),\n                np.concatenate([segment2[::-1], segment1, segment3]),\n                np.concatenate([segment3[::-1], segment1, segment2])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:l] = new_segment\n        else:  # Probabilistic segment relocation\n            if random.random() < 0.5:\n                new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[l:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], segment3, segment2, new_solution[k:]])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8882747956793511,
            0.18436086177825928
        ]
    },
    {
        "algorithm": "{This algorithm uses a novel \"edge-aware segment relocation with multi-objective adaptive perturbation\" that dynamically selects and relocates segments of the tour based on edge criticality in both objective spaces, while applying probabilistic perturbations to escape local optima and maintain solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Calculate edge criticality scores (sum of distances in both objective spaces)\n    edge_scores = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        score = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n        edge_scores.append(score)\n\n    # Find the least critical edge (potential for improvement)\n    min_idx = np.argmin(edge_scores)\n    a, b = new_solution[min_idx], new_solution[(min_idx+1)%n]\n\n    # Find the most critical node to insert between a and b\n    candidates = [i for i in range(n) if i not in {min_idx, (min_idx+1)%n}]\n    if not candidates:\n        return new_solution\n\n    # Calculate insertion gain for each candidate\n    gains = []\n    for i in candidates:\n        u = new_solution[(i-1)%n]\n        v = new_solution[i]\n        w = new_solution[(i+1)%n]\n\n        # Calculate gain as reduction in combined distance\n        gain = (distance_matrix_1[u, v] + distance_matrix_1[v, w] +\n                distance_matrix_2[u, v] + distance_matrix_2[v, w]) - \\\n               (distance_matrix_1[u, a] + distance_matrix_1[a, b] + distance_matrix_1[b, w] +\n                distance_matrix_2[u, a] + distance_matrix_2[a, b] + distance_matrix_2[b, w])\n        gains.append(gain)\n\n    if not gains or max(gains) <= 0:\n        # Apply probabilistic perturbation if no improvement possible\n        if random.random() < 0.3:\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        return new_solution\n\n    # Perform the best insertion\n    best_candidate = candidates[np.argmax(gains)]\n    best_pos = (min_idx+1)%n if best_candidate > min_idx else min_idx\n\n    # Create new solution with insertion\n    temp = new_solution.copy()\n    temp = np.concatenate([temp[:best_pos], [temp[best_candidate]], temp[best_pos:]])\n    if best_candidate < best_pos:\n        temp = np.delete(temp, best_candidate)\n\n    # Verify feasibility\n    if len(np.unique(temp)) == n:\n        new_solution = temp\n\n    # Apply additional probabilistic perturbation\n    if random.random() < 0.2:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.973243170275442,
            0.2092185616493225
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt with a probabilistic segment relocation to explore diverse regions in the solution space, prioritizing nodes with high edge diversity and objective trade-off potential while dynamically adjusting the search intensity based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution  # No improvement possible\n\n    # Hybrid local search: Dynamic 4-opt with probabilistic segment relocation\n    for _ in range(4):  # Repeat a few times for better exploration\n        i, j, k, l = sorted(random.sample(range(n), 4))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:l]\n\n        # Dynamic 4-opt: rearrange segments in different orders\n        if random.random() < 0.6:  # 60% chance to apply dynamic 4-opt\n            options = [\n                np.concatenate([segment2, segment1, segment3]),\n                np.concatenate([segment1, segment3, segment2]),\n                np.concatenate([segment3, segment1, segment2]),\n                np.concatenate([segment1[::-1], segment2, segment3]),\n                np.concatenate([segment2[::-1], segment1, segment3]),\n                np.concatenate([segment3[::-1], segment1, segment2])\n            ]\n            new_segment = random.choice(options)\n            new_solution[i:l] = new_segment\n        else:  # Probabilistic segment relocation\n            if random.random() < 0.5:\n                new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[l:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j], segment3, segment2, new_solution[k:]])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8882747956793511,
            0.18436086177825928
        ]
    }
]