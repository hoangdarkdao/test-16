[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(i, j)\n\n    # Rotate the segment\n    segment = new_solution[i:j+1]\n    rotated = np.concatenate([segment[k-i:], segment[:k-i]])\n    new_solution[i:j+1] = rotated\n\n    # Step 2: Randomly insert an edge from another position\n    if n > 3:\n        l = random.randint(0, n - 1)\n        m = random.randint(0, n - 1)\n        if l != m:\n            # Check if insertion is possible without violating TSP constraints\n            if abs(l - m) > 1:\n                # Perform edge insertion\n                new_solution = np.concatenate([\n                    new_solution[:l+1],\n                    [new_solution[m]],\n                    new_solution[l+1:m],\n                    new_solution[m+1:]\n                ])\n\n    return new_solution\n\n",
        "score": [
            7.318156184403801,
            6.8539898735067615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(i, j)\n\n    # Rotate the segment\n    segment = new_solution[i:j+1]\n    rotated = np.concatenate([segment[k-i:], segment[:k-i]])\n    new_solution[i:j+1] = rotated\n\n    # Step 2: Randomly insert an edge from another position\n    if n > 3:\n        l = random.randint(0, n - 1)\n        m = random.randint(0, n - 1)\n        if l != m:\n            # Check if insertion is possible without violating TSP constraints\n            if abs(l - m) > 1:\n                # Perform edge insertion\n                new_solution = np.concatenate([\n                    new_solution[:l+1],\n                    [new_solution[m]],\n                    new_solution[l+1:m],\n                    new_solution[m+1:]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_score = float('inf')\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]  # Combined objective score\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator with improved segment selection\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply a more sophisticated edge exchange\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            5.88822348764381,
            6.246387417194596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_score = float('inf')\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]  # Combined objective score\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator with improved segment selection\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply a more sophisticated edge exchange\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate Pareto dominance and diversity metrics\n    dominance = []\n    diversity = []\n    for sol, (obj1, obj2) in archive:\n        # Dominance: count how many solutions this solution dominates\n        count = 0\n        for _, (o1, o2) in archive:\n            if (obj1 < o1 and obj2 <= o2) or (obj1 <= o1 and obj2 < o2):\n                count += 1\n        dominance.append(count)\n\n        # Diversity: sum of distances to other solutions in objective space\n        div = 0\n        for _, (o1, o2) in archive:\n            div += np.sqrt((obj1 - o1)**2 + (obj2 - o2)**2)\n        diversity.append(div)\n\n    # Normalize metrics\n    max_dom = max(dominance) if max(dominance) != 0 else 1\n    max_div = max(diversity) if max(diversity) != 0 else 1\n    normalized = [(dom/max_dom + div/max_div) for dom, div in zip(dominance, diversity)]\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(normalized)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a novel hybrid local search operator\n    # Step 1: Select a random segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotated = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated\n\n    # Step 2: Randomly select two non-adjacent edges and swap them\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 2, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[l-1], new_solution[l]])\n    new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[k]])\n\n    current_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[l-1], new_solution[l]])\n    new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[k]])\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.806782804678528,
            7.3953119278815596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate Pareto dominance and diversity metrics\n    dominance = []\n    diversity = []\n    for sol, (obj1, obj2) in archive:\n        # Dominance: count how many solutions this solution dominates\n        count = 0\n        for _, (o1, o2) in archive:\n            if (obj1 < o1 and obj2 <= o2) or (obj1 <= o1 and obj2 < o2):\n                count += 1\n        dominance.append(count)\n\n        # Diversity: sum of distances to other solutions in objective space\n        div = 0\n        for _, (o1, o2) in archive:\n            div += np.sqrt((obj1 - o1)**2 + (obj2 - o2)**2)\n        diversity.append(div)\n\n    # Normalize metrics\n    max_dom = max(dominance) if max(dominance) != 0 else 1\n    max_div = max(diversity) if max(diversity) != 0 else 1\n    normalized = [(dom/max_dom + div/max_div) for dom, div in zip(dominance, diversity)]\n\n    # Select solution with highest combined score\n    selected_idx = np.argmax(normalized)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a novel hybrid local search operator\n    # Step 1: Select a random segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotated = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated\n\n    # Step 2: Randomly select two non-adjacent edges and swap them\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 2, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_1[new_solution[l-1], new_solution[l]])\n    new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[k]])\n\n    current_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                      distance_matrix_2[new_solution[l-1], new_solution[l]])\n    new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[k]])\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    }
]