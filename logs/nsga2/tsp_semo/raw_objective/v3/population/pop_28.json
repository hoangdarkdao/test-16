[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            4.206923218193344,
            10.795075673160595
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.641110317370018,
            4.309974453390293
        ]
    }
]