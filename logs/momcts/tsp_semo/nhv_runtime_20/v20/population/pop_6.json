[
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the lowest combined objective value) and applies a novel 4-opt-inspired local search by randomly selecting four edges and reconnecting them in a non-standard way to explore higher-quality neighborhoods, ensuring feasibility by reversing segments and maintaining a circular tour. The key design idea is to prioritize the most promising solution while introducing diversity through a creative edge-reconnection strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[l:j+1][::-1],\n        new_solution[k:l+1][::-1],\n        new_solution[j+1:k+1],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9964296678185147,
            0.10547882318496704
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest combined objective) and applies a novel 4-opt-inspired local search by randomly selecting four edges, reversing segments between them, and reconnecting them to explore a larger neighborhood while ensuring feasibility. It prioritizes solutions with lower total cost and dynamically modifies the tour by segment reversal and concatenation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    # This ensures feasibility while exploring a new neighborhood\n    new_solution = np.concatenate([\n        new_solution[:a+1],\n        new_solution[b:c+1][::-1],\n        new_solution[d:],\n        new_solution[a+1:b+1][::-1],\n        new_solution[c+1:d+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9715020941909596,
            0.14212608337402344
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the sum of objectives) and applies a hybrid local search combining edge insertion (moving a node to a new position) and node swapping (exchanging two nodes) to generate a neighbor solution while ensuring feasibility by checking for duplicate nodes. The design prioritizes solutions with lower combined objective values and uses random segment selection to explore the solution space.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower combined objective)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: edge insertion + node swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge insertion: move a random node to a new position\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node_to_move], new_solution[j+1:]])\n\n    # Node swap: swap two random nodes\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.905185401510344,
            1.402988612651825
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (based on normalized objective scores) and applies a hybrid local search combining 3-opt moves with an edge-selection mechanism. It prioritizes solutions with higher combined objective values and uses random edge modifications to explore neighboring solutions while ensuring feasibility. The edge-selection step evaluates swaps between random edges and the 3-opt segment, accepting improvements in both objectives to generate high-quality neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move\n    if np.random.rand() < 0.5:\n        # Case 1: Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Case 2: Reverse segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Edge selection mechanism: choose the best edge to include\n    for _ in range(5):  # Limit iterations to avoid long computation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a == b:\n            continue\n\n        # Evaluate the impact of swapping edges a-b and i-j\n        old_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[i]] + distance_matrix_1[new_solution[b], new_solution[j]]\n\n        old_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[i]] + distance_matrix_2[new_solution[b], new_solution[j]]\n\n        if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n            # Perform the swap\n            new_solution[a], new_solution[i] = new_solution[i], new_solution[a]\n            new_solution[b], new_solution[j] = new_solution[j], new_solution[b]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9267165987309169,
            2.00429505109787
        ]
    },
    {
        "algorithm": "The heuristic selects the solution with the highest combined objective value from the archive, then applies a novel 3-opt-inspired local search by randomly selecting three edges and reconnecting them in a way that maintains feasibility while exploring higher-quality neighborhoods. The algorithm prioritizes solutions with worse combined objectives (sum of both costs) to focus on less explored regions, and ensures the generated neighbor remains a valid TSP tour by reversing segments of the path and reconnecting them.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 3-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to reconnect\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Create a new tour by reconnecting the edges in a different order\n    # This ensures feasibility while exploring a new neighborhood\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[j:k+1][::-1],\n        new_solution[k+1:],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.8796892138585624,
            0.27913469076156616
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a combined metric of cost and diversity, then applies a hybrid local search combining segment reversal and edge insertion to generate a feasible neighbor solution while ensuring no nodes are skipped or revisited. The selection prioritizes solutions with lower costs and higher diversity, while the local search operates on randomly chosen segments to explore the solution space creatively. The algorithm maintains feasibility by checking for duplicates and reverting invalid moves.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_criteria(sol_obj):\n        # Prefer solutions with lower costs and higher diversity\n        cost1, cost2 = sol_obj[1]\n        diversity = np.sum(np.abs(distance_matrix_1[sol_obj[0][:-1], sol_obj[0][1:]] - distance_matrix_2[sol_obj[0][:-1], sol_obj[0][1:]]))\n        return (cost1 + cost2) / diversity\n\n    archive_sorted = sorted(archive, key=selection_criteria)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    k, l = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Perform segment reversal\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    # Randomly insert a segment between two points\n    if n > 3:\n        a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(1, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8341203722535285,
            2.780918836593628
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search: first reversing a random segment of the tour (like 2-opt) and then rotating the segment to explore a more diverse neighborhood while ensuring feasibility. The selection strategy focuses on high-quality solutions, while the novel local search combines segment reversal and rotation to escape local optima effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower combined objective)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Segment reversal (similar to 2-opt)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment rotation: rotate the segment by a random amount\n    k = np.random.randint(1, j-i+1)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7527095184899617,
            0.7415230870246887
        ]
    },
    {
        "algorithm": "The algorithm selects a nondominated solution from the archive, applies adaptive segment selection to dynamically adjust segment sizes based on objective diversity, and uses a hybrid edge-selection mechanism to explore high-quality neighborhoods while ensuring feasibility. The selection prioritizes solutions on the Pareto front, while the local search dynamically balances segment size and edge swaps to improve both objectives. The hybrid approach combines segment reversal and edge-based swaps, with a focus on reducing total cost across both spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a nondominated solution (Pareto front)\n    objectives = np.array([obj for _, obj in archive])\n    nondominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j] <= objectives[i]).all():\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append(i)\n\n    if not nondominated:\n        selected_idx = np.argmin(objectives.sum(axis=1))\n    else:\n        selected_idx = random.choice(nondominated)\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Adaptive segment selection based on objective diversity\n    obj_diversity = objectives.std(axis=0).sum()\n    segment_size = max(2, int(obj_diversity / (objectives.max() - objectives.min()).sum() * len(base_solution) / 2))\n\n    # Hybrid local search with dynamic segment size\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments to modify\n    i = np.random.randint(0, n - segment_size)\n    j = i + segment_size\n\n    # Reverse segment to explore new neighborhoods\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge selection mechanism with dynamic evaluation\n    for _ in range(min(3, n // 2)):  # Limit iterations for efficiency\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a == b:\n            continue\n\n        # Evaluate the impact of swapping edges\n        old_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[i]] + distance_matrix_1[new_solution[b], new_solution[j]]\n\n        old_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[i]] + distance_matrix_2[new_solution[b], new_solution[j]]\n\n        if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n            # Perform the swap\n            new_solution[a], new_solution[i] = new_solution[i], new_solution[a]\n            new_solution[b], new_solution[j] = new_solution[j], new_solution[b]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8733659506046769,
            9.661152005195618
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on its combined normalized improvement potential across both objectives, then applies a hybrid local search combining random segment shuffling and segment reordering to generate a neighbor solution while ensuring feasibility. It prioritizes solutions with higher combined costs relative to the total possible costs in both spaces, and the local search operates by randomly perturbing segments of the tour to explore the solution space. The method avoids 2-opt by using more disruptive segment-based operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement\n    selected_idx = np.argmax([(obj[0] + obj[1]) / (np.sum(distance_matrix_1) + np.sum(distance_matrix_2)) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment reordering\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Edge insertion\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    if j - i > 1:\n        segment = new_solution[i:j]\n        np.random.shuffle(segment)\n        new_solution[i:j] = segment\n\n    # Step 2: Segment reordering\n    k, l = np.random.choice(n, size=2, replace=False)\n    k, l = min(k, l), max(k, l)\n    if l - k > 1:\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.8246578651118661,
            3.99768728017807
        ]
    }
]