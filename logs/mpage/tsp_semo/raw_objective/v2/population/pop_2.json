[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Step 2: Hybrid local search (edge insertion + node reordering)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reorder\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n - 1)\n\n    # Reverse the segment (node reordering)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly insert a node elsewhere (edge insertion)\n    node_to_insert = new_solution[end]\n    new_solution = np.delete(new_solution, end)\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
          "score": [
               6.0500135980359975,
               6.09537249265896
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (high ratio of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)  # Avoid division by zero\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge exchange followed by segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: Swap two edges if it improves both objectives\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n\n        # Calculate new objectives\n        old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n           (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n            new_solution = candidate\n            break\n\n    # Segment reversal: Reverse a random segment if it improves the solution\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Calculate new objectives\n    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n    # Accept if both objectives improve or one improves significantly\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n       (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n       (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n        new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               7.938052437621909,
               4.974250410098344
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating each solution's potential for improvement using a combination of objective values and diversity measures. It then applies a novel hybrid local search operator that combines a modified version of the Lin-Kernighan heuristic with a variable-length segment relocation strategy. The operator randomly selects a segment of nodes in the tour and relocates it to a new position while considering both objective spaces, ensuring feasibility by maintaining the TSP constraints. The selection of the segment length and insertion point is guided by a probabilistic approach that balances exploration and exploitation, favoring segments that show high potential for reducing both objectives. The function returns the new neighbor solution after validating its feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([(cost1 + cost2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2)) for _, (cost1, cost2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment length (1 to n//2)\n    segment_length = random.randint(1, n // 2)\n\n    # Randomly select a starting position for the segment\n    start_pos = random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Find the best insertion position considering both objectives\n    best_insert_pos = 0\n    best_cost = float('inf')\n\n    for insert_pos in range(len(new_solution)):\n        # Insert the segment at the current position\n        candidate = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Calculate the total cost in both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Combine the costs with a weighted sum\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = insert_pos\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n",
          "score": [
               6.11088345881558,
               5.468006696741405
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a solution with good potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 2:\n        # Exclude the top 20% and bottom 20% to focus on middle-range solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        start_idx = int(0.2 * len(sorted_archive))\n        end_idx = int(0.8 * len(sorted_archive))\n        selected_solution = random.choice(sorted_archive[start_idx:end_idx])[0].copy()\n    else:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment-based perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select 3 non-adjacent edges to perform a 3-opt move\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect the segments in a new order\n    candidates = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment2, segment3, segment4[::-1]]),\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n    ]\n\n    # Evaluate all candidates based on both objectives\n    best_neighbor = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_neighbor = candidate.copy()\n\n    # Step 2: Apply novel segment-based perturbation if 3-opt didn't improve\n    if best_neighbor is None or np.array_equal(best_neighbor, new_solution):\n        # Randomly select a segment and reverse it, then insert elsewhere\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n        insert_pos = random.randint(0, len(remaining))\n        best_neighbor = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    return best_neighbor\n\n",
          "score": [
               6.711106193981905,
               5.67906101484736
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with the best Pareto front dominance or highest diversity\n    def dominance_score(sol_obj):\n        # Simple dominance score: higher if solution is better in both objectives\n        # or has higher diversity (sum of objectives)\n        return -(sol_obj[0] + sol_obj[1])  # Negative for minimization\n\n    # Select the solution with the highest score\n    selected_sol = max(archive, key=lambda x: dominance_score(x[1]))[0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: restricted 3-opt with dynamic edge exchange\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Select three random segments\n        i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n        # Try different segment orderings to find improvement\n        for perm in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n            # Create new solution with this permutation\n            temp_sol = new_solution.copy()\n            temp_sol[perm[0]:perm[1]] = np.flip(temp_sol[perm[0]:perm[1]])\n            temp_sol[perm[1]:perm[2]] = np.flip(temp_sol[perm[1]:perm[2]])\n\n            # Calculate new objectives\n            new_obj1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n            new_obj2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n\n            # Accept if better in at least one objective\n            current_obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n            current_obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n\n            if (new_obj1 < current_obj1) or (new_obj2 < current_obj2):\n                new_solution = temp_sol\n                break  # Move to next iteration with improved solution\n\n    # Dynamic edge exchange: swap edges based on their contribution to objectives\n    for _ in range(3):\n        # Select two random edges to swap\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+1, n-1)\n\n        # Create candidate solution\n        temp_sol = new_solution.copy()\n        temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n        new_obj2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n\n        # Accept if better in at least one objective\n        current_obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n        current_obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n\n        if (new_obj1 < current_obj1) or (new_obj2 < current_obj2):\n            new_solution = temp_sol\n\n    return new_solution\n\n",
          "score": [
               6.225234873057076,
               6.449669128850349
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first intelligently selects a promising solution from the archive by prioritizing those with objective values that are not dominated by others, ensuring diverse exploration. It then applies a hybrid local search strategy that combines edge insertion with a novel adaptive segment reversal, where segments of varying lengths are dynamically chosen based on the solution's current quality and the instance's structure. The segment reversal is guided by a combination of distance improvements in both objective spaces, with a probabilistic acceptance criterion to escape local optima. The function ensures feasibility by maintaining a valid tour structure throughout the operations, and returns the improved neighbor solution with minimized costs in both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Filter non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select a solution with probability inversely proportional to its objective values\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in non_dominated]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(non_dominated), p=probabilities)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion + adaptive segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], new_solution[i:i+1], new_solution[j+1:]])\n\n    # Adaptive segment reversal\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    reversed_segment = new_solution[start:end][::-1]\n    candidate = np.concatenate([new_solution[:start], reversed_segment, new_solution[end:]])\n\n    new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n    # Accept if improvement in at least one objective\n    if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n        new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.390271291741203,
               6.972964363171967
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-phase approach that combines a novel \"objective-space aware\" node swapping mechanism with a dynamic segment inversion strategy. It first identifies a solution with balanced objective values by analyzing the Pareto front and then applies a hybrid operator that selectively swaps nodes based on their relative positions in both objective spaces, followed by an adaptive segment inversion where the segment length and position are determined by analyzing the solution's current structure and the distribution of nodes in the two spaces. The operator includes a probabilistic acceptance criterion that considers both objective improvements and spatial coherence in the two spaces, ensuring the solution remains feasible while exploring the trade-off between the objectives more effectively than standard methods.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Phase 1: Select a solution with balanced objectives\n    objectives = [obj for _, obj in archive]\n    obj1_mean = sum(o[0] for o in objectives) / len(objectives)\n    obj2_mean = sum(o[1] for o in objectives) / len(objectives)\n\n    balanced_solutions = []\n    for sol, obj in archive:\n        if (obj[0] <= obj1_mean and obj[1] <= obj2_mean) or (obj[0] >= obj1_mean and obj[1] >= obj2_mean):\n            balanced_solutions.append(sol)\n\n    if not balanced_solutions:\n        balanced_solutions = [sol for sol, _ in archive]\n\n    base_solution = random.choice(balanced_solutions).copy()\n\n    # Phase 2: Objective-space aware node swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate node positions in both spaces\n    node_positions = []\n    for node in new_solution:\n        x1, y1, x2, y2 = instance[node]\n        node_positions.append(((x1, y1), (x2, y2)))\n\n    # Select nodes based on their relative positions in both spaces\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        pos_i1, pos_i2 = node_positions[i]\n        pos_j1, pos_j2 = node_positions[j]\n\n        # Swap if nodes are closer in one space but farther in the other\n        swap = False\n        if (distance_matrix_1[i, j] < distance_matrix_1[new_solution[i-1], new_solution[i]] and\n            distance_matrix_2[i, j] > distance_matrix_2[new_solution[i-1], new_solution[i]]):\n            swap = True\n        elif (distance_matrix_1[i, j] > distance_matrix_1[new_solution[i-1], new_solution[i]] and\n              distance_matrix_2[i, j] < distance_matrix_2[new_solution[i-1], new_solution[i]]):\n            swap = True\n\n        if swap:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            node_positions[i], node_positions[j] = node_positions[j], node_positions[i]\n\n    # Phase 3: Adaptive segment inversion\n    segment_length = random.randint(2, min(5, n // 3))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Calculate potential improvement\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    reversed_segment = new_solution[start:end][::-1]\n    candidate = np.concatenate([new_solution[:start], reversed_segment, new_solution[end:]])\n\n    new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n    # Accept if improvement in at least one objective or probabilistic acceptance\n    if (new_cost1 < current_cost1 or new_cost2 < current_cost2) or random.random() < 0.2:\n        new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.7102064420452905,
               6.7557899101619885
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions\n    non_dominated = []\n    objectives = [obj for _, obj in archive]\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a base solution with weighted randomness\n    weights = []\n    for sol, obj in non_dominated:\n        # Calculate diversity score (distance to other solutions)\n        diversity = 0.0\n        for other_sol, _ in non_dominated:\n            diversity += np.sum(sol != other_sol)\n        weights.append(1.0 / (1.0 + diversity))\n\n    weights = np.array(weights)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(non_dominated), p=weights)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment size based on current objective values\n    obj1, obj2 = non_dominated[selected_idx][1]\n    max_obj = max(obj1, obj2)\n    segment_size = max(3, min(n // 2, int(n * (max_obj / (max_obj + 1)))))\n\n    # 3-opt with adaptive segment inversion\n    if n >= 3:\n        # Select random segment\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Apply adaptive inversion\n        if np.random.rand() < 0.7:  # Higher probability for inversion\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Random swap within segment\n            i, j = np.random.choice(range(start, end), 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.950788573605236,
               6.759382533501396
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Non-dominated sorting to find Pareto front\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    # Select from top 20% of non-dominated solutions\n    if not pareto_front:\n        base_solution = archive[random.randint(0, len(archive) - 1)][0].copy()\n    else:\n        top_k = max(1, int(0.2 * len(pareto_front)))\n        selected = random.choice(pareto_front[:top_k])\n        base_solution = selected[0].copy()\n\n    # Novel local search operator: Segment-based crossover with inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-overlapping segments\n    seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n    seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and non-overlapping\n    while (seg1_start <= seg2_end and seg1_end >= seg2_start):\n        seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n        seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n\n    # Extract segments and invert one of them\n    seg1 = new_solution[seg1_start:seg1_end + 1]\n    seg2 = new_solution[seg2_start:seg2_end + 1]\n\n    if random.random() < 0.5:\n        seg1 = seg1[::-1]\n\n    # Reconstruct the solution by combining segments in a new order\n    new_order = []\n    if seg1_start < seg2_start:\n        new_order.extend(new_solution[:seg1_start])\n        new_order.extend(seg1)\n        new_order.extend(new_solution[seg1_end+1:seg2_start])\n        new_order.extend(seg2)\n        new_order.extend(new_solution[seg2_end+1:])\n    else:\n        new_order.extend(new_solution[:seg2_start])\n        new_order.extend(seg2)\n        new_order.extend(new_solution[seg2_end+1:seg1_start])\n        new_order.extend(seg1)\n        new_order.extend(new_solution[seg1_end+1:])\n\n    new_solution = np.array(new_order)\n\n    # Validate the new solution\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Invalid tour: Duplicate nodes detected.\")\n\n    return new_solution\n\n",
          "score": [
               7.039117501558234,
               6.769378483480521
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection of high-diversity solutions from the first approach with a novel multi-objective segment inversion strategy inspired by the second approach. It first identifies solutions with significant edge diversity across both objective spaces, then applies a segment inversion operator that flips variable-length segments of the tour while considering both objectives, using a multi-objective acceptance criterion that prioritizes solutions improving at least one objective while maintaining or improving the other. The segment inversion dynamically adjusts the segment length based on local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure, and incorporates a directed edge swapping mechanism to further refine the solution while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest edge diversity\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, _) in enumerate(archive):\n        edges = [(sol[j], sol[(j+1)%len(sol)]) for j in range(len(sol))]\n        diversity = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] for e in edges)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective segment inversion\n    for _ in range(5):\n        segment_length = min(3, n // 3)\n        start = np.random.randint(n - segment_length)\n        end = start + segment_length\n\n        # Invert the segment\n        inverted_segment = base_solution[start:end][::-1]\n        temp_solution = np.concatenate([\n            base_solution[:start],\n            inverted_segment,\n            base_solution[end:]\n        ])\n\n        # Calculate costs\n        current_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            base_solution = temp_solution.copy()\n\n    # Directed edge swapping\n    for _ in range(10):\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i == j:\n            continue\n\n        # Get current edges\n        prev_i = base_solution[i-1] if i > 0 else base_solution[-1]\n        next_i = base_solution[(i+1)%n]\n        prev_j = base_solution[j-1] if j > 0 else base_solution[-1]\n        next_j = base_solution[(j+1)%n]\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[prev_i, base_solution[i]] + distance_matrix_1[base_solution[i], next_i] + \\\n                       distance_matrix_1[prev_j, base_solution[j]] + distance_matrix_1[base_solution[j], next_j]\n        current_cost2 = distance_matrix_2[prev_i, base_solution[i]] + distance_matrix_2[base_solution[i], next_i] + \\\n                       distance_matrix_2[prev_j, base_solution[j]] + distance_matrix_2[base_solution[j], next_j]\n\n        # Swap edges\n        temp_solution = base_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate new edges\n        new_prev_i = temp_solution[i-1] if i > 0 else temp_solution[-1]\n        new_next_i = temp_solution[(i+1)%n]\n        new_prev_j = temp_solution[j-1] if j > 0 else temp_solution[-1]\n        new_next_j = temp_solution[(j+1)%n]\n\n        new_cost1 = distance_matrix_1[new_prev_i, temp_solution[i]] + distance_matrix_1[temp_solution[i], new_next_i] + \\\n                   distance_matrix_1[new_prev_j, temp_solution[j]] + distance_matrix_1[temp_solution[j], new_next_j]\n        new_cost2 = distance_matrix_2[new_prev_i, temp_solution[i]] + distance_matrix_2[temp_solution[i], new_next_i] + \\\n                   distance_matrix_2[new_prev_j, temp_solution[j]] + distance_matrix_2[temp_solution[j], new_next_j]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            base_solution = temp_solution.copy()\n\n    return base_solution\n\n",
          "score": [
               7.5596551241132355,
               7.260127612593887
          ]
     }
]