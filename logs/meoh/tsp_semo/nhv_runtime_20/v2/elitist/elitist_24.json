[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9366182031389043,
            0.07236099243164062
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9899725544167229,
            0.129022479057312
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9893647956588854,
            0.07638520002365112
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9955756972706151,
            0.19696515798568726
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.009750535007263,
            0.3081088066101074
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8925259502193565,
            0.07236272096633911
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 6:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(3, min(7, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 10:\n            first_start = np.random.randint(0, n//2 - 3)\n            first_length = np.random.randint(3, min(7, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9834202800315652,
            0.0740630030632019
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9899725544167229,
            0.129022479057312
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9893647956588854,
            0.07638520002365112
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9366182031389043,
            0.07236099243164062
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9893647956588854,
            0.07638520002365112
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-objective segment swap\" with \"adaptive edge inversion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize solutions with balanced objectives and high diversity\n    sorted_archive = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment swap\n    if n > 4:\n        segment_length = np.random.randint(2, min(6, n//2))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n\n        # Calculate segment costs before swap\n        original_segment1 = new_solution[start1:start1+segment_length]\n        original_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_before = sum(distance_matrix_1[original_segment1[i], original_segment1[i+1]] for i in range(len(original_segment1)-1)) + \\\n                       sum(distance_matrix_2[original_segment2[i], original_segment2[i+1]] for i in range(len(original_segment2)-1))\n\n        # Perform swap\n        new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n        new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n        swapped_segment1 = new_solution[start1:start1+segment_length]\n        swapped_segment2 = new_solution[start2:start2+segment_length]\n\n        cost1_after = sum(distance_matrix_1[swapped_segment1[i], swapped_segment1[i+1]] for i in range(len(swapped_segment1)-1)) + \\\n                     sum(distance_matrix_2[swapped_segment2[i], swapped_segment2[i+1]] for i in range(len(swapped_segment2)-1))\n\n        # Revert if swap doesn't improve both objectives\n        if cost1_after >= cost1_before:\n            new_solution[start1:start1+segment_length], new_solution[start2:start2+segment_length] = \\\n            new_solution[start2:start2+segment_length], new_solution[start1:start1+segment_length]\n\n    # Adaptive edge inversion\n    if n > 6:\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            if i != j:\n                # Calculate edge costs before inversion\n                original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Invert edges\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                # Calculate edge costs after inversion\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Revert if inversion doesn't improve both objectives\n                if (new_cost1 >= original_cost1) or (new_cost2 >= original_cost2):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9899725544167229,
            0.129022479057312
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9893647956588854,
            0.07638520002365112
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9893647956588854,
            0.07638520002365112
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9893647956588854,
            0.07638520002365112
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive node sequence reordering\" with \"objective-biased segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive node sequence reordering with objective-biased segment insertion\n    if n > 4:\n        # Adaptive node sequence reordering\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reorder nodes in segment based on objective dominance\n        if segment_cost1 > segment_cost2:\n            segment = sorted(segment, key=lambda x: instance[x, 0] + instance[x, 1])\n        else:\n            segment = sorted(segment, key=lambda x: instance[x, 2] + instance[x, 3])\n\n        new_solution[start:start+segment_length] = segment\n\n        # Objective-biased segment insertion\n        if n > 8:\n            insert_length = np.random.randint(2, min(5, n//2))\n            insert_segment = new_solution[:insert_length]\n\n            # Calculate insertion cost in both objectives\n            insert_cost1 = sum(distance_matrix_1[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n            insert_cost2 = sum(distance_matrix_2[insert_segment[i], insert_segment[i+1]] for i in range(len(insert_segment)-1))\n\n            # Insert segment at a position that improves the weaker objective\n            if insert_cost1 > insert_cost2:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n            else:\n                insert_pos = np.random.randint(insert_length, n - insert_length)\n                new_solution = np.concatenate([new_solution[:insert_pos], insert_segment, new_solution[insert_pos:]])\n                new_solution = np.concatenate([new_solution[:n], new_solution[n:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9893647956588854,
            0.07638520002365112
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    }
]