[
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing those with the lowest sum of normalized objectives, then applies a hybrid local search combining edge swapping and node insertion to explore diverse neighborhoods while ensuring feasibility. The selection is based on normalized objective values to balance trade-offs between the two objectives, while the local search operates on randomly chosen segments of the tour to avoid getting stuck in local optima. The critical design ideas are the intelligent selection of solutions and the hybrid local search strategy, which together aim to improve solution quality across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select segments to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge swap between i-j and k-l\n    new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    # Node insertion: move a random node to a new position\n    node_to_move = np.random.choice(new_solution)\n    pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    if pos != new_pos:\n        new_solution = np.insert(np.delete(new_solution, pos), new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8179669842566333,
            0.3183813691139221
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a promising solution from the archive by prioritizing balanced objectives (40% weight for the first cost, 60% for the second) and randomly applies either a node swap or a path reversal to generate a neighbor, ensuring feasibility by verifying no nodes are duplicated or missing. The method balances exploration and exploitation by favoring more balanced solutions and using a hybrid local search strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower weighted objectives (prioritize balanced solutions)\n    archive_sorted = sorted(archive, key=lambda x: (0.4 * x[1][0] + 0.6 * x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)  # Select from top 5 or all if fewer\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    # Hybrid local search: combine node swaps and path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between swap or path reversal\n    if random.random() < 0.6:\n        # Node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Path reversal between two random indices\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.9229999080145157,
            1.1371864676475525
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-dominance-based selection, prioritizing non-dominated solutions, then applies a hybrid local search operator that combines segment rotation and edge insertion to generate a neighbor solution while ensuring feasibility by validating the tour and reverting to the original if invalid. The segment size and rotation are randomized to balance diversification and intensification, with the solution's objective values implicitly guiding the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance based selection\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj[0] and obj_j[1] <= obj[1] and (obj_j[0] < obj[0] or obj_j[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = random.choice(pareto_front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation and edge insertion\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Rotate the segment\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert the rotated segment back\n    remaining = np.delete(new_solution, range(start, start + segment_length))\n    best_pos = random.randint(0, len(remaining))\n\n    # Insert the rotated segment at the best position\n    new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    # Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9319700699839684,
            1.4907165169715881
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using inverse lexicographical ordering, then applies a hybrid local search combining adaptive segment relocations, probabilistic edge crossings, and dynamic node swaps with varying segment sizes and insertion probabilities to explore the solution space more thoroughly. The selection prioritizes solutions with better objectives, while the local search operators dynamically adjust their intensity based on segment costs and random probabilities to ensure diverse exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with inverse lexicographical ordering of objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = sorted_indices[np.random.randint(0, min(3, len(sorted_indices)))]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with dynamic size\n    segment_size = random.randint(3, min(6, n//3))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    remaining = np.delete(new_solution, range(start, start+segment_size))\n\n    # Calculate segment's contribution to objectives\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_size))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_size))\n\n    # Dynamic insertion with probability based on segment cost\n    insertion_prob = min(0.9, 0.4 + (seg_cost1 + seg_cost2) / (sum(distance_matrix_1.flatten()) + sum(distance_matrix_2.flatten()) + 1e-10))\n    if random.random() < insertion_prob:\n        best_pos = random.randint(0, len(remaining))\n        new_solution = np.insert(remaining, best_pos, segment)\n    else:\n        new_solution = np.concatenate([remaining, segment])\n\n    # Probabilistic edge crossing\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            k = random.randint(i+1, j-1)\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:j], new_solution[i:k], new_solution[j:]])\n\n    # Dynamic node swaps with varying segment sizes\n    if random.random() < 0.4:\n        swap_size = random.randint(1, min(3, n//4))\n        i = random.randint(0, n - swap_size)\n        j = random.randint(0, n - swap_size)\n        if abs(i - j) >= swap_size:\n            temp = new_solution[i:i+swap_size].copy()\n            new_solution[i:i+swap_size] = new_solution[j:j+swap_size]\n            new_solution[j:j+swap_size] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9692505333613919,
            1.5506538152694702
        ]
    },
    {
        "algorithm": "The algorithm selects nondominated solutions with inverse Pareto rank probability, then applies a hybrid local search combining cost-aware segment rotations (prioritizing high-cost-ratio segments) and adaptive edge flips (prioritizing cost-improving flips), ensuring feasibility through permutation checks. The method balances exploration (via segment rotation) and exploitation (via edge flips) while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto ranking and selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    ranks = np.zeros(len(objectives))\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                ranks[i] += 1\n\n    # Select with inverse rank probability\n    selected_idx = np.random.choice(np.where(ranks == np.min(ranks))[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cost-aware segment rotation\n    segment_length = random.randint(3, min(7, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Calculate segment cost ratios\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n    cost_ratio = seg_cost1 / (seg_cost2 + 1e-10)\n\n    # Rotate based on cost ratio\n    rotation = random.randint(1, segment_length-1)\n    if cost_ratio > 1.3:\n        rotation = -rotation\n    rotated_segment = np.roll(segment, rotation)\n\n    # Find best insertion position\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, rotated_segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + 0.6 * cost2  # Weighted sum\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    # Adaptive edge flips\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            seg_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            seg_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            flip_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            flip_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n            if (flip_cost1 + flip_cost2) < (seg_cost1 + seg_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        return base_solution\n    return new_solution\n\n",
        "score": [
            -1.017532167337836,
            4.72875714302063
        ]
    },
    {
        "algorithm": "The algorithm selects promising solutions from the archive using Pareto dominance and weighted probability, then applies a hybrid local search strategy that prioritizes flipping high-cost-ratio edges, adaptively rotates segments, and probabilistically swaps nodes to improve both objectives while ensuring feasibility. It balances exploitation of edge costs with exploration through segment rotations and node swaps, dynamically adjusting the search based on edge cost ratios and randomness.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (sol, obj) in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    normalized = (objectives[pareto_front] - objectives[pareto_front].min(axis=0)) / (objectives[pareto_front].max(axis=0) - objectives[pareto_front].min(axis=0) + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    weights = 1 / (scores + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(pareto_front, p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high cost ratios\n    edge_costs = []\n    for i in range(n):\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        ratio = max(cost1 / (cost2 + 1e-10), cost2 / (cost1 + 1e-10))\n        edge_costs.append((i, ratio))\n    edge_costs.sort(key=lambda x: -x[1])\n\n    # Flip edges with high ratios with probability inversely proportional to ratio\n    for i, ratio in edge_costs[:max(2, n//5)]:\n        if random.random() < 1 / (ratio + 1):\n            new_solution[i-1], new_solution[i] = new_solution[i], new_solution[i-1]\n\n    # Adaptive segment rotation\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Rotate segment\n    rotation = random.randint(1, segment_length-1)\n    rotated_segment = np.roll(segment, rotation)\n\n    # Find best insertion point\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, rotated_segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    # Probabilistic node swaps\n    for _ in range(min(3, n//4)):\n        a, b = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9792176250002724,
            4.461400032043457
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined objective costs (weighted 60% for the first objective and 40% for the second), then applies a hybrid local search that randomly chooses between segment reversal (reversing a random segment of the tour) or edge swapping (swapping two non-adjacent edges) to generate a neighbor solution, ensuring feasibility by checking for duplicate nodes. The selection process biases toward high-potential solutions, while the local search diversifies exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective (exponential weighting)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    selected_idx = min(15, len(archive_sorted) - 1)\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal or edge swapping\n    if random.random() < 0.6:\n        # Segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge swapping\n        if n >= 4:\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify solution validity\n    assert len(new_solution) == len(selected_solution), \"Solution length mismatch\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes detected\"\n\n    return new_solution\n\n",
        "score": [
            -0.9076585486137072,
            1.1378300786018372
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted probability favoring solutions with lower average normalized objective values, then applies either a standard 2-opt operation or a novel segment inversion/reinsertion strategy to generate a neighbor solution while ensuring feasibility. The segment operation specifically inverts a random segment of the tour and reinserts it at the best position to minimize the combined cost of both objectives, providing a more exploratory local search compared to pure 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = objectives - objectives.min(axis=0)\n    normalized = normalized / (normalized.max(axis=0) + 1e-10)\n    weights = 1 - normalized.mean(axis=1)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 2-opt and segment inversion/reinsertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or segment operation\n    if random.random() < 0.5:\n        # 2-opt operation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment inversion and reinsertion\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.delete(new_solution, range(start, start+segment_length))\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Find best insertion point for inverted segment\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) + 1):\n            temp_solution = np.insert(remaining, pos, inverted_segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(remaining, best_pos, inverted_segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9353011851346344,
            1.5762245655059814
        ]
    },
    {
        "algorithm": "The algorithm selects nondominated solutions from the archive with probability inversely proportional to their Pareto rank, then applies a hybrid local search combining segment rotation (prioritizing high-cost-ratio segments) and adaptive edge flips (selectively reversing edges with improved total cost), while ensuring feasibility through validation. The segment rotation step weights the first objective more heavily (0.7) in the cost calculation, while edge flips consider both objectives equally in their improvement criterion. This balances exploration of high-potential segments with targeted local improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto ranking and selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    ranks = np.zeros(len(objectives))\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                ranks[i] += 1\n    selected_idx = np.random.choice(np.where(ranks == np.min(ranks))[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation with cost-aware prioritization\n    segment_length = random.randint(3, min(7, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Calculate segment cost ratios\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n    cost_ratio = seg_cost1 / (seg_cost2 + 1e-10)\n\n    # Rotate based on cost ratio\n    rotation = random.randint(1, segment_length-1)\n    if cost_ratio > 1.5:\n        rotation = -rotation\n    rotated_segment = np.roll(segment, rotation)\n\n    # Find best insertion position\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, rotated_segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + 0.7 * cost2  # Weighted sum\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    # Adaptive edge flips\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            seg_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            seg_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            flip_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            flip_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n            if (flip_cost1 + flip_cost2) < (seg_cost1 + seg_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        return base_solution\n    return new_solution\n\n",
        "score": [
            -1.0044033859956638,
            5.004755675792694
        ]
    },
    {
        "algorithm": "The algorithm selects nondominated solutions with inverse Pareto rank probability, then applies a hybrid local search combining cost-aware segment rotations (prioritizing high-cost-ratio segments) and adaptive edge flips (prioritizing cost-improving flips), ensuring feasibility through permutation checks. It prioritizes segments in the first objective space when their cost ratio exceeds 1.3, and evaluates edge flips based on a weighted sum of both objectives to maintain balance. The solution is validated to ensure it remains a feasible TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto ranking and selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    ranks = np.zeros(len(objectives))\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                ranks[i] += 1\n\n    # Select with inverse rank probability\n    selected_idx = np.random.choice(np.where(ranks == np.min(ranks))[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cost-aware segment rotation\n    segment_length = random.randint(3, min(7, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Calculate segment cost ratios\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n    cost_ratio = seg_cost1 / (seg_cost2 + 1e-10)\n\n    # Rotate based on cost ratio\n    rotation = random.randint(1, segment_length-1)\n    if cost_ratio > 1.3:\n        rotation = -rotation\n    rotated_segment = np.roll(segment, rotation)\n\n    # Find best insertion position\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, rotated_segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + 0.6 * cost2  # Weighted sum\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    # Adaptive edge flips\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            seg_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            seg_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            flip_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            flip_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n            if (flip_cost1 + flip_cost2) < (seg_cost1 + seg_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        return base_solution\n    return new_solution\n\n",
        "score": [
            -0.9414472362380265,
            4.796680927276611
        ]
    }
]