[
    {
        "algorithm": "{This heuristic selects a solution from the archive by prioritizing those with the highest combined objective values, then applies a novel \"cross-space edge relocation\" local search that intelligently moves segments between the two objective spaces while maintaining feasibility through careful validation and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select solution with highest combined objective values\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-space edge relocation\n    if n > 3:\n        # Select a segment to move\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(5, n-seg_start-1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Determine insertion point in opposite space\n        # Calculate segment's properties in both spaces\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%seg_length]] for i in range(seg_length))\n\n        # Find best insertion point in opposite space\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_start + seg_length:\n                continue\n\n            # Calculate potential improvement\n            prev_node = new_solution[pos-1]\n            next_node = new_solution[pos]\n\n            # For first objective space\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                         distance_matrix_1[segment[-1], next_node])\n\n            # For second objective space\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                         distance_matrix_2[segment[-1], next_node])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove segment\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_length:]\n            ])\n\n            # Insert segment at best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0301725358101428,
            0.4450001120567322
        ]
    },
    {
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive, applies a hybrid local search operator that combines node insertion and segment rotation to explore non-dominated regions in the bi-objective space, and ensures feasibility by validating the generated neighbor solution before returning it.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 2)\n    segment = new_solution[start:end+1]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[start:end+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a randomly selected node at a new position\n    node = random.choice(new_solution)\n    pos = random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9504832977718974,
            0.048609256744384766
        ]
    }
]