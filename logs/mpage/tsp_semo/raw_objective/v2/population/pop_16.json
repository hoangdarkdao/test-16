[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (high ratio of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)  # Avoid division by zero\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge exchange followed by segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: Swap two edges if it improves both objectives\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n\n        # Calculate new objectives\n        old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n           (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n            new_solution = candidate\n            break\n\n    # Segment reversal: Reverse a random segment if it improves the solution\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Calculate new objectives\n    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n    # Accept if both objectives improve or one improves significantly\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n       (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n       (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n        new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               7.938052437621909,
               4.974250410098344
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating each solution's potential for improvement using a combination of objective values and diversity measures. It then applies a novel hybrid local search operator that combines a modified version of the Lin-Kernighan heuristic with a variable-length segment relocation strategy. The operator randomly selects a segment of nodes in the tour and relocates it to a new position while considering both objective spaces, ensuring feasibility by maintaining the TSP constraints. The selection of the segment length and insertion point is guided by a probabilistic approach that balances exploration and exploitation, favoring segments that show high potential for reducing both objectives. The function returns the new neighbor solution after validating its feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([(cost1 + cost2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2)) for _, (cost1, cost2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment length (1 to n//2)\n    segment_length = random.randint(1, n // 2)\n\n    # Randomly select a starting position for the segment\n    start_pos = random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Find the best insertion position considering both objectives\n    best_insert_pos = 0\n    best_cost = float('inf')\n\n    for insert_pos in range(len(new_solution)):\n        # Insert the segment at the current position\n        candidate = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Calculate the total cost in both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Combine the costs with a weighted sum\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = insert_pos\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n",
          "score": [
               6.11088345881558,
               5.468006696741405
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection strategy of focusing on non-dominated solutions from the second provided algorithm with a novel local search operator that integrates both edge-based and node-based perturbations. It first identifies promising solutions by filtering non-dominated ones from the archive, then applies a hybrid local search that alternates between a \"node jump\" operation (where a node is temporarily removed and reinserted at a better position based on both objective spaces) and a \"multi-edge swap\" operation (where multiple edges are simultaneously rearranged to improve both objectives), with the search guided by a Pareto-dominance acceptance criterion to ensure feasible and high-quality solutions are generated.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select a random non-dominated solution\n    selected_idx = np.random.randint(0, len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node Jump + Multi-Edge Swap\n    for _ in range(10):  # Number of local search iterations\n        # Node Jump: Remove a node and reinsert at a better position\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        candidate_positions = list(range(n))\n        candidate_positions.remove(node_pos)\n\n        # Evaluate insertion positions based on both objectives\n        best_pos = None\n        best_score = float('inf')\n        for pos in candidate_positions:\n            # Create temporary solution\n            temp_sol = np.delete(new_solution, node_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            # Calculate objectives\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            # Use Pareto dominance for selection\n            if best_pos is None or (cost1 <= best_score and cost2 <= best_score):\n                if cost1 < best_score or cost2 < best_score:\n                    best_pos = pos\n                    best_score = max(cost1, cost2)\n\n        if best_pos is not None:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n        # Multi-Edge Swap: Swap multiple edges simultaneously\n        if n >= 4:\n            # Select two random edge pairs to swap\n            a, b, c, d = np.random.choice(n, 4, replace=False)\n            if a > b:\n                a, b = b, a\n            if c > d:\n                c, d = d, c\n\n            # Create candidate solution\n            candidate = new_solution.copy()\n            # Swap edges (a,b) and (c,d) with (a,c) and (b,d)\n            candidate[a:b+1] = candidate[a:b+1][::-1]\n            candidate[c:d+1] = candidate[c:d+1][::-1]\n\n            # Calculate objectives\n            old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Accept if Pareto-dominant\n            if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) and (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               5.990936237660408,
               5.777165829116156
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection strategy of focusing on diverse solutions from the first provided algorithm with a novel local search operator that integrates both path inversion and node relocation, guided by a hybrid objective improvement criterion that considers both individual objective improvements and their combined trade-offs. It first partitions the archive into clusters based on both objective values and spatial diversity, then selects a representative solution from the least explored cluster. The local search operator dynamically selects multiple non-overlapping segments from the solution, applies inversion with probability based on local objective improvements, and then performs targeted node relocations to further optimize the tour, with the search guided by a hybrid acceptance criterion that balances individual objective improvements with their combined trade-offs to ensure feasible and high-quality solutions are generated.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    from sklearn.cluster import KMeans\n    import random\n\n    # Cluster-based selection\n    objectives = np.array([obj for _, obj in archive])\n    coords = instance[archive[0][0], :2]\n    diversity = np.array([np.std(coords[:, 0]), np.std(coords[:, 1])])\n\n    cluster_data = np.hstack([objectives, diversity.reshape(1, -1).repeat(len(archive), axis=0)])\n    n_clusters = min(3, len(archive))\n    kmeans = KMeans(n_clusters=n_clusters)\n    labels = kmeans.fit_predict(cluster_data)\n\n    cluster_sizes = np.bincount(labels)\n    least_cluster = np.argmin(cluster_sizes)\n    candidates = [i for i, label in enumerate(labels) if label == least_cluster]\n\n    if not candidates:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Segment inversion with node relocation\n    num_segments = min(3, n // 4)\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments*2))\n    segments = [(segment_indices[i], segment_indices[i+1]) for i in range(0, len(segment_indices), 2)]\n    segments.sort(key=lambda x: x[1]-x[0], reverse=True)\n\n    for start, end in segments:\n        segment = new_solution[start:end+1]\n        if random.random() < 0.6:\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n\n            inverted_segment = segment[::-1]\n            temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= 1.1 * current_cost2) or \\\n               (new_cost1 <= 1.1 * current_cost1 and new_cost2 < current_cost2):\n                new_solution = temp_solution\n\n    # Node relocation with trade-off consideration\n    for _ in range(5):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        candidate_positions = list(range(n))\n        candidate_positions.remove(node_pos)\n\n        best_pos = None\n        best_score = float('inf')\n        for pos in candidate_positions:\n            temp_sol = np.delete(new_solution, node_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            combined_score = 0.7 * cost1 + 0.3 * cost2\n            if combined_score < best_score:\n                best_pos = pos\n                best_score = combined_score\n\n        if best_pos is not None:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               5.041981799207054,
               7.326106261285743
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a multi-objective tour decomposition and reconstruction strategy that first partitions the base solution into non-overlapping segments based on both objective spaces' local topologies, then independently optimizes each segment using a novel adaptive segment inversion operator that considers the trade-off between the two objectives, and finally reconstructs the tour by strategically merging segments while maintaining feasibility through a dynamic node reallocation mechanism that ensures no nodes are skipped or revisited. The segment inversion operator dynamically adjusts the inversion length and direction based on local objective improvements, and the reconstruction phase uses a hybrid objective-aware merging criterion that prioritizes segments improving at least one objective while maintaining or improving the other, with the entire process guided by a spatial diversity measure to ensure comprehensive exploration of the solution space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution with best combined objective\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    # Calculate spatial diversity for each segment\n    def segment_diversity(segment):\n        coords1 = instance[segment, :2]\n        coords2 = instance[segment, 2:]\n        return np.std(coords1[:, 0]) + np.std(coords1[:, 1]) + np.std(coords2[:, 0]) + np.std(coords2[:, 1])\n\n    # Decompose tour into segments\n    n = len(base_solution)\n    min_segment = max(3, n // 5)\n    max_segment = min(10, n // 2)\n    segments = []\n    current_start = 0\n\n    while current_start < n:\n        segment_length = np.random.randint(min_segment, max_segment + 1)\n        segment_end = min(current_start + segment_length, n)\n        segments.append(base_solution[current_start:segment_end])\n        current_start = segment_end\n\n    # Optimize each segment independently\n    optimized_segments = []\n    for segment in segments:\n        if len(segment) < 3:\n            optimized_segments.append(segment)\n            continue\n\n        best_segment = segment.copy()\n        best_cost = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment))) + \\\n                    sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Adaptive segment inversion\n        for _ in range(3):\n            inv_start = np.random.randint(0, len(segment)-2)\n            inv_end = np.random.randint(inv_start+2, len(segment))\n\n            inverted = np.concatenate([segment[:inv_start], segment[inv_start:inv_end][::-1], segment[inv_end:]])\n\n            cost1 = sum(distance_matrix_1[inverted[i], inverted[(i+1)%len(inverted)]] for i in range(len(inverted)))\n            cost2 = sum(distance_matrix_2[inverted[i], inverted[(i+1)%len(inverted)]] for i in range(len(inverted)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_segment = inverted\n                best_cost = total_cost\n\n        optimized_segments.append(best_segment)\n\n    # Reconstruct tour with hybrid merging\n    new_solution = np.concatenate(optimized_segments)\n\n    # Dynamic node reallocation for feasibility\n    for _ in range(2):\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Find optimal insertion position considering both objectives\n        best_pos = node_pos\n        best_score = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            temp_sol = np.delete(new_solution, node_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n\n            # Hybrid objective score with spatial diversity consideration\n            diversity = segment_diversity(temp_sol)\n            score = 0.5 * (cost1 + cost2) + 0.5 * diversity\n\n            if score < best_score:\n                best_pos = pos\n                best_score = score\n\n        if best_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               6.103468513092029,
               5.6692877716368955
          ]
     },
     {
          "algorithm": "{The new algorithm combines Pareto front analysis with a novel multi-objective segment relocation strategy that dynamically selects and repositions segments of the tour based on their contribution to both objectives, using a hybrid acceptance criterion that balances improvement in both objectives while maintaining solution feasibility through a constrained segment relocation mechanism. The segment relocation dynamically adjusts the segment length and position based on local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure, and incorporates a guided edge reversal mechanism to further refine the solution while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best trade-off using Pareto front analysis\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective segment relocation\n    for _ in range(5):\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(n - segment_length)\n        end = start + segment_length\n\n        # Extract the segment\n        segment = base_solution[start:end]\n\n        # Remove the segment\n        temp_solution = np.concatenate([base_solution[:start], base_solution[end:]])\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(len(temp_solution)):\n            # Insert segment at position i\n            candidate = np.insert(temp_solution, i, segment)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Multi-objective comparison\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                best_pos = i\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        # Insert segment at best position\n        new_solution = np.insert(temp_solution, best_pos, segment)\n\n    # Guided edge reversal\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Create candidate solution\n        candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n        # Calculate costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if at least one objective improves or both improve with controlled trade-off\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               5.733596318190619,
               5.825750634336084
          ]
     },
     {
          "algorithm": "{The new algorithm combines Pareto-based solution selection with a novel multi-objective tour fragmentation and reassembly strategy that intelligently splits the tour into contiguous segments, evaluates their objective contributions, and reassembles them in a way that maximizes improvements in both objectives while maintaining solution feasibility through a constrained segment merging mechanism. The reassembly process dynamically adjusts segment boundaries based on local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure, and incorporates a guided segment rotation mechanism to further refine the solution while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best Pareto trade-off\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective tour fragmentation and reassembly\n    for _ in range(5):\n        # Randomly select two cut points to split the tour into three segments\n        cut1, cut2 = sorted(random.sample(range(1, n), 2))\n        segment1 = base_solution[:cut1]\n        segment2 = base_solution[cut1:cut2]\n        segment3 = base_solution[cut2:]\n\n        # Try different reassembly orders\n        candidates = [\n            np.concatenate([segment1, segment3, segment2]),\n            np.concatenate([segment2, segment1, segment3]),\n            np.concatenate([segment3, segment2, segment1]),\n            np.concatenate([segment1, segment2[::-1], segment3]),\n            np.concatenate([segment2[::-1], segment1, segment3])\n        ]\n\n        best_candidate = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                best_candidate = candidate\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_candidate\n\n    # Guided segment rotation\n    for _ in range(5):\n        # Select a segment to rotate\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Try different rotation amounts\n        for rotation in range(1, segment_length):\n            candidate = new_solution.copy()\n            segment = candidate[start:end]\n            rotated_segment = np.roll(segment, rotation)\n            candidate[start:end] = rotated_segment\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n                new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.520469626016764,
               5.163588701139817
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a multi-objective adaptive path refinement strategy that dynamically combines the strengths of both provided approaches by first identifying critical path segments through a hybrid clustering and Pareto-based analysis, then applies a novel adaptive segment refinement process that alternates between cluster-aware reordering and guided segment rotation, with each operation weighted by its potential objective improvement and spatial coherence, while maintaining feasibility through a constrained segment merging mechanism that ensures valid tour structures, and finally refines the solution through an iterative adaptive optimization process that dynamically adjusts the balance between exploration and exploitation based on the current Pareto front characteristics.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best Pareto trade-off\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Cluster-based path refinement\n    from sklearn.cluster import KMeans\n    n_clusters = max(2, len(base_solution) // 5)\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    combined_coords = np.hstack((coords1, coords2))\n\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n    clusters = kmeans.fit_predict(combined_coords)\n\n    cluster_groups = {}\n    for node, cluster in zip(base_solution, clusters):\n        if cluster not in cluster_groups:\n            cluster_groups[cluster] = []\n        cluster_groups[cluster].append(node)\n\n    # Adaptive segment refinement\n    for _ in range(5):\n        # Select a cluster to refine\n        cluster_to_refine = np.random.choice(list(cluster_groups.keys()))\n        nodes_in_cluster = cluster_groups[cluster_to_refine]\n\n        if len(nodes_in_cluster) < 2:\n            continue\n\n        # Find the positions of these nodes in the current solution\n        positions = [i for i, node in enumerate(new_solution) if node in nodes_in_cluster]\n\n        if len(positions) < 2:\n            continue\n\n        # Try different segment operations\n        best_candidate = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # Option 1: Reverse the segment\n        candidate = new_solution.copy()\n        segment = candidate[positions[0]:positions[-1]+1]\n        candidate[positions[0]:positions[-1]+1] = segment[::-1]\n\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n            best_candidate = candidate\n            best_cost1 = cost1\n            best_cost2 = cost2\n\n        # Option 2: Rotate the segment\n        for rotation in range(1, len(positions)):\n            candidate = new_solution.copy()\n            segment = candidate[positions[0]:positions[-1]+1]\n            rotated_segment = np.roll(segment, rotation)\n            candidate[positions[0]:positions[-1]+1] = rotated_segment\n\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                best_candidate = candidate\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_candidate\n\n    # Final adaptive optimization\n    for _ in range(3):\n        # Randomly select two cut points to split the tour into three segments\n        cut1, cut2 = sorted(random.sample(range(1, n), 2))\n        segment1 = new_solution[:cut1]\n        segment2 = new_solution[cut1:cut2]\n        segment3 = new_solution[cut2:]\n\n        # Try different reassembly orders\n        candidates = [\n            np.concatenate([segment1, segment3, segment2]),\n            np.concatenate([segment2, segment1, segment3]),\n            np.concatenate([segment3, segment2, segment1]),\n            np.concatenate([segment1, segment2[::-1], segment3]),\n            np.concatenate([segment2[::-1], segment1, segment3])\n        ]\n\n        best_candidate = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Adaptive acceptance criteria based on current Pareto front\n            if len(pareto_front) > 0:\n                avg_obj1 = sum(obj[0] for _, obj in pareto_front) / len(pareto_front)\n                avg_obj2 = sum(obj[1] for _, obj in pareto_front) / len(pareto_front)\n\n                if (cost1 < best_cost1 and cost2 <= avg_obj2 * 1.1) or (cost2 < best_cost2 and cost1 <= avg_obj1 * 1.1):\n                    best_candidate = candidate\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n            else:\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                    best_candidate = candidate\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        new_solution = best_candidate\n\n    return new_solution\n\n",
          "score": [
               5.505195001264278,
               6.001408081349817
          ]
     },
     {
          "algorithm": "{The novel algorithm employs a multi-phase approach that first identifies the most diverse solution in the archive using a novel diversity metric that combines both objective values and topological features, then applies a hybrid local search operator that combines a probabilistic node exchange mechanism with a constrained geometric transformation strategy. The operator selectively exchanges nodes based on their relative positions in both objective spaces, while applying a geometric transformation that warps the tour in a way that preserves feasibility and maximizes improvements in both objectives, with the transformation parameters dynamically adjusted based on the local topology and objective trade-offs. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and incorporates a guided diversification mechanism to escape local optima while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most diverse solution based on both objectives and topological features\n    diversity_scores = []\n    for sol, obj in archive:\n        # Calculate objective diversity\n        obj_diversity = (obj[0] - obj[1]) / (obj[0] + obj[1]) if (obj[0] + obj[1]) > 0 else 0\n\n        # Calculate topological diversity (average distance between consecutive nodes)\n        topo_diversity = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)) / len(sol)\n\n        # Combine both diversity measures\n        diversity_scores.append(abs(obj_diversity) + topo_diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search operator\n    for _ in range(5):\n        # Probabilistic node exchange mechanism\n        exchange_prob = 0.3\n        for i in range(n):\n            if random.random() < exchange_prob:\n                j = random.randint(0, n-1)\n                if i != j:\n                    # Swap nodes\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n                    # Calculate new costs\n                    cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n                    cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n                    # Accept if both objectives improve or one improves significantly\n                    old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n                    old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n\n                    if not ((cost1 < old_cost1 and cost2 <= old_cost2 * 1.05) or (cost2 < old_cost2 and cost1 <= old_cost1 * 1.05)):\n                        # Revert if not accepted\n                        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Geometric transformation strategy\n        if random.random() < 0.5:\n            # Select a segment of nodes\n            segment_length = random.randint(2, min(5, n//2))\n            start = random.randint(0, n - segment_length)\n            end = start + segment_length\n\n            # Apply a geometric transformation (rotation) to the segment\n            segment = new_solution[start:end]\n            rotation = random.randint(1, segment_length-1)\n            rotated_segment = np.roll(segment, rotation)\n            new_solution[start:end] = rotated_segment\n\n            # Check feasibility and cost\n            cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n            old_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%n]] for k in range(n))\n\n            if not ((cost1 < old_cost1 and cost2 <= old_cost2 * 1.05) or (cost2 < old_cost2 and cost1 <= old_cost1 * 1.05)):\n                # Revert if not accepted\n                new_solution[start:end] = base_solution[start:end]\n\n    # Guided diversification mechanism\n    if random.random() < 0.3:\n        # Select a random segment and reverse it\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
          "score": [
               8.509521446306293,
               5.4677328138881
          ]
     },
     {
          "algorithm": "{The new algorithm will combine the selection of diverse solutions from the archive with a novel \"objective-aware segment inversion\" operator that identifies segments of the tour where nodes are consistently distant in both objective spaces, inverts these segments, and strategically reinserts them to potentially reduce both objectives simultaneously, while maintaining feasibility through careful segment boundary handling and objective-aware acceptance criteria.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    selected_sol = max(archive, key=lambda x: (x[1][0] - x[1][1])**2)[0].copy()\n\n    # Objective-aware segment inversion\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Find segments where nodes are consistently distant in both objectives\n    segment_length = max(2, n // 5)\n    for _ in range(3):\n        # Randomly select a segment\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate average distance in both objectives\n        avg_dist1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) / (len(segment)-1)\n        avg_dist2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) / (len(segment)-1)\n\n        # If segment is consistently long in both objectives, consider inversion\n        if avg_dist1 > 0.5 * np.mean(distance_matrix_1) and avg_dist2 > 0.5 * np.mean(distance_matrix_2):\n            # Create candidate by inverting the segment\n            candidate = new_solution.copy()\n            candidate[start:start+segment_length] = segment[::-1]\n\n            # Check if inversion improves at least one objective\n            old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]]\n            new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution = candidate.copy()\n\n    # Strategic reinsertion of segments\n    for _ in range(2):\n        # Select a segment to move\n        segment_size = np.random.randint(2, min(5, n//3))\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Remove the segment\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n\n        # Find best insertion position based on both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(remaining)):\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n            # Calculate new objectives\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(len(candidate))) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Use weighted sum of objectives for selection\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
          "score": [
               5.618008886625851,
               7.567143663322766
          ]
     }
]