[
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a multi-objective adaptive local search strategy that intelligently selects a promising solution from the archive based on a combined objective score (normalized sum of both objectives), then applies a novel hybrid local search operator that combines edge insertion with a biased random walk to explore high-potential regions of the search space. The method first identifies the Pareto-frontier solutions in the archive, then selects a base solution probabilistically weighted by its dominance and diversity, followed by a two-stage perturbation: 1) a constrained segment inversion that preserves node connectivity, and 2) a multi-objective-aware edge swap that prioritizes improvements in both objectives while ensuring feasibility through a validation check. The generated neighbor solution is guaranteed to be a valid TSP tour through the use of a permutation repair mechanism that corrects any invalid sequences.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution (weighted random selection)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(norm_obj, axis=1)\n    probabilities = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Stage 1: Constrained segment inversion\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        np.random.shuffle(segment)\n        new_solution[start:end] = segment\n\n    # Stage 2: Multi-objective-aware edge swap\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before swap\n        prev_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        prev_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost after swap\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if both objectives improve\n        if (new_cost1 < prev_cost1) and (new_cost2 < prev_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism if invalid\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in range(n) if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            pos = np.where(new_solution == dup)[0][1]\n            new_solution[pos] = missing.pop()\n\n    return new_solution\n\n",
          "score": [
               -0.9434502893378602,
               0.6291956901550293
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of their objectives (prioritize those with lower total cost)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator: a combination of segment reversal and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse (to avoid getting stuck in local optima)\n    start = np.random.randint(0, n - 1)\n    end = np.random.randint(start + 1, n)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert (to explore new neighborhoods)\n    node_to_move = np.random.choice(new_solution)\n    mask = new_solution != node_to_move\n    new_solution = np.concatenate([new_solution[mask], [node_to_move]])\n\n    return new_solution\n\n",
          "score": [
               -0.7095738278032713,
               0.4901522397994995
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(archive) > 1:\n        # Select a solution that is not dominated by others\n        selected_idx = 0\n        for i in range(1, len(archive)):\n            if (objectives[i][0] < objectives[selected_idx][0] and objectives[i][1] <= objectives[selected_idx][1]) or \\\n               (objectives[i][0] <= objectives[selected_idx][0] and objectives[i][1] < objectives[selected_idx][1]):\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose a segment to reverse (novel segment reversal)\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply 2-opt to improve the solution\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if not (np.array_equal(np.unique(new_solution), np.arange(n)) and len(new_solution) == n):\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
          "score": [
               -0.8398412362557686,
               0.5397500395774841
          ]
     },
     {
          "algorithm": "{The common backbone idea in the provided algorithms is the selection of promising solutions from an archive based on multi-objective criteria (Pareto dominance or combined objective scores) followed by the application of a local search operator that balances exploration and exploitation while maintaining solution feasibility. The new algorithm will employ a multi-stage local search strategy that combines a biased random walk with a constrained segment rotation, where the selection of segments is guided by the instance's coordinate data to identify high-potential regions for improvement. The method will first normalize the objectives to create a combined score, then select a base solution probabilistically, followed by a two-phase perturbation: 1) a biased random walk that prioritizes edges with high potential for cost reduction in both objectives, and 2) a constrained segment rotation that dynamically selects and rotates segments to explore the neighborhood while ensuring feasibility through a validation check and permutation repair mechanism if needed.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution (weighted random selection)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(norm_obj, axis=1)\n    probabilities = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Biased random walk phase\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random starting point\n        current_pos = np.random.randint(0, n)\n        steps = np.random.randint(2, min(5, n//2))\n\n        # Perform biased random walk\n        for _ in range(steps):\n            next_pos = (current_pos + 1) % n\n\n            # Calculate potential cost reduction\n            current_edges = [\n                (new_solution[current_pos-1], new_solution[current_pos]),\n                (new_solution[next_pos], new_solution[(next_pos+1)%n])\n            ]\n            swapped_edges = [\n                (new_solution[current_pos-1], new_solution[next_pos]),\n                (new_solution[current_pos], new_solution[(next_pos+1)%n])\n            ]\n\n            current_cost1 = sum(distance_matrix_1[u, v] for u, v in current_edges)\n            current_cost2 = sum(distance_matrix_2[u, v] for u, v in current_edges)\n            swapped_cost1 = sum(distance_matrix_1[u, v] for u, v in swapped_edges)\n            swapped_cost2 = sum(distance_matrix_2[u, v] for u, v in swapped_edges)\n\n            # Accept if both objectives improve\n            if (swapped_cost1 < current_cost1) and (swapped_cost2 < current_cost2):\n                new_solution[current_pos], new_solution[next_pos] = new_solution[next_pos], new_solution[current_pos]\n\n            current_pos = next_pos\n\n    # Step 3: Constrained segment rotation\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Rotate the segment\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end] = rotated_segment\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism if invalid\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in range(n) if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            pos = np.where(new_solution == dup)[0][1]\n            new_solution[pos] = missing.pop()\n\n    return new_solution\n\n",
          "score": [
               -0.8726024957466604,
               0.5535788536071777
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with low crowding distance)\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n\n    # Hybrid local search: Dynamic segment replacement\n    n = len(selected_solution)\n    if n < 3:\n        return selected_solution  # No improvement possible\n\n    # Randomly select a segment length (between 2 and n/2)\n    segment_length = np.random.randint(2, max(2, n // 2 + 1))\n\n    # Randomly select a starting index for the segment\n    start_idx = np.random.randint(0, n - segment_length)\n\n    # Extract the segment to be replaced\n    segment = selected_solution[start_idx:start_idx + segment_length]\n\n    # Generate a new segment using a greedy insertion approach weighted by both objectives\n    remaining_nodes = [node for node in selected_solution if node not in segment]\n    new_segment = []\n\n    # Start with a random node from the remaining nodes\n    current_node = np.random.choice(remaining_nodes)\n    new_segment.append(current_node)\n    remaining_nodes.remove(current_node)\n\n    while len(new_segment) < segment_length and remaining_nodes:\n        # Find the best next node based on weighted distance\n        best_node = None\n        best_score = float('inf')\n\n        for candidate in remaining_nodes:\n            # Calculate weighted distance to the last node in the new segment\n            dist1 = distance_matrix_1[new_segment[-1], candidate]\n            dist2 = distance_matrix_2[new_segment[-1], candidate]\n            weighted_dist = 0.5 * dist1 + 0.5 * dist2  # Equal weight for simplicity\n\n            if weighted_dist < best_score:\n                best_score = weighted_dist\n                best_node = candidate\n\n        if best_node is not None:\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n    # Replace the segment in the original solution\n    new_solution = np.concatenate([\n        selected_solution[:start_idx],\n        np.array(new_segment),\n        selected_solution[start_idx + segment_length:]\n    ])\n\n    # Ensure the solution is a valid tour (circular)\n    if not np.array_equal(new_solution, selected_solution):\n        # Validate the tour (optional, but good practice)\n        if len(np.unique(new_solution)) == len(selected_solution):\n            return new_solution\n\n    return selected_solution  # Return original if no improvement\n\n",
          "score": [
               -0.8751655686311861,
               0.8388110995292664
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a multi-objective cluster-based local search strategy that first partitions the archive into clusters of solutions with similar objective profiles, then probabilistically selects a base solution from the cluster with the highest potential for improvement, followed by a two-stage perturbation: 1) a dynamic segment relocation that moves a variable-length segment to a new position while preserving connectivity, and 2) a multi-objective-aware node insertion that evaluates candidate insertions based on a weighted combination of both objectives, with acceptance criteria that balance improvement in both dimensions while ensuring feasibility through a comprehensive validation mechanism that repairs any invalid sequences through a combination of node swaps and segment reversals.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Cluster solutions based on objective similarity\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n\n    # Use K-means to cluster solutions (simplified for demonstration)\n    from sklearn.cluster import KMeans\n    n_clusters = min(3, len(archive))\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(norm_obj)\n    cluster_labels = kmeans.labels_\n\n    # Step 2: Select cluster with highest potential for improvement\n    cluster_potentials = []\n    for cluster in range(n_clusters):\n        cluster_indices = np.where(cluster_labels == cluster)[0]\n        cluster_objectives = objectives[cluster_indices]\n        # Potential is based on average objective values (lower is better)\n        potential = np.mean(cluster_objectives, axis=0)\n        cluster_potentials.append(potential)\n\n    # Select cluster with lowest average objectives (most promising)\n    selected_cluster = np.argmin(np.sum(cluster_potentials, axis=1))\n    cluster_indices = np.where(cluster_labels == selected_cluster)[0]\n\n    # Select a base solution from this cluster\n    if len(cluster_indices) > 1:\n        # Select solution closest to the cluster centroid\n        cluster_centroid = kmeans.cluster_centers_[selected_cluster]\n        distances = np.linalg.norm(norm_obj[cluster_indices] - cluster_centroid, axis=1)\n        selected_idx = cluster_indices[np.argmin(distances)]\n    else:\n        selected_idx = cluster_indices[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Dynamic segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Find new insertion point\n        insertion_point = np.random.randint(0, n - segment_length)\n        while insertion_point >= start and insertion_point < end:\n            insertion_point = np.random.randint(0, n - segment_length)\n\n        # Relocate segment\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:insertion_point],\n            segment,\n            new_solution[insertion_point:start],\n            new_solution[end:]\n        ])\n\n    # Step 4: Multi-objective-aware node insertion\n    for _ in range(3):\n        # Select a random node to move\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Evaluate possible insertions\n        best_pos = node_idx\n        best_cost1 = 0\n        best_cost2 = 0\n\n        # Consider positions around current node\n        for pos in range(max(0, node_idx-3), min(n, node_idx+4)):\n            if pos == node_idx:\n                continue\n\n            # Calculate cost before and after insertion\n            if pos > 0:\n                prev_node = new_solution[pos-1]\n                next_node = new_solution[pos]\n                current_node = new_solution[node_idx]\n\n                # Cost before insertion\n                prev_cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n                prev_cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n\n                # Cost after insertion\n                if node_idx > pos:\n                    # Node is moved forward\n                    new_cost1 = (distance_matrix_1[prev_node, node] +\n                                distance_matrix_1[node, next_node] +\n                                distance_matrix_1[new_solution[node_idx-1], current_node])\n                    new_cost2 = (distance_matrix_2[prev_node, node] +\n                                distance_matrix_2[node, next_node] +\n                                distance_matrix_2[new_solution[node_idx-1], current_node])\n                else:\n                    # Node is moved backward\n                    new_cost1 = (distance_matrix_1[prev_node, node] +\n                                distance_matrix_1[node, next_node] +\n                                distance_matrix_1[current_node, new_solution[node_idx+1]])\n                    new_cost2 = (distance_matrix_2[prev_node, node] +\n                                distance_matrix_2[node, next_node] +\n                                distance_matrix_2[current_node, new_solution[node_idx+1]])\n\n                # Weighted cost improvement\n                weight = 0.5  # Equal weighting between objectives\n                cost_improvement = (weight * (prev_cost1 - new_cost1) + (1-weight) * (prev_cost2 - new_cost2))\n\n                if cost_improvement > 0:\n                    if (best_pos == node_idx) or (cost_improvement > (weight * (prev_cost1 - best_cost1) + (1-weight) * (prev_cost2 - best_cost2))):\n                        best_pos = pos\n                        best_cost1 = new_cost1\n                        best_cost2 = new_cost2\n\n        # Perform the best insertion if found\n        if best_pos != node_idx:\n            # Remove node from current position\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            # Insert node at new position\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in range(n) if list(new_solution).count(x) > 1]\n\n        for dup in duplicates:\n            pos = np.where(new_solution == dup)[0][1]\n            new_solution[pos] = missing.pop()\n\n    return new_solution\n\n",
          "score": [
               -0.9382842925863917,
               2.6549702882766724
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' employs a novel hybrid local search strategy that combines adaptive selection pressure with a multi-phase perturbation mechanism. It first intelligently samples the archive to identify solutions with high potential for improvement by evaluating their dominance and crowding distance in the bi-objective space, then applies a dynamic 3-exchange operator followed by a targeted inversion of a subtour segment, guided by a weighted objective-aware fitness function that balances the trade-offs between the two objectives. The method ensures feasibility by strictly maintaining permutation properties and includes a validity check to revert to the original solution if the generated neighbor is invalid, guaranteeing the output is always a feasible TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a weighted selection based on dominance and crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance and crowding distance (simplified approach)\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]:\n                if objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]:\n                    dominated[i] = True\n                    break\n\n    # Select non-dominated solutions if available, otherwise select all\n    non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n    selected_indices = non_dominated if non_dominated else list(range(len(archive)))\n\n    # Calculate crowding distance for selected solutions\n    if len(selected_indices) > 1:\n        # Sort by first objective\n        sorted_indices = sorted(selected_indices, key=lambda i: objectives[i][0])\n        crowding = [0.0] * len(archive)\n        crowding[sorted_indices[0]] = float('inf')\n        crowding[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, len(sorted_indices)-1):\n            crowding[sorted_indices[i]] = abs(objectives[sorted_indices[i+1]][0] - objectives[sorted_indices[i-1]][0])\n\n        # Sort by second objective\n        sorted_indices = sorted(selected_indices, key=lambda i: objectives[i][1])\n        crowding[sorted_indices[0]] = float('inf')\n        crowding[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, len(sorted_indices)-1):\n            crowding[sorted_indices[i]] += abs(objectives[sorted_indices[i+1]][1] - objectives[sorted_indices[i-1]][1])\n\n        # Select solution with highest crowding distance\n        best_idx = max(selected_indices, key=lambda i: crowding[i])\n    else:\n        best_idx = selected_indices[0]\n\n    base_solution = solutions[best_idx].copy()\n\n    # Step 2: Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive 3-exchange\n    if n >= 3:\n        # Select three distinct positions\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Perform 3-exchange\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = new_solution[c]\n        new_solution[c] = temp\n\n    # Phase 2: Targeted inversion\n    if n >= 2:\n        # Select a segment to invert\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Verify the solution is valid (permutation)\n    if not (np.array_equal(np.sort(new_solution), np.sort(base_solution)) and len(np.unique(new_solution)) == n):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.692138007707279,
               0.504461407661438
          ]
     },
     {
          "algorithm": "{The proposed algorithm first selects a promising solution from the archive by prioritizing those with the highest potential for improvement, measured by the ratio of their objective values to the average objective values in the archive. It then applies a hybrid local search operator that combines a novel edge-swapping strategy with a perturbation mechanism. The edge-swapping strategy identifies the most critical edges in the solution based on their contribution to the total cost in both objective spaces, and swaps them with alternative edges that reduce the total cost. The perturbation mechanism introduces controlled randomness to escape local optima by randomly swapping a subset of edges. The algorithm ensures feasibility by maintaining a valid TSP tour throughout the process, and it iteratively refines the solution until no further improvement is possible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the most promising solution (highest potential for improvement)\n    avg_cost1 = np.mean([obj[0] for _, obj in archive])\n    avg_cost2 = np.mean([obj[1] for _, obj in archive])\n\n    # Calculate the improvement potential for each solution\n    potentials = []\n    for sol, obj in archive:\n        cost1, cost2 = obj\n        potential = (cost1 / avg_cost1) + (cost2 / avg_cost2)  # Higher is better (more potential)\n        potentials.append(potential)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping strategy (novel approach)\n    # Identify the most critical edges in both objective spaces\n    critical_edges = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        critical_edges.append((i, (i + 1) % n, cost1, cost2))\n\n    # Sort edges by their contribution to the total cost (descending)\n    critical_edges.sort(key=lambda x: -(x[2] + x[3]))\n\n    # Swap the most critical edges with alternative edges\n    for i in range(min(3, len(critical_edges))):  # Limit to top 3 critical edges\n        pos1, pos2, _, _ = critical_edges[i]\n        # Find alternative edges to swap with\n        for j in range(n):\n            if j == pos1 or j == pos2 or (j + 1) % n == pos1 or (j + 1) % n == pos2:\n                continue\n            # Calculate the cost of the alternative edge\n            u = new_solution[pos1]\n            v = new_solution[(pos1 + 1) % n]\n            new_u = new_solution[j]\n            new_v = new_solution[(j + 1) % n]\n            cost1_old = distance_matrix_1[u, v] + distance_matrix_1[new_u, new_v]\n            cost1_new = distance_matrix_1[u, new_u] + distance_matrix_1[new_v, v]\n            cost2_old = distance_matrix_2[u, v] + distance_matrix_2[new_u, new_v]\n            cost2_new = distance_matrix_2[u, new_u] + distance_matrix_2[new_v, v]\n            # If the alternative edge reduces the total cost, perform the swap\n            if (cost1_new + cost2_new) < (cost1_old + cost2_old):\n                # Perform the swap\n                new_solution[pos1] = new_u\n                new_solution[(pos1 + 1) % n] = new_v\n                new_solution[j] = u\n                new_solution[(j + 1) % n] = v\n                break\n\n    # Step 2: Perturbation mechanism (introduce controlled randomness)\n    if np.random.rand() < 0.3:  # 30% chance of perturbation\n        # Randomly select a segment to reverse\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, min(5, n // 2))  # Random segment length\n        end = (start + length) % n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            segment = segment[::-1]\n            new_solution[start:] = segment[:n - start]\n            new_solution[:end] = segment[n - start:]\n\n    return new_solution\n\n",
          "score": [
               -0.8612723930221843,
               0.5997492074966431
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance and combined cost for each solution\n    dominated = [False] * len(archive)\n    combined_costs = []\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        combined_cost = obj_i[0] + obj_i[1]\n        combined_costs.append(combined_cost)\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated[i] = True\n                break\n\n    # Select non-dominated solutions or those with lowest combined cost\n    promising_indices = [i for i, dom in enumerate(dominated) if not dom]\n    if not promising_indices:\n        promising_indices = [i for i, _ in sorted(enumerate(combined_costs), key=lambda x: x[1])[:max(1, len(archive)//3)]]\n\n    # Step 2: Select a base solution with weighted randomness\n    weights = [1.0 / (1.0 + combined_costs[i]) for i in promising_indices]\n    total_weight = sum(weights)\n    probs = [w / total_weight for w in weights]\n    selected_idx = random.choices(promising_indices, weights=probs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Adaptive segment inversion with multi-objective awareness\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment boundaries\n    segment_length = max(2, n // 5)\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Calculate segment cost before inversion\n    def calculate_segment_cost(sol, start, end):\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(start, end):\n            cost1 += distance_matrix_1[sol[i], sol[(i+1)%n]]\n            cost2 += distance_matrix_2[sol[i], sol[(i+1)%n]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_segment_cost(new_solution, start, end)\n\n    # Perform inversion\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Calculate segment cost after inversion\n    new_cost1, new_cost2 = calculate_segment_cost(new_solution, start, end)\n\n    # Acceptance criterion: accept if at least one objective improves\n    if not (new_cost1 <= original_cost1 and new_cost2 <= original_cost2):\n        # If no improvement, try to find a better segment\n        for _ in range(3):  # Try a few more segments\n            new_start = random.randint(0, n - segment_length - 1)\n            new_end = new_start + segment_length\n            new_new_solution = new_solution.copy()\n            new_new_solution[new_start:new_end] = new_new_solution[new_start:new_end][::-1]\n            new_new_cost1, new_new_cost2 = calculate_segment_cost(new_new_solution, new_start, new_end)\n            if (new_new_cost1 <= original_cost1 and new_new_cost2 <= original_cost2) or \\\n               random.random() < 0.3:  # Small probability of accepting worse solution\n                new_solution = new_new_solution\n                break\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.791548686523524,
               0.5963345170021057
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical edges in both objectives\n    def get_edge_costs(solution, distance_matrix):\n        costs = []\n        for i in range(n):\n            costs.append(distance_matrix[solution[i], solution[(i+1)%n]])\n        return np.array(costs)\n\n    edge_costs_1 = get_edge_costs(new_solution, distance_matrix_1)\n    edge_costs_2 = get_edge_costs(new_solution, distance_matrix_2)\n    combined_costs = edge_costs_1 + edge_costs_2\n    critical_edges = np.argsort(combined_costs)[-max(2, n//10):]  # Top 10% or 2 edges\n\n    # Hybrid local search\n    if np.random.rand() < 0.7:  # 70% chance for segment reversal\n        # Segment reversal with critical edge protection\n        if len(critical_edges) > 1:\n            i, j = sorted(np.random.choice(critical_edges, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Fallback to standard segment reversal\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance for hybrid edge exchange\n        # Select two non-critical edges to exchange\n        non_critical = [i for i in range(n) if i not in critical_edges]\n        if len(non_critical) >= 4:\n            a, b, c, d = np.random.choice(non_critical, 4, replace=False)\n            # Perform 2-opt like exchange\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = (\n                new_solution[a], new_solution[c], new_solution[b], new_solution[d])\n        else:\n            # Fallback to standard edge exchange\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.6289509178977262,
               0.5672571063041687
          ]
     }
]