[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a promising solution (prioritize diversity and objective balance)\n    selected_solution = None\n    min_score = float('inf')\n    for sol, obj in non_dominated:\n        # Score based on objective values and diversity (simplified here)\n        score = obj[0] + obj[1] + np.random.uniform(0, 0.1)  # Small randomness to avoid bias\n        if score < min_score:\n            min_score = score\n            selected_solution = sol.copy()\n\n    # Step 3: Generate neighbor using hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Random segment reversal (diversity)\n    if n > 2:\n        start = np.random.randint(0, n - 1)\n        end = np.random.randint(start + 1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Objective-aware edge swap (improvement)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i = np.random.randint(0, n - 1)\n        j = np.random.randint(i + 1, n)\n\n        # Current edges\n        a, b = new_solution[i-1], new_solution[i]\n        c, d = new_solution[j-1], new_solution[j]\n\n        # Potential new edges\n        new_edges = [(a, new_solution[j]), (new_solution[j], b), (c, new_solution[i]), (new_solution[i], d)]\n\n        # Calculate objective improvements\n        delta_obj1 = (distance_matrix_1[a, new_solution[j]] + distance_matrix_1[new_solution[j], b] +\n                      distance_matrix_1[c, new_solution[i]] + distance_matrix_1[new_solution[i], d] -\n                      (distance_matrix_1[a, b] + distance_matrix_1[c, d]))\n\n        delta_obj2 = (distance_matrix_2[a, new_solution[j]] + distance_matrix_2[new_solution[j], b] +\n                      distance_matrix_2[c, new_solution[i]] + distance_matrix_2[new_solution[i], d] -\n                      (distance_matrix_2[a, b] + distance_matrix_2[c, d]))\n\n        # Accept if at least one objective improves\n        if delta_obj1 < 0 or delta_obj2 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to a random valid tour if invalid\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n",
          "score": [
               -0.82047267287735,
               0.6255292296409607
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive.copy()\n\n    # Step 2: Select a solution probabilistically based on non-domination rank and crowding distance\n    selected = random.choices(non_dominated, k=1)[0][0].copy()\n\n    # Step 3: Apply hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Variable-length segment relocation\n    if n > 3:\n        seg_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Biased 3-opt move\n    if n > 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n\n        # Try all possible 3-opt configurations\n        options = [\n            (new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]),\n        ]\n\n        best_option = None\n        best_improvement = 0\n\n        for opt in options:\n            temp_sol = np.concatenate([new_solution[:i], opt[0], opt[1], opt[2]])\n            new_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, n)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            new_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, n)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n            improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_option = opt\n\n        if best_option is not None:\n            new_solution = np.concatenate([new_solution[:i], best_option[0], best_option[1], best_option[2]])\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism: reorder nodes to form a valid tour\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, list(missing)])\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.9209101573486693,
               0.6316920518875122
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with the lowest combined objective)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion + multi-objective edge exchange\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Segment inversion\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Multi-objective edge exchange\n        for _ in range(5):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.7895915616322705,
               0.45019596815109253
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the variance of objectives in the archive to identify solutions with high potential\n    objectives = np.array([obj for (sol, obj) in archive])\n    variance = np.var(objectives, axis=0)\n    normalized_variance = variance / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n\n    # Select the solution with the highest normalized variance in objectives\n    selected_idx = np.argmax(np.sum(normalized_variance * (objectives - np.mean(objectives, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: combine 3-opt with a biased edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to perform 3-opt\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Perform 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Insert a randomly selected node at a position that improves both objectives\n    if n > 3:\n        # Remove a random node and reinsert it at a position that minimizes the sum of distances in both spaces\n        node_to_insert = np.random.choice(new_solution)\n        mask = new_solution != node_to_insert\n        filtered_solution = new_solution[mask]\n\n        best_pos = 0\n        min_total_cost = float('inf')\n\n        for pos in range(len(filtered_solution)):\n            # Create a temporary solution with the node inserted at pos\n            temp_solution = np.insert(filtered_solution, pos, node_to_insert)\n\n            # Calculate the total cost in both spaces\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(filtered_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n",
          "score": [
               -0.8767660732396109,
               3.445814549922943
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment relocation strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments to perform 3-opt\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Perform 3-opt: reverse segments between i-j, j-k, or i-k\n    option = np.random.randint(0, 3)\n    if option == 0:\n        new_solution[i:j] = new_solution[i:j][::-1]\n    elif option == 1:\n        new_solution[j:k] = new_solution[j:k][::-1]\n    else:\n        new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Novel segment relocation: move a random segment to a new position\n    seg_start = np.random.randint(0, n)\n    seg_end = np.random.randint(seg_start + 1, n + 1)\n    seg = new_solution[seg_start:seg_end]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:], seg])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.514912285006846,
               0.45540595054626465
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies solutions in the archive with the lowest combined objective values, then intelligently selects one based on their diversity and potential for improvement by examining the distance matrices. It then applies a novel hybrid local search operator that combines a randomized edge swap with a biased node insertion, where the bias is determined by the relative distances in the two objective spaces. The edge swap is performed by selecting two non-adjacent edges and reversing the path between them, while the node insertion involves removing a node and reinserting it at a position that minimizes the weighted sum of distances in both objective spaces. The operator ensures feasibility by maintaining a valid tour structure, and the selection of solutions prioritizes those with underutilized edges or nodes that show promise for reducing the objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the top 10% solutions with the lowest combined objective values\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, len(archive) // 10)\n    top_solutions = archive_sorted[:top_k]\n\n    # Select a solution with high diversity (high variance in edge usage)\n    selected_solution = None\n    max_variance = -1\n    for sol, _ in top_solutions:\n        edges = [(sol[i], sol[i+1]) for i in range(len(sol)-1)] + [(sol[-1], sol[0])]\n        edge_counts = np.zeros_like(distance_matrix_1)\n        for u, v in edges:\n            edge_counts[u, v] += 1\n            edge_counts[v, u] += 1\n        variance = np.var(edge_counts)\n        if variance > max_variance:\n            max_variance = variance\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n < 4:\n        # For small tours, just swap two nodes\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Randomly choose between edge swap and node insertion\n        if np.random.random() < 0.5:\n            # Edge swap with bias towards high-distance edges\n            i, j = np.random.choice(n, 2, replace=False)\n            i, j = min(i, j), max(i, j)\n            if j - i > 1:\n                # Reverse the segment between i and j\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Node insertion with bias towards nodes that can improve both objectives\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            # Find the best insertion point that minimizes the weighted sum of distances\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution)):\n                if pos == 0:\n                    prev_node = new_solution[-1]\n                else:\n                    prev_node = new_solution[pos-1]\n                next_node = new_solution[pos]\n                cost = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] -\n                        distance_matrix_1[prev_node, next_node]) + \\\n                       (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] -\n                        distance_matrix_2[prev_node, next_node])\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.7757417993428217,
               2.3514594435691833
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first evaluates the archive of solutions by computing their dominance relationships and identifying non-dominated solutions, which are then ranked based on their objective values. A promising solution is intelligently selected using a tournament selection mechanism that favors solutions with lower objective values and higher diversity. The selected solution undergoes a novel hybrid local search strategy combining a multi-segment inversion operator with a guided edge insertion heuristic. This operator randomly selects two segments of the tour and reverses their order, while the insertion heuristic evaluates potential edge insertions to improve both objectives. The generated neighbor solution is validated to ensure feasibility by verifying that it forms a valid TSP tour with no skipped or repeated nodes. The function returns this new solution for further exploration in the multi-objective optimization process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection to choose a promising solution\n    tournament_size = min(5, len(archive))\n    selected = np.random.choice(len(archive), tournament_size, replace=False)\n    best_idx = selected[0]\n    for idx in selected[1:]:\n        # Prefer solutions with lower objective values (Pareto dominance)\n        if (archive[idx][1][0] < archive[best_idx][1][0] and archive[idx][1][1] <= archive[best_idx][1][1]) or \\\n           (archive[idx][1][0] <= archive[best_idx][1][0] and archive[idx][1][1] < archive[best_idx][1][1]):\n            best_idx = idx\n\n    base_solution = archive[best_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion operator\n    if n > 3:\n        # Randomly select two segments and reverse their order\n        seg1_start = np.random.randint(0, n-2)\n        seg1_end = np.random.randint(seg1_start+1, n-1)\n        seg2_start = np.random.randint(0, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        # Ensure the segments are not overlapping\n        if seg1_end <= seg2_start or seg2_end <= seg1_start:\n            # Reverse the segments\n            new_solution[seg1_start:seg1_end+1] = new_solution[seg1_start:seg1_end+1][::-1]\n            new_solution[seg2_start:seg2_end+1] = new_solution[seg2_start:seg2_end+1][::-1]\n\n    # Guided edge insertion heuristic\n    if n > 2:\n        # Randomly select two nodes and try to insert one between the other's neighbors\n        i, j = np.random.choice(n, 2, replace=False)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Find neighbors of node_j\n        j_prev = (j - 1) % n\n        j_next = (j + 1) % n\n        neighbor_prev = new_solution[j_prev]\n        neighbor_next = new_solution[j_next]\n\n        # Calculate potential improvements\n        current_cost = distance_matrix_1[node_i, neighbor_prev] + distance_matrix_1[node_i, neighbor_next] + \\\n                       distance_matrix_2[node_i, neighbor_prev] + distance_matrix_2[node_i, neighbor_next]\n        new_cost = distance_matrix_1[neighbor_prev, node_i] + distance_matrix_1[node_i, neighbor_next] + \\\n                   distance_matrix_2[neighbor_prev, node_i] + distance_matrix_2[node_i, neighbor_next]\n\n        # If improvement, perform insertion\n        if new_cost < current_cost:\n            # Remove node_i from its current position\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            # Insert node_i between neighbors of node_j\n            new_solution = np.insert(new_solution, j_next, node_i)\n\n    # Ensure the solution remains valid (no duplicates and all nodes present)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7020521953050154,
               0.5767357349395752
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0]\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search: combine 3-opt with a dynamic edge exchange\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        i, j, k = sorted(random.sample(range(n), 3))\n        # 3-opt move\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        segment3 = new_solution[k:]\n        # Try all possible combinations of these segments\n        candidates = [\n            np.concatenate([new_solution[:i], segment1[::-1], segment2, segment3]),\n            np.concatenate([new_solution[:i], segment2, segment1[::-1], segment3]),\n            np.concatenate([new_solution[:i], segment1, segment2[::-1], segment3]),\n            np.concatenate([new_solution[:i], segment2[::-1], segment1, segment3]),\n            np.concatenate([new_solution[:i], segment1, segment3, segment2[::-1]]),\n            np.concatenate([new_solution[:i], segment3, segment1, segment2[::-1]])\n        ]\n        # Evaluate all candidates based on both objectives\n        best_candidate = min(candidates, key=lambda x: sum(distance_matrix_1[x[i], x[(i+1)%n]] for i in range(n)) + sum(distance_matrix_2[x[i], x[(i+1)%n]] for i in range(n)))\n        new_solution = best_candidate\n\n        # Dynamic edge exchange: swap edges based on both objectives\n        if random.random() < 0.5:  # 50% chance to perform edge exchange\n            a, b = sorted(random.sample(range(n), 2))\n            # Calculate cost improvement for both objectives\n            cost1_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n            cost2_before = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n            cost1_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n            cost2_after = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n            # Accept if both objectives improve or one improves significantly\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n               (cost1_after < 0.9 * cost1_before and cost2_after < 1.1 * cost2_before) or \\\n               (cost2_after < 0.9 * cost2_before and cost1_after < 1.1 * cost1_before):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               -0.8574220653779082,
               3.9334295988082886
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Multi-objective edge swapping with Lin-Kernighan-like approach\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to modify\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n\n    # Extract the segment\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Evaluate the segment in both objective spaces\n    seg_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n    seg_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n    # Find the best insertion point outside the segment\n    best_improvement = 0\n    best_pos = -1\n    best_reversed = False\n\n    for pos in range(n):\n        if pos >= segment_start and pos < segment_start + segment_length:\n            continue\n\n        # Try inserting the segment normally\n        new_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n        old_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n        delta1 = new_cost1 - old_cost1\n\n        new_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n        old_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n        delta2 = new_cost2 - old_cost2\n\n        improvement = (seg_cost1 + delta1) + (seg_cost2 + delta2)\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n            best_reversed = False\n\n        # Try inserting the reversed segment\n        reversed_segment = segment[::-1]\n        new_cost1_rev = distance_matrix_1[new_solution[pos-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[pos]]\n        delta1_rev = new_cost1_rev - old_cost1\n\n        new_cost2_rev = distance_matrix_2[new_solution[pos-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[pos]]\n        delta2_rev = new_cost2_rev - old_cost2\n\n        improvement_rev = (seg_cost1 + delta1_rev) + (seg_cost2 + delta2_rev)\n\n        if improvement_rev < best_improvement:\n            best_improvement = improvement_rev\n            best_pos = pos\n            best_reversed = True\n\n    if best_pos != -1:\n        # Apply the best found modification\n        if best_reversed:\n            segment = segment[::-1]\n\n        # Remove the segment from its original position\n        new_solution = np.concatenate([\n            new_solution[:segment_start],\n            new_solution[segment_start + segment_length:]\n        ])\n\n        # Insert the segment at the new position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n",
          "score": [
               -0.8091168588690303,
               4.1131404638290405
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating a combined fitness score that considers both objectives, normalized to handle their different scales. It then applies a hybrid local search strategy: a novel 'multi-objective edge-swap' operator that randomly selects two disjoint edges from the tour, swaps their positions while preserving feasibility, and further refines the solution by performing a short 'multi-objective 3-opt' move on the affected segment. The operator prioritizes edges with high combined cost in either objective space, ensuring both objectives are improved. The function ensures the generated neighbor remains feasible by validating the tour structure after each modification.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on combined objective scores\n    def combined_score(obj):\n        # Normalize objectives to [0, 1] range for fair comparison\n        obj1, obj2 = obj\n        max_obj1 = max(o[0] for _, o in archive)\n        max_obj2 = max(o[1] for _, o in archive)\n        norm_obj1 = obj1 / max_obj1 if max_obj1 > 0 else 0\n        norm_obj2 = obj2 / max_obj2 if max_obj2 > 0 else 0\n        return norm_obj1 + norm_obj2  # Simple sum for combined score\n\n    # Sort solutions by combined score (lower is better)\n    archive_sorted = sorted(archive, key=lambda x: combined_score(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Multi-objective edge-swap + 3-opt\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Multi-objective edge-swap\n    # Select two random edges (non-adjacent and non-overlapping)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2 or abs(i - j) > n - 2:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n\n    # Calculate combined cost of the edges\n    def edge_cost(a, b):\n        cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, a]\n        cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, a]\n        return cost1 + cost2\n\n    # Swap the edges if it improves both objectives\n    a, b = new_solution[i], new_solution[(i+1)%n]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    old_cost = edge_cost(a, b) + edge_cost(c, d)\n    new_cost = edge_cost(a, c) + edge_cost(b, d)\n\n    if new_cost < old_cost:\n        # Perform the swap\n        new_solution[(i+1)%n], new_solution[(j+1)%n] = new_solution[(j+1)%n], new_solution[(i+1)%n]\n\n    # Step 2: Multi-objective 3-opt on the affected segment\n    # Select a random segment of 3 edges\n    k = np.random.randint(0, n)\n    l = (k + 2) % n\n    m = (k + 4) % n\n\n    # Try all possible 3-opt moves on this segment\n    def try_3opt(a, b, c, d, e, f):\n        # Calculate old and new costs\n        old_cost = (distance_matrix_1[a,b] + distance_matrix_1[c,d] + distance_matrix_1[e,f] +\n                    distance_matrix_2[a,b] + distance_matrix_2[c,d] + distance_matrix_2[e,f])\n        new_cost = (distance_matrix_1[a,c] + distance_matrix_1[b,e] + distance_matrix_1[d,f] +\n                    distance_matrix_2[a,c] + distance_matrix_2[b,e] + distance_matrix_2[d,f])\n        return new_cost < old_cost\n\n    # Get the nodes in order\n    nodes = [new_solution[k], new_solution[(k+1)%n], new_solution[(k+2)%n], new_solution[(k+3)%n], new_solution[(k+4)%n]]\n\n    # Try all 3-opt permutations\n    if try_3opt(nodes[0], nodes[1], nodes[2], nodes[3], nodes[4], nodes[0]):\n        # Reconnect the tour in the new order\n        new_solution[(k+1)%n] = nodes[2]\n        new_solution[(k+2)%n] = nodes[1]\n        new_solution[(k+3)%n] = nodes[4]\n\n    return new_solution\n\n",
          "score": [
               -0.6432985605819139,
               6.86582350730896
          ]
     }
]