[
     {
          "algorithm": "{The proposed algorithm, named \"Objective-Centric Path Decomposition and Reconstruction with Dynamic Segment Fusion,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective dominance\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then reconstructed using a dynamic fusion strategy that merges segments of the same objective type while preserving their original order, followed by an \"objective-aware segment inversion\" phase that probabilistically reverses segments of one objective to explore alternative configurations. The method dynamically adjusts the decomposition and fusion parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on objective dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate edge contributions to each objective\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Determine if the edge belongs to objective 1 or 2\n        if cost1 > 1.5 * cost2 or cost2 > 1.5 * cost1:\n            # If significantly dominated by one objective, end current segment\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Dynamic segment fusion\n    merged_segments = []\n    i = 0\n    while i < len(segments):\n        current_obj = 1 if sum(distance_matrix_1[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1)) > \\\n                           sum(distance_matrix_2[segments[i][j], segments[i][j+1]] for j in range(len(segments[i])-1)) else 2\n\n        j = i + 1\n        while j < len(segments):\n            next_obj = 1 if sum(distance_matrix_1[segments[j][k], segments[j][k+1]] for k in range(len(segments[j])-1)) > \\\n                            sum(distance_matrix_2[segments[j][k], segments[j][k+1]] for k in range(len(segments[j])-1)) else 2\n\n            if current_obj == next_obj:\n                # Merge segments of the same objective\n                segments[i] = segments[i] + segments[j][1:]\n                j += 1\n            else:\n                break\n\n        merged_segments.append(segments[i])\n        i = j\n\n    # Step 4: Objective-aware segment inversion\n    for i in range(len(merged_segments)):\n        segment = merged_segments[i]\n        if len(segment) < 3:\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Decide whether to invert based on objective dominance\n        if cost1 > 1.3 * cost2:\n            # More dominated by objective 2, consider inversion\n            if random.random() < 0.5:\n                merged_segments[i] = segment[::-1]\n        elif cost2 > 1.3 * cost1:\n            # More dominated by objective 1, consider inversion\n            if random.random() < 0.5:\n                merged_segments[i] = segment[::-1]\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in merged_segments:\n        new_solution.extend(segment)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # If invalid, perform a simple segment reversal\n        if len(merged_segments) > 1:\n            i = random.randint(0, len(merged_segments)-1)\n            merged_segments[i] = merged_segments[i][::-1]\n            new_solution = []\n            for segment in merged_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9650858580707128,
               0.1937757134437561
          ]
     },
     {
          "algorithm": "{This novel algorithm, named \"Adaptive Objective-Driven Path Fusion and Multi-Space Edge Optimization,\" begins by identifying the solution in the archive with the highest combined objective value and then partitions it into multiple segments based on spatial clustering in both objective spaces. It then constructs a new solution by strategically fusing these segments through an adaptive path fusion process that prioritizes edges which show the most significant improvement in either objective space, while maintaining tour feasibility. The algorithm dynamically adjusts the fusion strategy based on the current solution's performance in both objectives, using a multi-space edge optimization phase to refine the tour by replacing edges with alternatives that offer better trade-offs between the objectives. The method employs a novel \"objective-aware edge selection\" mechanism that evaluates each edge's impact on both objectives before refinement, and includes a \"path diversity preservation\" step to ensure the solution maintains structural diversity while improving the objectives. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and includes a \"solution quality validation\" mechanism that verifies the new solution's feasibility before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Spatial clustering-based segmentation\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n\n        # Calculate distance in both spaces\n        dist1 = distance_matrix_1[prev_node, curr_node]\n        dist2 = distance_matrix_2[prev_node, curr_node]\n\n        # Check if the edge is \"significant\" in either space\n        if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n            segments.append(current_segment)\n            current_segment = [curr_node]\n        else:\n            current_segment.append(curr_node)\n    segments.append(current_segment)\n\n    # Step 3: Adaptive path fusion\n    merged_solution = []\n    for i in range(len(segments)):\n        seg = segments[i]\n        if not merged_solution:\n            merged_solution.extend(seg)\n            continue\n\n        # Find the best connection between current end and next segment start\n        last_node = merged_solution[-1]\n        next_seg = segments[(i+1) % len(segments)]\n        first_node = next_seg[0]\n\n        # Evaluate potential connections\n        candidates = []\n        for node in seg:\n            candidates.append((last_node, node))\n            candidates.append((node, first_node))\n\n        # Select the best connection based on objective improvement\n        best_candidate = None\n        best_improvement = -float('inf')\n\n        for (a, b) in candidates:\n            # Calculate improvement in both objectives\n            original_cost1 = distance_matrix_1[last_node, first_node]\n            new_cost1 = distance_matrix_1[a, b]\n            improvement1 = original_cost1 - new_cost1\n\n            original_cost2 = distance_matrix_2[last_node, first_node]\n            new_cost2 = distance_matrix_2[a, b]\n            improvement2 = original_cost2 - new_cost2\n\n            # Combine improvements with objective weights\n            obj1, obj2 = selected[1]\n            total_improvement = (improvement1 * obj1 + improvement2 * obj2) / (obj1 + obj2)\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_candidate = (a, b)\n\n        # Apply the best connection\n        if best_candidate:\n            a, b = best_candidate\n            if a == last_node:\n                merged_solution.extend(seg)\n            else:\n                # Find the node in seg that connects to first_node\n                connection_node = None\n                for node in seg:\n                    if node == b:\n                        connection_node = node\n                        break\n\n                if connection_node is not None:\n                    idx = np.where(seg == connection_node)[0][0]\n                    merged_solution.extend(seg[:idx+1])\n                    merged_solution.extend(seg[idx+1:])\n                else:\n                    merged_solution.extend(seg)\n        else:\n            merged_solution.extend(seg)\n\n    # Step 4: Multi-space edge optimization\n    for i in range(n):\n        current_node = merged_solution[i]\n        next_node = merged_solution[(i+1) % n]\n\n        # Find potential replacements\n        candidates = []\n        for j in range(n):\n            if j != i and j != (i+1) % n:\n                candidates.append((current_node, j, merged_solution[(i+1) % n]))\n\n        # Evaluate candidates\n        best_candidate = None\n        best_improvement = -float('inf')\n\n        for (a, b, c) in candidates:\n            # Calculate improvement in both objectives\n            original_cost1 = distance_matrix_1[a, c]\n            new_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n            improvement1 = original_cost1 - new_cost1\n\n            original_cost2 = distance_matrix_2[a, c]\n            new_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n            improvement2 = original_cost2 - new_cost2\n\n            # Combine improvements with objective weights\n            obj1, obj2 = selected[1]\n            total_improvement = (improvement1 * obj1 + improvement2 * obj2) / (obj1 + obj2)\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_candidate = (a, b, c)\n\n        # Apply the best replacement if it improves both objectives\n        if best_candidate and best_improvement > 0:\n            a, b, c = best_candidate\n            # Insert the new node\n            merged_solution = np.insert(merged_solution, (i+1) % n, b)\n            # Remove duplicates if any\n            unique_nodes = np.unique(merged_solution)\n            if len(unique_nodes) < n:\n                # Rebuild the solution if duplicates exist\n                remaining_nodes = [node for node in range(n) if node not in unique_nodes]\n                merged_solution = np.concatenate([unique_nodes, remaining_nodes])\n            # Ensure circular tour\n            if merged_solution[0] != merged_solution[-1]:\n                merged_solution = np.append(merged_solution, merged_solution[0])\n\n    # Step 5: Verify feasibility\n    if len(set(merged_solution)) != n or len(merged_solution) != n:\n        merged_solution = base_solution.copy()\n\n    return merged_solution\n\n",
          "score": [
               -0.9987503052685248,
               5.6584725975990295
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Objective-Driven Hybrid Segment Fusion with Dynamic Node Rebalancing,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first identifying and fusing the most complementary segments from different solutions in the archive, then dynamically rebalancing the tour by selectively replacing nodes based on their cross-dimensional contribution scores. This method combines segment fusion with a novel node replacement mechanism that evaluates each node's potential to improve both objectives simultaneously, using a probabilistic acceptance criterion that considers both immediate improvement and long-term solution balance, while maintaining tour feasibility through a two-phase validation process that checks both segment connectivity and node uniqueness.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the best segments from different solutions\n    best_segments = []\n    for solution, _ in archive[:3]:  # Consider top 3 solutions\n        n = len(solution)\n        segment_length = max(2, n // 5)\n        for i in range(0, n, segment_length):\n            segment = solution[i:i+segment_length]\n            if len(segment) > 1:\n                best_segments.append(segment)\n\n    if not best_segments:\n        best_segments = [archive[0][0][:3]]\n\n    # Step 2: Create initial solution by combining complementary segments\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    for seg in best_segments:\n        new_solution.extend(seg)\n        for node in seg:\n            remaining_nodes.discard(node)\n\n    # Step 3: Dynamic node rebalancing\n    for _ in range(3):  # Perform 3 rebalancing iterations\n        for i in range(len(new_solution)):\n            node = new_solution[i]\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i+1] if i < len(new_solution)-1 else new_solution[0]\n\n            # Calculate current contribution to both objectives\n            current_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                              distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Find potential replacement nodes\n            candidates = list(remaining_nodes)\n            if not candidates:\n                break\n\n            for candidate in candidates:\n                # Calculate potential new contribution\n                new_contrib = (distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node] +\n                              distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node])\n\n                # Accept if improvement in both objectives\n                if new_contrib < current_contrib * 0.95:  # 5% improvement threshold\n                    new_solution[i] = candidate\n                    remaining_nodes.add(node)\n                    remaining_nodes.remove(candidate)\n                    break\n\n    # Step 4: Insert remaining nodes\n    remaining_nodes = list(remaining_nodes)\n    while remaining_nodes:\n        best_node = None\n        best_pos = -1\n        best_score = float('inf')\n\n        for node in remaining_nodes:\n            for i in range(len(new_solution)):\n                if i == 0:\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                else:\n                    prev_node = new_solution[i-1]\n                    next_node = new_solution[i]\n\n                score = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                        distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n                    best_pos = i\n\n        if best_node is not None:\n            new_solution.insert(best_pos, best_node)\n            remaining_nodes.remove(best_node)\n        else:\n            new_solution.extend(remaining_nodes)\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(set(new_solution[:-1])) == len(instance), \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8144581164160893,
               0.09934872388839722
          ]
     },
     {
          "algorithm": "{This novel algorithm, named \"Adaptive Objective-Centric Tour Reconstruction with Dynamic Path Realignment,\" begins by selecting the solution from the archive with the most balanced objective values, then decomposes the tour into segments based on their primary objective contribution using a novel \"objective dominance\" metric. It then reconstructs the tour by strategically realigning these segments through a dynamic path fusion process that prioritizes edges which show the most significant improvement in either objective space, while maintaining tour feasibility. The algorithm dynamically adjusts the fusion strategy based on the current solution's performance in both objectives, using a multi-space edge optimization phase to refine the tour by replacing edges with alternatives that offer better trade-offs between the objectives. The method employs a novel \"objective-aware edge selection\" mechanism that evaluates each edge's impact on both objectives before refinement, and includes a \"path diversity preservation\" step to ensure the solution maintains structural diversity while improving the objectives. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and includes a \"solution quality validation\" mechanism that verifies the new solution's feasibility before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with most balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on objective dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate edge contributions to each objective\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Determine if the edge belongs to objective 1 or 2\n        if cost1 > 1.5 * cost2:\n            segments.append(current_segment)\n            current_segment = [current_node]\n        elif cost2 > 1.5 * cost1:\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Dynamic path realignment\n    merged_solution = []\n    for i in range(len(segments)):\n        current_seg = segments[i]\n        if not merged_solution:\n            merged_solution.extend(current_seg)\n            continue\n\n        # Find the best connection between current end and next segment start\n        last_node = merged_solution[-1]\n        next_seg = segments[(i+1) % len(segments)]\n        first_node = next_seg[0]\n\n        # Evaluate potential connections\n        candidates = []\n        for node in current_seg:\n            candidates.append((last_node, node, first_node))\n\n        best_candidate = None\n        best_improvement = -float('inf')\n\n        for (a, b, c) in candidates:\n            # Calculate improvement in both objectives\n            original_cost1 = distance_matrix_1[a, c]\n            new_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n            improvement1 = original_cost1 - new_cost1\n\n            original_cost2 = distance_matrix_2[a, c]\n            new_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n            improvement2 = original_cost2 - new_cost2\n\n            # Combine improvements with objective weights\n            obj1, obj2 = archive_sorted[0][1]\n            total_improvement = (improvement1 * obj1 + improvement2 * obj2) / (obj1 + obj2)\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_candidate = (a, b, c)\n\n        # Apply the best connection\n        if best_candidate and best_improvement > 0:\n            a, b, c = best_candidate\n            merged_solution.append(b)\n\n    # Complete the tour\n    merged_solution.extend(segments[-1][1:])\n    merged_solution.append(merged_solution[0])\n\n    # Step 4: Verify feasibility\n    unique_nodes = np.unique(merged_solution)\n    if len(unique_nodes) != n or len(merged_solution) != n + 1:\n        # If invalid, perform a simple segment reversal\n        i = random.randint(0, len(segments)-1)\n        segments[i] = segments[i][::-1]\n        merged_solution = []\n        for seg in segments:\n            merged_solution.extend(seg)\n        merged_solution.append(merged_solution[0])\n\n    return np.array(merged_solution)\n\n",
          "score": [
               -0.9701877202285001,
               0.23711872100830078
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Multi-Objective Segment Fusion with Adaptive Node Fusion and Objective-Weighted Reallocation,\" builds upon the segment-based approach but introduces a fundamentally different strategy by first identifying and fusing the most complementary segments from different solutions in the archive, then adaptively fusing nodes based on their cross-dimensional contribution scores, followed by an objective-weighted reallocation phase that probabilistically reorders segments to explore alternative configurations, while dynamically adjusting the fusion and reallocation parameters based on the current solution's objective balance, and ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on cross-dimensional contribution\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        total_cost = cost1 + cost2\n\n        if total_cost > 1.5 * (cost1 + cost2) / 2:  # High cross-dimensional variance\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Adaptive node fusion within segments\n    fused_segments = []\n    for segment in segments:\n        if len(segment) < 3:\n            fused_segments.append(segment)\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Adaptive fusion based on objective balance\n        if cost1 > 1.3 * cost2:\n            # Merge nodes with similar contribution to objective 1\n            fused_segment = []\n            i = 0\n            while i < len(segment):\n                if i + 1 < len(segment):\n                    node1 = segment[i]\n                    node2 = segment[i+1]\n                    contrib1 = distance_matrix_1[segment[i-1], node1] + distance_matrix_1[node1, node2]\n                    contrib2 = distance_matrix_1[segment[i-1], node2] + distance_matrix_1[node2, segment[i+2] if i+2 < len(segment) else segment[0]]\n\n                    if abs(contrib1 - contrib2) < 0.1 * (contrib1 + contrib2):\n                        fused_segment.append(node1)\n                        i += 2\n                    else:\n                        fused_segment.append(node1)\n                        i += 1\n                else:\n                    fused_segment.append(segment[i])\n                    i += 1\n            fused_segments.append(fused_segment)\n        else:\n            fused_segments.append(segment)\n\n    # Step 4: Objective-weighted segment reallocation\n    if len(fused_segments) > 1:\n        for i in range(len(fused_segments)):\n            if len(fused_segments[i]) < 2:\n                continue\n\n            cost1 = sum(distance_matrix_1[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n            cost2 = sum(distance_matrix_2[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n\n            if cost1 > 1.2 * cost2:\n                if random.random() < 0.5:\n                    # Reallocate nodes to better balance objectives\n                    segment = fused_segments[i]\n                    new_segment = []\n                    for j in range(len(segment)):\n                        node = segment[j]\n                        prev_node = segment[j-1] if j > 0 else segment[-1]\n                        next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                        if cost1 > 1.2 * cost2:\n                            # Find better node to replace with\n                            candidates = [k for k in range(len(instance)) if k not in segment]\n                            if candidates:\n                                best_node = None\n                                best_score = float('inf')\n                                for candidate in candidates:\n                                    new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                                    new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                                    score = abs(new_cost1 - new_cost2)\n                                    if score < best_score:\n                                        best_score = score\n                                        best_node = candidate\n                                if best_node is not None:\n                                    new_segment.append(best_node)\n                                else:\n                                    new_segment.append(node)\n                        else:\n                            new_segment.append(node)\n                    fused_segments[i] = new_segment\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            fused_segments[i] = fused_segments[i][::-1]\n            new_solution = []\n            for segment in fused_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9513067335199508,
               0.12776219844818115
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Objective-Centric Tour Decomposition with Cross-Objective Segment Fusion,\" builds upon the common backbone of solution selection and tour decomposition from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective-centric\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then fused across objectives using an adaptive strategy that dynamically combines segments from both objectives while maintaining their relative order, followed by a \"cross-objective segment interleaving\" phase that probabilistically interleaves segments from both objectives to explore alternative configurations. The method dynamically adjusts the decomposition and fusion parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into objective-centric segments\n    segments = []\n    current_segment = [new_solution[0]]\n    current_obj = None\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if current_obj is None:\n            if cost1 > cost2:\n                current_obj = 1\n            else:\n                current_obj = 2\n            current_segment.append(current_node)\n        else:\n            if (current_obj == 1 and cost1 < cost2 * 0.8) or (current_obj == 2 and cost2 < cost1 * 0.8):\n                segments.append((current_obj, current_segment))\n                current_segment = [current_node]\n                current_obj = 3 - current_obj  # Switch objective\n            else:\n                current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append((current_obj, current_segment))\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [(1, new_solution[:n//2]), (2, new_solution[n//2:])]\n\n    # Step 3: Cross-objective segment fusion\n    fused_segments = []\n    i = 0\n    while i < len(segments):\n        obj1, seg1 = segments[i]\n        if i + 1 < len(segments):\n            obj2, seg2 = segments[i+1]\n            if obj1 != obj2 and random.random() < 0.5:\n                # Fuse segments from different objectives\n                fused_segment = seg1 + seg2\n                fused_segments.append((obj1, fused_segment))\n                i += 2\n            else:\n                fused_segments.append((obj1, seg1))\n                i += 1\n        else:\n            fused_segments.append((obj1, seg1))\n            i += 1\n\n    # Step 4: Cross-objective segment interleaving\n    if len(fused_segments) > 1:\n        # Separate segments by objective\n        obj1_segments = [seg for obj, seg in fused_segments if obj == 1]\n        obj2_segments = [seg for obj, seg in fused_segments if obj == 2]\n\n        # Interleave segments from both objectives\n        new_solution = []\n        i, j = 0, 0\n        while i < len(obj1_segments) or j < len(obj2_segments):\n            if i < len(obj1_segments) and (j >= len(obj2_segments) or random.random() < 0.5):\n                new_solution.extend(obj1_segments[i])\n                i += 1\n            else:\n                new_solution.extend(obj2_segments[j])\n                j += 1\n\n    # Step 5: Reconstruct solution and validate\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            _, seg = fused_segments[i]\n            fused_segments[i] = (3 - fused_segments[i][0], seg[::-1])\n            new_solution = []\n            for _, seg in fused_segments:\n                new_solution.extend(seg)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8855038623380989,
               0.12278997898101807
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Objective-Aware Hybrid Segment Refinement with Dynamic Objective-Weighted Path Reordering,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms by first identifying promising solutions through archive analysis. Instead of decomposing tours into segments or clusters based on objective dominance or importance, it employs a novel hybrid approach that combines both segment decomposition and cluster refinement. It first decomposes the tour into segments based on objective dominance (similar to the first algorithm), then further refines these segments by clustering nodes within each segment based on their relative importance to each objective (similar to the second algorithm). These refined segments are then processed through a dynamic objective-weighted path reordering phase that probabilistically reorders nodes within segments while considering both objectives, followed by a hybrid segment inversion and cluster realignment phase that selectively reverses segments or clusters based on their objective contributions. The method continuously monitors the solution's objective balance and dynamically adjusts the decomposition, clustering, and reordering parameters to maintain a healthy balance between objectives, while ensuring feasibility through a comprehensive validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Calculate objective balance\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1))\n    balance = abs(total_cost1 - total_cost2) / (total_cost1 + total_cost2 + 1e-6)\n\n    # Step 2: Hybrid segment decomposition and clustering\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate edge contributions to each objective\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Determine if the edge belongs to objective 1 or 2\n        if cost1 > 1.5 * cost2 or cost2 > 1.5 * cost1:\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Refine segments with clustering\n    refined_segments = []\n    for segment in segments:\n        clusters = []\n        current_cluster = [segment[0]]\n        for i in range(1, len(segment)):\n            prev_node = segment[i-1]\n            current_node = segment[i]\n\n            # Calculate edge contributions to each objective\n            cost1 = distance_matrix_1[prev_node, current_node]\n            cost2 = distance_matrix_2[prev_node, current_node]\n\n            # Calculate weighted importance\n            importance1 = cost1 / (total_cost1 + 1e-6)\n            importance2 = cost2 / (total_cost2 + 1e-6)\n            weighted_importance = (1 - balance) * importance1 + balance * importance2\n\n            # Decide whether to start new cluster\n            if weighted_importance > 0.3 or random.random() < 0.2:\n                clusters.append(current_cluster)\n                current_cluster = [current_node]\n            else:\n                current_cluster.append(current_node)\n\n        if len(current_cluster) > 0:\n            clusters.append(current_cluster)\n\n        # Ensure at least one cluster exists\n        if len(clusters) == 0:\n            clusters = [segment.copy()]\n\n        refined_segments.append(clusters)\n\n    # Step 4: Dynamic objective-weighted path reordering\n    for i in range(len(refined_segments)):\n        clusters = refined_segments[i]\n        for j in range(len(clusters)):\n            cluster = clusters[j]\n            if len(cluster) < 3:\n                continue\n\n            # Calculate cluster costs\n            cluster_cost1 = sum(distance_matrix_1[cluster[k], cluster[k+1]] for k in range(len(cluster)-1))\n            cluster_cost2 = sum(distance_matrix_2[cluster[k], cluster[k+1]] for k in range(len(cluster)-1))\n\n            # Reorder nodes within cluster\n            if cluster_cost1 > cluster_cost2:\n                # More dominated by objective 1, try to reorder towards objective 2\n                for k in range(1, len(cluster)-1):\n                    if random.random() < 0.4:\n                        # Find the best position to insert the node\n                        best_pos = k\n                        best_cost1 = float('inf')\n                        best_cost2 = float('inf')\n\n                        for l in range(1, len(cluster)-1):\n                            if l == k:\n                                continue\n\n                            # Calculate potential improvement\n                            old_cost1 = distance_matrix_1[cluster[k-1], cluster[k]] + distance_matrix_1[cluster[k], cluster[k+1]]\n                            new_cost1 = distance_matrix_1[cluster[k-1], cluster[l]] + distance_matrix_1[cluster[l], cluster[k+1]]\n\n                            old_cost2 = distance_matrix_2[cluster[k-1], cluster[k]] + distance_matrix_2[cluster[k], cluster[k+1]]\n                            new_cost2 = distance_matrix_2[cluster[k-1], cluster[l]] + distance_matrix_2[cluster[l], cluster[k+1]]\n\n                            if (new_cost1 < best_cost1 and new_cost2 < best_cost2) or (random.random() < 0.3):\n                                best_pos = l\n                                best_cost1 = new_cost1\n                                best_cost2 = new_cost2\n\n                        if best_pos != k:\n                            # Perform the reordering\n                            node = cluster.pop(k)\n                            cluster.insert(best_pos, node)\n            else:\n                # More dominated by objective 2, try to reorder towards objective 1\n                for k in range(1, len(cluster)-1):\n                    if random.random() < 0.4:\n                        # Find the best position to insert the node\n                        best_pos = k\n                        best_cost1 = float('inf')\n                        best_cost2 = float('inf')\n\n                        for l in range(1, len(cluster)-1):\n                            if l == k:\n                                continue\n\n                            # Calculate potential improvement\n                            old_cost1 = distance_matrix_1[cluster[k-1], cluster[k]] + distance_matrix_1[cluster[k], cluster[k+1]]\n                            new_cost1 = distance_matrix_1[cluster[k-1], cluster[l]] + distance_matrix_1[cluster[l], cluster[k+1]]\n\n                            old_cost2 = distance_matrix_2[cluster[k-1], cluster[k]] + distance_matrix_2[cluster[k], cluster[k+1]]\n                            new_cost2 = distance_matrix_2[cluster[k-1], cluster[l]] + distance_matrix_2[cluster[l], cluster[k+1]]\n\n                            if (new_cost1 < best_cost1 and new_cost2 < best_cost2) or (random.random() < 0.3):\n                                best_pos = l\n                                best_cost1 = new_cost1\n                                best_cost2 = new_cost2\n\n                        if best_pos != k:\n                            # Perform the reordering\n                            node = cluster.pop(k)\n                            cluster.insert(best_pos, node)\n\n    # Step 5: Hybrid segment inversion and cluster realignment\n    for i in range(len(refined_segments)):\n        clusters = refined_segments[i]\n        for j in range(len(clusters)):\n            cluster = clusters[j]\n            if len(cluster) < 3:\n                continue\n\n            # Calculate cluster costs\n            cluster_cost1 = sum(distance_matrix_1[cluster[k], cluster[k+1]] for k in range(len(cluster)-1))\n            cluster_cost2 = sum(distance_matrix_2[cluster[k], cluster[k+1]] for k in range(len(cluster)-1))\n\n            # Decide whether to invert based on objective balance\n            if cluster_cost1 > cluster_cost2 and random.random() < 0.5 * (1 - balance):\n                clusters[j] = cluster[::-1]\n            elif cluster_cost2 > cluster_cost1 and random.random() < 0.5 * balance:\n                clusters[j] = cluster[::-1]\n\n    # Reconstruct solution\n    new_solution = []\n    for clusters in refined_segments:\n        for cluster in clusters:\n            new_solution.extend(cluster)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # If invalid, perform a simple cluster reversal\n        if len(refined_segments) > 0 and len(refined_segments[0]) > 1:\n            i = random.randint(0, len(refined_segments)-1)\n            j = random.randint(0, len(refined_segments[i])-1)\n            refined_segments[i][j] = refined_segments[i][j][::-1]\n            new_solution = []\n            for clusters in refined_segments:\n                for cluster in clusters:\n                    new_solution.extend(cluster)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9662728942653428,
               0.2537660002708435
          ]
     },
     {
          "algorithm": "{The novel algorithm, named \"Adaptive Objective-Aware Node Reordering with Dynamic Path Segmentation,\" departs from the provided approaches by first selecting the most balanced solution from the archive, then analyzing the node sequence through a dynamic path segmentation process that identifies critical transition points where the objective contributions change significantly. These segments are then reordered using an adaptive node reordering strategy that considers both local and global objective interactions, with a probabilistic approach that favors reorderings that improve both objectives while maintaining feasibility. The method dynamically adjusts the segmentation criteria based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a comprehensive validation mechanism that checks for node uniqueness, circularity, and objective consistency in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Calculate objective balance\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1))\n    balance = abs(total_cost1 - total_cost2) / (total_cost1 + total_cost2 + 1e-6)\n\n    # Step 2: Dynamic path segmentation\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Calculate objective ratio\n        ratio = cost1 / (cost2 + 1e-6)\n\n        # Determine if this is a critical transition point\n        if ratio > 1.5 or ratio < 0.6667:\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Adaptive node reordering\n    for i in range(len(segments)):\n        segment = segments[i]\n        if len(segment) < 3:\n            continue\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Determine reordering strategy based on objective balance\n        if segment_cost1 > segment_cost2 and random.random() < 0.7 * (1 - balance):\n            # Reorder nodes to prioritize objective 2\n            segment_sorted = sorted(segment[1:-1], key=lambda x: sum(distance_matrix_2[x, y] for y in segment[1:-1]))\n            segments[i] = [segment[0]] + segment_sorted + [segment[-1]]\n        elif segment_cost2 > segment_cost1 and random.random() < 0.7 * balance:\n            # Reorder nodes to prioritize objective 1\n            segment_sorted = sorted(segment[1:-1], key=lambda x: sum(distance_matrix_1[x, y] for y in segment[1:-1]))\n            segments[i] = [segment[0]] + segment_sorted + [segment[-1]]\n\n    # Step 4: Probabilistic segment reversal\n    for i in range(len(segments)):\n        if len(segments[i]) > 2 and random.random() < 0.3:\n            segments[i] = segments[i][0] + segments[i][-2:0:-1] + [segments[i][-1]]\n\n    # Reconstruct solution\n    new_solution = []\n    for segment in segments:\n        new_solution.extend(segment)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            segments[i] = segments[i][::-1]\n            new_solution = []\n            for segment in segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9293426952484541,
               0.22391223907470703
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Objective-Driven Segment Reallocation with Dynamic Neighborhood Expansion,\" builds upon the common backbone of solution selection from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective dominance\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then reallocated using an adaptive strategy that dynamically expands the neighborhood by considering both local and global segment interactions, followed by an \"objective-balanced segment permutation\" phase that probabilistically reorders segments to explore alternative configurations. The method dynamically adjusts the decomposition and reallocation parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on objective dominance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if cost1 > 1.2 * cost2 or cost2 > 1.2 * cost1:\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Adaptive segment reallocation with dynamic neighborhood expansion\n    expanded_segments = []\n    for segment in segments:\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Expand neighborhood by considering local and global interactions\n        if cost1 > 1.5 * cost2:\n            # Expand segment by merging with next segment if beneficial\n            if len(expanded_segments) > 0 and len(segments) > 1:\n                last_segment = expanded_segments[-1]\n                last_cost1 = sum(distance_matrix_1[last_segment[j], last_segment[j+1]] for j in range(len(last_segment)-1))\n                last_cost2 = sum(distance_matrix_2[last_segment[j], last_segment[j+1]] for j in range(len(last_segment)-1))\n\n                if last_cost1 > 1.5 * last_cost2:\n                    expanded_segments[-1] = last_segment + segment\n                    continue\n\n        expanded_segments.append(segment)\n\n    # Step 4: Objective-balanced segment permutation\n    if len(expanded_segments) > 1:\n        for i in range(len(expanded_segments)):\n            if len(expanded_segments[i]) < 3:\n                continue\n\n            cost1 = sum(distance_matrix_1[expanded_segments[i][j], expanded_segments[i][j+1]] for j in range(len(expanded_segments[i])-1))\n            cost2 = sum(distance_matrix_2[expanded_segments[i][j], expanded_segments[i][j+1]] for j in range(len(expanded_segments[i])-1))\n\n            if cost1 > 1.3 * cost2:\n                if random.random() < 0.6:\n                    expanded_segments[i] = expanded_segments[i][::-1]\n            elif cost2 > 1.3 * cost1:\n                if random.random() < 0.6:\n                    expanded_segments[i] = expanded_segments[i][::-1]\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = []\n    for segment in expanded_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(expanded_segments) > 1:\n            i = random.randint(0, len(expanded_segments)-1)\n            expanded_segments[i] = expanded_segments[i][::-1]\n            new_solution = []\n            for segment in expanded_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8696070846348665,
               0.1638835072517395
          ]
     },
     {
          "algorithm": "{The proposed algorithm, named \"Adaptive Objective-Space Warping with Dynamic Path Fusion,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms by first identifying promising solutions through archive analysis, but instead of decomposing tours into segments or clusters, it employs a novel objective-space warping approach that probabilistically transforms the solution's path in one objective space while dynamically fusing it with the original path in the other objective space, creating a hybrid path that maintains feasibility through a dynamic path fusion mechanism that ensures node uniqueness and circularity, while continuously monitoring the solution's objective balance to dynamically adjust the warping and fusion parameters to maintain a healthy balance between objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective balance\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1))\n    balance = abs(total_cost1 - total_cost2) / (total_cost1 + total_cost2 + 1e-6)\n\n    # Objective-space warping parameters\n    warp_intensity = 0.3 + 0.4 * balance\n    fusion_prob = 0.5 * (1 - balance)\n\n    # Create warped path in one objective space\n    warped_path = new_solution.copy()\n    for i in range(1, n-1):\n        if random.random() < warp_intensity:\n            # Randomly select a node to swap\n            j = random.randint(1, n-2)\n            if i != j:\n                warped_path[i], warped_path[j] = warped_path[j], warped_path[i]\n\n    # Dynamic path fusion\n    fused_path = []\n    for i in range(n):\n        if random.random() < fusion_prob:\n            fused_path.append(warped_path[i])\n        else:\n            fused_path.append(new_solution[i])\n\n    # Ensure circular tour\n    if fused_path[0] != fused_path[-1]:\n        fused_path.append(fused_path[0])\n\n    # Validate solution\n    unique_nodes = np.unique(fused_path)\n    if len(unique_nodes) != n or len(fused_path) != n + 1:\n        # If invalid, perform a simple path reversal\n        fused_path = fused_path[::-1]\n        fused_path.append(fused_path[0])\n\n    return np.array(fused_path)\n\n",
          "score": [
               -0.7997749098248199,
               0.18823844194412231
          ]
     }
]