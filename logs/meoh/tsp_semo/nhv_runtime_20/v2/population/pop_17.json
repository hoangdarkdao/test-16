[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"adaptive segment merge\" with \"objective-biased segment reversal\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment merge with objective-biased segment reversal\n    if n > 4:\n        # Objective-biased segment reversal\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves both objectives or one objective significantly\n        if (segment_cost1 > distance_matrix_1[segment[-1], segment[0]] and\n            segment_cost2 > distance_matrix_2[segment[-1], segment[0]]) or \\\n           (segment_cost1 > 1.2 * distance_matrix_1[segment[-1], segment[0]] or\n            segment_cost2 > 1.2 * distance_matrix_2[segment[-1], segment[0]]):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Adaptive segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8925259502193565,
            0.07236272096633911
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -1.0199334422006583,
            0.18807607889175415
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9955756972706151,
            0.19696515798568726
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining a novel \"node segment inversion\" with a \"distance-aware swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Weighted objective combination with diversity\n    weights = np.random.uniform(0.3, 0.7)\n    sorted_archive = sorted(archive, key=lambda x: (weights * x[1][0] + (1 - weights) * x[1][1]))\n    candidate_indices = min(4, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment inversion + distance-aware swap\n    if n > 5:\n        # Node segment inversion: Invert a segment of 3-5 nodes\n        segment_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n        # Distance-aware swap: Swap nodes that are far apart in either objective space\n        if n > 10:\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.009750535007263,
            0.3081088066101074
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9790134761382666,
            0.07310903072357178
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9957873510296426,
            0.3842282295227051
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9601362894719456,
            0.18925809860229492
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" and an additional \"node inversion\" step to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n            if np.random.random() < 0.3:\n                invert_start = np.random.randint(0, n - 2)\n                invert_end = np.random.randint(invert_start + 2, n)\n                new_solution[invert_start:invert_end] = new_solution[invert_start:invert_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9659346655023324,
            0.07538694143295288
        ]
    }
]