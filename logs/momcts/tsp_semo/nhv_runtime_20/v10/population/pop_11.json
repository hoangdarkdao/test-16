[
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted probability favoring solutions with lower average normalized objective values, then applies either a standard 2-opt operation or a novel segment inversion/reinsertion strategy to generate a neighbor solution while ensuring feasibility. The segment operation specifically inverts a random segment of the tour and reinserts it at the best position to minimize the combined cost of both objectives, providing a more exploratory local search compared to pure 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = objectives - objectives.min(axis=0)\n    normalized = normalized / (normalized.max(axis=0) + 1e-10)\n    weights = 1 - normalized.mean(axis=1)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 2-opt and segment inversion/reinsertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or segment operation\n    if random.random() < 0.5:\n        # 2-opt operation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment inversion and reinsertion\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.delete(new_solution, range(start, start+segment_length))\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Find best insertion point for inverted segment\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) + 1):\n            temp_solution = np.insert(remaining, pos, inverted_segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(remaining, best_pos, inverted_segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9353011851346344,
            1.5762245655059814
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing those with the lowest sum of normalized objectives, then applies a hybrid local search combining edge swapping and node insertion to explore diverse neighborhoods while ensuring feasibility. The selection is based on normalized objective values to balance trade-offs between the two objectives, while the local search operates on randomly chosen segments of the tour to avoid getting stuck in local optima. The critical design ideas are the intelligent selection of solutions and the hybrid local search strategy, which together aim to improve solution quality across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select segments to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge swap between i-j and k-l\n    new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    # Node insertion: move a random node to a new position\n    node_to_move = np.random.choice(new_solution)\n    pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    if pos != new_pos:\n        new_solution = np.insert(np.delete(new_solution, pos), new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8179669842566333,
            0.3183813691139221
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing Pareto-efficient solutions (non-dominated by others) and falling back to the lowest-sum objective if none exist. It then applies a hybrid local search combining segment reversal (randomly reversing a segment of the tour) and adaptive node relocation (probabilistically relocating nodes based on combined cost improvements in both objectives), ensuring feasibility by maintaining valid TSP tours throughout. The method balances exploration and exploitation through randomness and dynamic trade-off considerations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using Pareto-efficient front and objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        pareto_front[i] = not dominated\n\n    if np.any(pareto_front):\n        candidates = [i for i, is_pareto in enumerate(pareto_front) if is_pareto]\n        selected_idx = np.random.choice(candidates)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + adaptive node relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment reversal\n    start = np.random.randint(0, n-2)\n    end = np.random.randint(start+2, min(start+10, n))\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive node relocation\n    for _ in range(2):\n        node = np.random.choice(new_solution)\n        current_pos = np.where(new_solution == node)[0][0]\n\n        # Calculate potential insertion positions based on both objectives\n        costs = []\n        for pos in range(n):\n            if pos == current_pos:\n                costs.append(np.inf)\n                continue\n\n            temp_sol = np.delete(new_solution, current_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            costs.append((cost1 + cost2) * (1 + np.random.uniform(-0.1, 0.1)))\n\n        best_pos = np.argmin(costs)\n        if costs[best_pos] < np.inf:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9538456537192214,
            10.783259153366089
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search that randomly chooses between node swaps or edge insertions to generate a neighbor solution while ensuring feasibility. It selects from the top 10 solutions (or fewer if the archive is small) and verifies the new solution has no duplicates or missing nodes. The method balances exploration (random selection) with exploitation (focusing on lower-cost solutions) while maintaining valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower objectives (prioritize non-dominated solutions)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(10, len(archive_sorted) - 1)  # Select from top 10 or all if fewer\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    # Hybrid local search: combine node swaps and edge insertions\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between swap or insertion\n    if random.random() < 0.5:\n        # Node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge insertion\n        if n >= 3:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            # Remove segment from i to j and reinsert at a random position\n            segment = new_solution[i:j+1]\n            remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.8861771732022544,
            3.430252432823181
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive with high potential for improvement by normalizing and combining its two objective values, then applies a hybrid local search that either performs edge insertion (removing and reinserting a node) or node swapping (exchanging two nodes) to generate a neighbor solution while ensuring feasibility. The selection prioritizes solutions with worse fitness (higher combined normalized objectives) to explore less-explored regions, while the local search balances exploration and exploitation through randomized edge manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Compute normalized objectives for selection\n    obj1 = np.array([obj[0] for obj in archive_objectives])\n    obj2 = np.array([obj[1] for obj in archive_objectives])\n\n    # Normalize objectives\n    if len(obj1) > 1:\n        obj1 = (obj1 - np.min(obj1)) / (np.max(obj1) - np.min(obj1) + 1e-10)\n        obj2 = (obj2 - np.min(obj2)) / (np.max(obj2) - np.min(obj2) + 1e-10)\n\n    # Compute a combined fitness score (lower is better)\n    fitness = obj1 + obj2\n\n    # Select the solution with the highest fitness (most potential for improvement)\n    selected_idx = np.argmax(fitness)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor solution using a hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to modify\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Hybrid local search: combine edge insertion and node swapping\n    if np.random.rand() < 0.5:\n        # Edge insertion: remove edge (i, i+1) and insert it between (j, j+1)\n        removed_node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, removed_node)\n    else:\n        # Node swapping: swap nodes at positions i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8780519228388297,
            1.816645324230194
        ]
    },
    {
        "algorithm": "The algorithm combines weighted selection of solutions based on normalized objective values with a hybrid local search that dynamically partitions tours into segments, inverts them probabilistically based on their contribution to objectives, and reinserts them optimally, while also applying probabilistic edge swaps to refine the solution. It balances exploration and exploitation by adapting segment size and inversion probability to the segment's impact on objectives, ensuring feasibility and promoting diverse high-quality solutions across the bi-objective space. The selection prioritizes solutions with lower objective sums, while the local search intelligently explores the solution space through segment manipulation and edge swapping.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized objective sum\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    weights = 1 / (scores + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment partitioning and inversion\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Calculate the segment's contribution to each objective\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n    total_seg_cost = seg_cost1 + seg_cost2\n\n    # Dynamic inversion probability based on segment contribution\n    inversion_prob = min(0.9, 0.5 + (total_seg_cost / (seg_cost1 + seg_cost2 + 1e-10)) * 0.4)\n\n    if random.random() < inversion_prob:\n        segment = segment[::-1]\n\n    # Find best insertion point for the segment\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    # Probabilistic edge swapping\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.903495168346596,
            4.518869042396545
        ]
    },
    {
        "algorithm": "The algorithm selects a solution from the archive and applies a hybrid local search combining 3-opt with a custom edge-swap heuristic to generate a neighbor solution, ensuring feasibility by checking for duplicate nodes and missing nodes. The selection prioritizes solutions with promising potential for improvement, while the hybrid search balances exploration and exploitation across both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with a custom edge-swap heuristic\n    n = len(new_solution)\n    if n >= 4:\n        # Randomly select three edges to modify (3-opt)\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Custom edge-swap heuristic: Swap edges in both objective spaces\n        for _ in range(2):  # Perform 2 edge swaps\n            a, b = np.random.choice(range(n), 2, replace=False)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    assert len(set(new_solution)) == len(selected_solution), \"Invalid solution: Duplicate nodes\"\n    assert len(new_solution) == len(selected_solution), \"Invalid solution: Missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8380232830229785,
            1.871150016784668
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects a solution from the archive using Pareto dominance and hybrid normalization (prioritizing the first objective 60% and the second 40%), then applies a segment-based local search combining inversion, reinsertion, and edge refinement to explore diverse neighborhoods while ensuring feasibility. It balances improvement across objectives by evaluating both distance matrices during segment insertion and refinement. The selection process uses weighted random choice based on normalized objective values, while the local search dynamically adapts segment lengths and performs constrained optimizations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using Pareto dominance and hybrid normalization\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-10)\n    weights = 1 - (normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4)  # Weighted sum\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid segment-based local search\n    if n < 4:\n        # Simple swap for small tours\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment inversion with constrained reinsertion\n        segment_len = random.randint(2, min(4, n//3))\n        start = random.randint(0, n - segment_len)\n        segment = new_solution[start:start+segment_len]\n\n        # Invert and find best insertion point\n        inverted = segment[::-1]\n        remaining = np.delete(new_solution, range(start, start+segment_len))\n\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) - segment_len + 1):\n            temp = np.insert(remaining, pos, inverted)\n            cost1 = sum(distance_matrix_1[temp[i-1], temp[i]] for i in range(len(temp)))\n            cost2 = sum(distance_matrix_2[temp[i-1], temp[i]] for i in range(len(temp)))\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n\n        new_solution = np.insert(remaining, best_pos, inverted)\n\n        # Edge refinement\n        for _ in range(min(2, n//4)):\n            i, j = sorted(random.sample(range(n), 2))\n            if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n               distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8752180633859628,
            3.6663344502449036
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto dominance-based weighted selection, then applies a hybrid local search combining segment inversion with dynamic edge swapping to generate a neighbor solution while ensuring feasibility. It prioritizes solutions on the Pareto front, uses segment inversion and edge swapping for exploration, and evaluates insertion points to balance cost reduction across both objectives. The solution is validated to ensure no nodes are skipped or revisited.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto dominance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and all(other_obj <= obj):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        # Fallback to normalized objective selection if no Pareto front\n        normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        scores = np.sum(normalized_objectives, axis=1)\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = np.random.choice(pareto_front)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search\n    if n >= 4:\n        # Segment inversion with dynamic edge swapping\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.delete(new_solution, range(start, start+segment_length))\n\n        # Invert segment\n        inverted_segment = segment[::-1]\n\n        # Dynamic edge swapping\n        if random.random() < 0.7:  # Higher probability for edge swapping\n            swap_pos = random.randint(0, len(remaining)-1)\n            if swap_pos + 1 < len(remaining):\n                remaining[swap_pos], remaining[swap_pos+1] = remaining[swap_pos+1], remaining[swap_pos]\n\n        # Find best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) + 1):\n            temp_solution = np.insert(remaining, pos, inverted_segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(remaining, best_pos, inverted_segment)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != len(new_solution):\n        return base_solution  # Revert to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8783820153000428,
            6.625280737876892
        ]
    },
    {
        "algorithm": "The algorithm selects a high-potential solution from the archive (based on normalized objective product) and applies a hybrid local search combining segment reversal and node relocation, prioritizing improvement of the worst-performing objective. It ensures feasibility by maintaining valid TSP tours throughout operations. The selection focuses on Pareto-efficient regions, while the search strategically targets objective-specific improvements.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product (Pareto-efficient focus)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.prod(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment reversal + node relocation\n    # Reverse a segment to potentially improve worst objective\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Relocate node to improve worst objective\n    worst_obj = np.argmax(objectives[selected_idx])\n    if worst_obj == 0:\n        current_cost = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    else:\n        current_cost = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    best_cost = current_cost\n    best_pos = -1\n    node_to_move = np.random.choice(new_solution)\n\n    for pos in range(n):\n        temp_solution = np.insert(np.delete(new_solution, np.where(new_solution == node_to_move)[0][0]), pos, node_to_move)\n        if worst_obj == 0:\n            new_cost = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        else:\n            new_cost = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        if new_cost < best_cost:\n            best_cost = new_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        pos = np.where(new_solution == node_to_move)[0][0]\n        new_solution = np.insert(np.delete(new_solution, pos), best_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8448759490322407,
            5.057128846645355
        ]
    }
]