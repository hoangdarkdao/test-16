[
    {
        "algorithm": "{This algorithm implements a novel multi-objective adaptive path inversion strategy that combines probabilistic segment inversion with dynamic node reinsertion and intelligent segment reordering, dynamically balancing improvements across both objectives through adaptive weight adjustment and path quality evaluation while ensuring feasibility through path validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(1, min(3, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segments.append(new_solution[start:end])\n\n    for segment in segments:\n        if len(segment) < 2:\n            continue\n\n        segment = segment.copy()\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution) - len(segment) + 1):\n            candidate = new_solution.copy()\n            candidate[pos:pos+len(segment)] = segment\n\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n\n            weight = 0.7 if (pos == 0 or pos == len(new_solution) - len(segment)) else 0.3\n            score = weight * cost1 + (1 - weight) * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution[best_pos:best_pos+len(segment)] = segment\n\n    remaining_nodes = list(set(range(n)) - set(new_solution))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution) + 1):\n            candidate = np.insert(new_solution, pos, node)\n\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n\n            weight = 0.8 if (pos == 0 or pos == len(new_solution)) else 0.2\n            score = weight * cost1 + (1 - weight) * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            8.330893410295563,
            4.4166464509761925
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel path-splitting and reassembly strategy that divides the tour into multiple segments, randomly permutes these segments, and then intelligently reinserts them using a multi-objective segment alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with intelligent segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on current solution quality\n            current_cost1, current_cost2 = calculate_cost(reassembled)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.484883794537127,
            8.87657962803985
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel path-splitting and reassembly strategy that divides the tour into multiple segments, randomly permutes these segments, and then intelligently reinserts them using a multi-objective segment alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with intelligent segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on current solution quality\n            current_cost1, current_cost2 = calculate_cost(reassembled)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.484883794537127,
            8.87657962803985
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel multi-objective adaptive segment exchange strategy that combines probabilistic segment selection with dynamic segment swapping and intelligent node reinsertion, dynamically balancing improvements across both objectives through adaptive weight adjustment and segment quality evaluation while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection and exchange\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(2, min(3, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segments.append(new_solution[start:end])\n\n    # Dynamic segment swapping\n    if len(segments) > 1 and random.random() < 0.7:\n        swap_indices = random.sample(range(len(segments)), 2)\n        segments[swap_indices[0]], segments[swap_indices[1]] = segments[swap_indices[1]], segments[swap_indices[0]]\n\n    # Rebuild solution with intelligent segment insertion\n    reassembled = []\n    for segment in segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find best position to insert the segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Dynamic weight based on segment position\n            if pos == 0 or pos == len(reassembled):\n                weight = 0.6  # Higher weight for endpoints\n            else:\n                weight = 0.4\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Node reinsertion with multi-objective consideration\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on node position\n            if pos == 0 or pos == len(reassembled):\n                weight = 0.8  # Higher weight for endpoints\n            else:\n                weight = 0.2\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    # Ensure no duplicates and all nodes are present\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            8.119620236806579,
            4.441711426708227
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel multi-objective adaptive path inversion strategy that combines probabilistic segment inversion with dynamic node reinsertion and intelligent segment reordering, dynamically balancing improvements across both objectives through adaptive weight adjustment and path quality evaluation while ensuring feasibility through path validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(1, min(3, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segments.append(new_solution[start:end])\n\n    for segment in segments:\n        if len(segment) < 2:\n            continue\n\n        segment = segment.copy()\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution) - len(segment) + 1):\n            candidate = new_solution.copy()\n            candidate[pos:pos+len(segment)] = segment\n\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n\n            weight = 0.7 if (pos == 0 or pos == len(new_solution) - len(segment)) else 0.3\n            score = weight * cost1 + (1 - weight) * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution[best_pos:best_pos+len(segment)] = segment\n\n    remaining_nodes = list(set(range(n)) - set(new_solution))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution) + 1):\n            candidate = np.insert(new_solution, pos, node)\n\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n\n            weight = 0.8 if (pos == 0 or pos == len(new_solution)) else 0.2\n            score = weight * cost1 + (1 - weight) * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            8.330893410295563,
            4.4166464509761925
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel path-splitting and reassembly strategy that divides the tour into multiple segments, randomly permutes these segments, and then intelligently reinserts them using a multi-objective segment alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with intelligent segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on current solution quality\n            current_cost1, current_cost2 = calculate_cost(reassembled)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.484883794537127,
            8.87657962803985
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel multi-objective adaptive segment exchange strategy that combines probabilistic segment selection with dynamic segment swapping and intelligent node reinsertion, dynamically balancing improvements across both objectives through adaptive weight adjustment and segment quality evaluation while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection and exchange\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(2, min(3, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segments.append(new_solution[start:end])\n\n    # Dynamic segment swapping\n    if len(segments) > 1 and random.random() < 0.7:\n        swap_indices = random.sample(range(len(segments)), 2)\n        segments[swap_indices[0]], segments[swap_indices[1]] = segments[swap_indices[1]], segments[swap_indices[0]]\n\n    # Rebuild solution with intelligent segment insertion\n    reassembled = []\n    for segment in segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find best position to insert the segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Dynamic weight based on segment position\n            if pos == 0 or pos == len(reassembled):\n                weight = 0.6  # Higher weight for endpoints\n            else:\n                weight = 0.4\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Node reinsertion with multi-objective consideration\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on node position\n            if pos == 0 or pos == len(reassembled):\n                weight = 0.8  # Higher weight for endpoints\n            else:\n                weight = 0.2\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    # Ensure no duplicates and all nodes are present\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            8.119620236806579,
            4.441711426708227
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel path-reversal and segment-merging strategy that identifies critical segments in the tour, reverses their order to disrupt the current structure, and then intelligently merges adjacent segments using a multi-objective alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    random.shuffle(segments)\n\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    merged = []\n    for segment in segments:\n        if not merged:\n            merged = segment.tolist()\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(merged) + 1):\n            candidate = merged[:pos] + segment.tolist() + merged[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(merged)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[merged[k-1], merged[k]] for k in range(len(merged))) + sum(distance_matrix_2[merged[k-1], merged[k]] for k in range(len(merged))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        merged = merged[:best_pos] + segment.tolist() + merged[best_pos:]\n\n    _, unique_indices = np.unique(merged, return_index=True)\n    new_solution = np.array(merged)[np.sort(unique_indices)]\n\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.5524715097896555,
            8.362876361479778
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel segment-shuffling and adaptive-insertion strategy that divides the tour into segments, shuffles them with a multi-objective alignment heuristic, and intelligently reinserts segments based on adaptive weights that balance both objectives while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with adaptive segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Adaptive weight based on segment length and current solution quality\n            segment_length = len(segment)\n            total_length = len(reassembled) + segment_length\n            weight = 0.5 * (segment_length / total_length) + 0.5 * (1 - (segment_length / total_length))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.619311199652927,
            5.525104042188829
        ]
    },
    {
        "algorithm": "{This algorithm implements a hybrid multi-objective path relinking strategy combining adaptive path extraction with probabilistic segment crossover and intelligent node reinsertion, dynamically balancing improvements across both objectives through weighted cost evaluation while ensuring feasibility through path validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Path extraction with adaptive length\n    path_length = max(2, min(5, int(n * 0.3)))\n    start_idx = random.randint(0, n - path_length)\n    extracted_path = new_solution[start_idx:start_idx + path_length]\n\n    # Probabilistic segment crossover\n    if random.random() < 0.7 and len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n        crossover_point = random.randint(1, len(extracted_path) - 1)\n        extracted_path = np.concatenate([extracted_path[:crossover_point], other_solution[crossover_point:crossover_point + len(extracted_path) - crossover_point]])\n\n    # Find best position to insert the path\n    best_pos = 0\n    best_score = float('inf')\n    for pos in range(len(new_solution) - len(extracted_path) + 1):\n        candidate = np.concatenate([new_solution[:pos], extracted_path, new_solution[pos + len(extracted_path):]])\n\n        cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n\n        # Dynamic weight based on path quality\n        path_cost1 = sum(distance_matrix_1[extracted_path[k-1], extracted_path[k]] for k in range(1, len(extracted_path)))\n        path_cost2 = sum(distance_matrix_2[extracted_path[k-1], extracted_path[k]] for k in range(1, len(extracted_path)))\n        weight = 0.5 + 0.5 * np.tanh(path_cost1 + path_cost2)\n\n        score = weight * cost1 + (1 - weight) * cost2\n\n        if score < best_score:\n            best_score = score\n            best_pos = pos\n\n    new_solution = np.concatenate([new_solution[:best_pos], extracted_path, new_solution[best_pos + len(extracted_path):]])\n\n    # Node reinsertion with multi-objective consideration\n    remaining_nodes = list(set(range(n)) - set(new_solution))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution) + 1):\n            candidate = np.insert(new_solution, pos, node)\n\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n\n            # Weighted score based on node position\n            if pos == 0 or pos == len(new_solution):\n                weight = 0.8\n            else:\n                weight = 0.2\n\n            score = weight * cost1 + (1 - weight) * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure no duplicates and all nodes are present\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            8.024116921430974,
            4.9177122505762405
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel path-splitting and reassembly strategy that divides the tour into multiple segments, randomly permutes these segments, and then intelligently reinserts them using a multi-objective segment alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with intelligent segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on current solution quality\n            current_cost1, current_cost2 = calculate_cost(reassembled)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.484883794537127,
            8.87657962803985
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel adaptive segment relinking strategy that combines multi-objective segment extraction with probabilistic segment merging and intelligent node reinsertion, dynamically balancing improvements across both objectives through adaptive segment selection and weighted cost evaluation while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment extraction and relinking\n    segment_length = max(2, min(5, int(n * 0.25)))\n    num_segments = random.randint(2, min(4, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segments.append(new_solution[start:end])\n\n    # Probabilistic segment merging\n    if random.random() < 0.6 and len(segments) > 1:\n        merge_idx = random.randint(0, len(segments) - 2)\n        segments[merge_idx] = np.concatenate([segments[merge_idx], segments[merge_idx + 1]])\n        del segments[merge_idx + 1]\n\n    # Rebuild solution with intelligent segment insertion\n    reassembled = []\n    for segment in segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find best position to insert the segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Dynamic weight based on segment quality\n            segment_cost1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n            segment_cost2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n            weight = 0.5 + 0.5 * np.tanh(segment_cost1 + segment_cost2)\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Node reinsertion with multi-objective consideration\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on node position\n            if pos == 0 or pos == len(reassembled):\n                weight = 0.7  # Higher weight for endpoints\n            else:\n                weight = 0.3\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    # Ensure no duplicates and all nodes are present\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            7.11013638985262,
            4.938421725393732
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel multi-objective adaptive segment exchange strategy that combines probabilistic segment selection with dynamic segment swapping and intelligent node reinsertion, dynamically balancing improvements across both objectives through adaptive weight adjustment and segment quality evaluation while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection and exchange\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(2, min(3, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segments.append(new_solution[start:end])\n\n    # Dynamic segment swapping\n    if len(segments) > 1 and random.random() < 0.7:\n        swap_indices = random.sample(range(len(segments)), 2)\n        segments[swap_indices[0]], segments[swap_indices[1]] = segments[swap_indices[1]], segments[swap_indices[0]]\n\n    # Rebuild solution with intelligent segment insertion\n    reassembled = []\n    for segment in segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find best position to insert the segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Dynamic weight based on segment position\n            if pos == 0 or pos == len(reassembled):\n                weight = 0.6  # Higher weight for endpoints\n            else:\n                weight = 0.4\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Node reinsertion with multi-objective consideration\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on node position\n            if pos == 0 or pos == len(reassembled):\n                weight = 0.8  # Higher weight for endpoints\n            else:\n                weight = 0.2\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    # Ensure no duplicates and all nodes are present\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            8.119620236806579,
            4.441711426708227
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid approach that combines a probabilistic segment inversion with a multi-objective node insertion heuristic, where segments are randomly inverted and refined through adaptive node insertions guided by a Pareto-based selection criterion to balance improvements across both objectives while ensuring solution feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Probabilistic segment inversion with adaptive segment length\n    if random.random() < 0.7:  # Increased chance to 70%\n        segment_length = max(2, min(5, int(n * 0.2)))  # Adaptive segment length\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective node insertion with adaptive selection\n    for _ in range(3):  # Increased to 3 rounds\n        # Select a random node to remove\n        remove_idx = random.randint(1, n-1)\n        node = new_solution[remove_idx]\n        temp_solution = np.concatenate([new_solution[:remove_idx], new_solution[remove_idx+1:]])\n\n        # Find best insertion position for the removed node\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(1, n):\n            # Insert node at position pos\n            candidate = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n                return cost1, cost2\n\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Modified weight calculation based on relative improvement\n            weight = 0.5 + 0.5 * np.tanh((current_cost1 - candidate_cost1) + (current_cost2 - candidate_cost2))\n\n            # Weighted score with different balance\n            score = (1 - weight) * candidate_cost1 + weight * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.concatenate([temp_solution[:best_pos], [node], temp_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.633452515673034,
            5.405026437418702
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel path-splitting and reassembly strategy that divides the tour into multiple segments, randomly permutes these segments, and then intelligently reinserts them using a multi-objective segment alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with intelligent segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on current solution quality\n            current_cost1, current_cost2 = calculate_cost(reassembled)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.484883794537127,
            8.87657962803985
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel segment-based local search that divides the tour into segments, applies a multi-objective aware segment swap and reverse operation, and reconstructs the tour using a dynamic balance between objectives to create high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into segments\n    num_segments = random.randint(2, min(4, n // 3))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Apply segment swap and reverse operations\n    for i in range(len(segments)):\n        if random.random() < 0.7:\n            j = (i + 1) % len(segments)\n            if random.random() < 0.5:\n                segments[i], segments[j] = segments[j], segments[i]\n            else:\n                segments[i] = segments[i][::-1]\n\n    # Reconstruct the tour with dynamic objective balancing\n    reassembled = []\n    current_cost1 = 0\n    current_cost2 = 0\n\n    for segment in segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            current_cost1 = sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled)))\n            current_cost2 = sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled)))\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n        total_current_cost = current_cost1 + current_cost2\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Dynamic weight based on current solution quality\n            weight = 0.4 * (current_cost1 / total_current_cost) + 0.6 * (current_cost2 / total_current_cost)\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n        current_cost1, current_cost2 = calculate_cost(reassembled)\n\n    # Validate and repair the solution\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.882929493868174,
            5.361975308153313
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel adaptive segment relinking strategy that combines multi-objective segment extraction with probabilistic segment merging and intelligent node reinsertion, dynamically balancing improvements across both objectives through adaptive segment selection and weighted cost evaluation while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment extraction and relinking\n    segment_length = max(2, min(5, int(n * 0.25)))\n    num_segments = random.randint(2, min(4, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segments.append(new_solution[start:end])\n\n    # Probabilistic segment merging\n    if random.random() < 0.6 and len(segments) > 1:\n        merge_idx = random.randint(0, len(segments) - 2)\n        segments[merge_idx] = np.concatenate([segments[merge_idx], segments[merge_idx + 1]])\n        del segments[merge_idx + 1]\n\n    # Rebuild solution with intelligent segment insertion\n    reassembled = []\n    for segment in segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find best position to insert the segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Dynamic weight based on segment quality\n            segment_cost1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n            segment_cost2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n            weight = 0.5 + 0.5 * np.tanh(segment_cost1 + segment_cost2)\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Node reinsertion with multi-objective consideration\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on node position\n            if pos == 0 or pos == len(reassembled):\n                weight = 0.7  # Higher weight for endpoints\n            else:\n                weight = 0.3\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    # Ensure no duplicates and all nodes are present\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            7.11013638985262,
            4.938421725393732
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid approach that combines a probabilistic segment inversion with a multi-objective node insertion heuristic, where segments are randomly inverted and refined through adaptive node insertions guided by a Pareto-based selection criterion to balance improvements across both objectives while ensuring solution feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Probabilistic segment inversion with adaptive segment length\n    if random.random() < 0.7:  # Increased chance to 70%\n        segment_length = max(2, min(5, int(n * 0.2)))  # Adaptive segment length\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective node insertion with adaptive selection\n    for _ in range(3):  # Increased to 3 rounds\n        # Select a random node to remove\n        remove_idx = random.randint(1, n-1)\n        node = new_solution[remove_idx]\n        temp_solution = np.concatenate([new_solution[:remove_idx], new_solution[remove_idx+1:]])\n\n        # Find best insertion position for the removed node\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(1, n):\n            # Insert node at position pos\n            candidate = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n                return cost1, cost2\n\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Modified weight calculation based on relative improvement\n            weight = 0.5 + 0.5 * np.tanh((current_cost1 - candidate_cost1) + (current_cost2 - candidate_cost2))\n\n            # Weighted score with different balance\n            score = (1 - weight) * candidate_cost1 + weight * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.concatenate([temp_solution[:best_pos], [node], temp_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.633452515673034,
            5.405026437418702
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel path-splitting and reassembly strategy that divides the tour into multiple segments, randomly permutes these segments, and then intelligently reinserts them using a multi-objective segment alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with intelligent segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on current solution quality\n            current_cost1, current_cost2 = calculate_cost(reassembled)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.484883794537127,
            8.87657962803985
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel path-splitting and reassembly strategy that divides the tour into multiple segments, randomly permutes these segments, and then intelligently reinserts them using a multi-objective segment alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with intelligent segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on current solution quality\n            current_cost1, current_cost2 = calculate_cost(reassembled)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.484883794537127,
            8.87657962803985
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid approach that combines a probabilistic segment inversion with a multi-objective node insertion heuristic, where segments are randomly inverted and refined through adaptive node insertions guided by a Pareto-based selection criterion to balance improvements across both objectives while ensuring solution feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Probabilistic segment inversion with adaptive segment length\n    if random.random() < 0.7:  # Increased chance to 70%\n        segment_length = max(2, min(5, int(n * 0.2)))  # Adaptive segment length\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective node insertion with adaptive selection\n    for _ in range(3):  # Increased to 3 rounds\n        # Select a random node to remove\n        remove_idx = random.randint(1, n-1)\n        node = new_solution[remove_idx]\n        temp_solution = np.concatenate([new_solution[:remove_idx], new_solution[remove_idx+1:]])\n\n        # Find best insertion position for the removed node\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(1, n):\n            # Insert node at position pos\n            candidate = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n                return cost1, cost2\n\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Modified weight calculation based on relative improvement\n            weight = 0.5 + 0.5 * np.tanh((current_cost1 - candidate_cost1) + (current_cost2 - candidate_cost2))\n\n            # Weighted score with different balance\n            score = (1 - weight) * candidate_cost1 + weight * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.concatenate([temp_solution[:best_pos], [node], temp_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.633452515673034,
            5.405026437418702
        ]
    },
    {
        "algorithm": "{This algorithm implements a multi-segment crossover and local optimization strategy that combines segments from multiple archive solutions, applies a novel segment alignment heuristic to balance the objectives, and refines the tour using a multi-objective local search that considers both distance matrices simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 3 solutions from archive based on combined objective score\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solutions = [sol[0] for sol in archive_sorted[:min(3, len(archive))]]\n\n    # Create segments from selected solutions\n    segments = []\n    for sol in selected_solutions:\n        n = len(sol)\n        num_segments = random.randint(2, min(4, n // 3))\n        split_points = sorted(random.sample(range(1, n), num_segments - 1))\n        prev = 0\n        for point in split_points:\n            segments.append(sol[prev:point])\n            prev = point\n        segments.append(sol[prev:])\n\n    # Randomly select segments to form a new solution\n    new_solution = []\n    used_nodes = set()\n    while len(new_solution) < len(instance):\n        segment = random.choice(segments)\n        for node in segment:\n            if node not in used_nodes and len(new_solution) < len(instance):\n                new_solution.append(node)\n                used_nodes.add(node)\n\n    # Apply local search to optimize the new solution\n    n = len(new_solution)\n    improved = True\n    while improved:\n        improved = False\n        for i in range(n):\n            for j in range(i + 2, min(i + 10, n)):\n                # Calculate current and candidate costs\n                current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n                current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n                # Create candidate solution\n                candidate = new_solution.copy()\n                candidate[i:j] = candidate[i:j][::-1]\n\n                candidate_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n                candidate_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n\n                # Accept if both objectives improve\n                if candidate_cost1 < current_cost1 and candidate_cost2 < current_cost2:\n                    new_solution = candidate\n                    improved = True\n                    break\n            if improved:\n                break\n\n    return np.array(new_solution)\n\n",
        "score": [
            5.962465247831155,
            5.566945216451205
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid approach that combines a probabilistic segment inversion with a multi-objective node insertion heuristic, where segments are randomly inverted and refined through adaptive node insertions guided by a Pareto-based selection criterion to balance improvements across both objectives while ensuring solution feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Probabilistic segment inversion with adaptive segment length\n    if random.random() < 0.7:  # Increased chance to 70%\n        segment_length = max(2, min(5, int(n * 0.2)))  # Adaptive segment length\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective node insertion with adaptive selection\n    for _ in range(3):  # Increased to 3 rounds\n        # Select a random node to remove\n        remove_idx = random.randint(1, n-1)\n        node = new_solution[remove_idx]\n        temp_solution = np.concatenate([new_solution[:remove_idx], new_solution[remove_idx+1:]])\n\n        # Find best insertion position for the removed node\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(1, n):\n            # Insert node at position pos\n            candidate = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n                return cost1, cost2\n\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Modified weight calculation based on relative improvement\n            weight = 0.5 + 0.5 * np.tanh((current_cost1 - candidate_cost1) + (current_cost2 - candidate_cost2))\n\n            # Weighted score with different balance\n            score = (1 - weight) * candidate_cost1 + weight * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.concatenate([temp_solution[:best_pos], [node], temp_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.633452515673034,
            5.405026437418702
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel path-splitting and reassembly strategy that divides the tour into multiple segments, randomly permutes these segments, and then intelligently reinserts them using a multi-objective segment alignment heuristic to create a balanced neighbor solution while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Split the tour into multiple segments\n    num_segments = random.randint(2, min(5, n // 2))\n    split_points = sorted(random.sample(range(1, n), num_segments - 1))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    # Randomly permute the segments\n    random.shuffle(segments)\n\n    # Reassemble the tour with intelligent segment insertion\n    reassembled = []\n    for i, segment in enumerate(segments):\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        # Find the best position to insert the current segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Weighted score based on current solution quality\n            current_cost1, current_cost2 = calculate_cost(reassembled)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the segment at the best position\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    # Ensure all nodes are included and no duplicates\n    _, unique_indices = np.unique(reassembled, return_index=True)\n    new_solution = np.array(reassembled)[np.sort(unique_indices)]\n\n    # If any nodes are missing, add them at random positions\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.484883794537127,
            8.87657962803985
        ]
    },
    {
        "algorithm": "{This algorithm implements a dynamic segment insertion heuristic that adaptively combines segments from multiple solutions in the archive with a Pareto-guided edge refinement step, using objective-specific distance matrices to guide the selection of non-dominated segments and refining the tour through a multi-phase edge swapping process with adaptive acceptance criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined score (normalized objectives)\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        normalized_cost1 = cost1 / distance_matrix_1.max() if distance_matrix_1.max() > 0 else 0\n        normalized_cost2 = cost2 / distance_matrix_2.max() if distance_matrix_2.max() > 0 else 0\n        scores.append(normalized_cost1 + normalized_cost2)\n    selected_idx = np.argmin(scores)\n    base_solution, (base_cost1, base_cost2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment insertion from multiple solutions\n    if len(archive) > 2 and random.random() < 0.8:\n        num_solutions_to_use = min(3, len(archive) - 1)\n        other_indices = random.sample([i for i in range(len(archive)) if i != selected_idx], num_solutions_to_use)\n\n        for idx in other_indices:\n            other_sol, _ = archive[idx]\n            start, end = sorted(random.sample(range(n), 2))\n            segment = other_sol[start:end]\n\n            # Find optimal insertion point using distance matrices\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(len(new_solution) - len(segment) + 1):\n                candidate = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:]\n                ])\n                _, unique_indices = np.unique(candidate, return_index=True)\n                candidate = candidate[np.sort(unique_indices)]\n\n                cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n                combined_cost = cost1 + cost2\n\n                if combined_cost < min_cost:\n                    min_cost = combined_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n            _, unique_indices = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(unique_indices)]\n\n            missing_nodes = set(range(n)) - set(new_solution)\n            if missing_nodes:\n                for node in missing_nodes:\n                    insert_pos = random.randint(0, len(new_solution))\n                    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Multi-phase edge refinement with Pareto acceptance\n    for phase in range(2):\n        for _ in range(2 if phase == 0 else 3):\n            i, j = sorted(random.sample(range(n), 2))\n\n            candidate = new_solution.copy()\n            candidate[i:j] = candidate[i:j][::-1]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n                return cost1, cost2\n\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Adaptive Pareto acceptance\n            if phase == 0:\n                if (candidate_cost1 <= current_cost1 and candidate_cost2 < current_cost2) or \\\n                   (candidate_cost1 < current_cost1 and candidate_cost2 <= current_cost2):\n                    new_solution = candidate\n            else:\n                if (candidate_cost1 <= current_cost1 * 1.02 and candidate_cost2 < current_cost2 * 1.02) or \\\n                   (candidate_cost1 < current_cost1 * 1.02 and candidate_cost2 <= current_cost2 * 1.02):\n                    new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            5.612607355708424,
            5.782685461410917
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid approach that combines a probabilistic segment inversion with a multi-objective node insertion heuristic, where segments are randomly inverted and refined through adaptive node insertions guided by a Pareto-based selection criterion to balance improvements across both objectives while ensuring solution feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Probabilistic segment inversion\n    if random.random() < 0.6:  # 60% chance to apply segment inversion\n        start, end = sorted(random.sample(range(n), 2))\n        if end - start > 1:  # Only invert if segment has at least 2 nodes\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective node insertion with adaptive selection\n    for _ in range(2):  # Perform 2 rounds of node insertion\n        # Select a random node to remove\n        remove_idx = random.randint(1, n-1)\n        node = new_solution[remove_idx]\n        temp_solution = np.concatenate([new_solution[:remove_idx], new_solution[remove_idx+1:]])\n\n        # Find best insertion position for the removed node\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(1, n):\n            # Insert node at position pos\n            candidate = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n\n            # Calculate costs for both objectives\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n                return cost1, cost2\n\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            # Adaptive weight based on current solution quality\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)))\n\n            # Weighted score with different parameters\n            score = (0.7 * candidate_cost1 + 0.3 * candidate_cost2) * (1 + 0.1 * (candidate_cost1 + candidate_cost2) / (current_cost1 + current_cost2))\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Perform the best insertion\n        new_solution = np.concatenate([temp_solution[:best_pos], [node], temp_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            5.4071649156322215,
            7.005426108240839
        ]
    }
]